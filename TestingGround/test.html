<!DOCTYPE html>
<html lang="nl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactieve Studiegids: Webdesign</title>
    <style>
        :root {
            --primary-bg: #f4f7f9;
            --secondary-bg: #ffffff;
            --sidebar-bg: #1e293b;
            --sidebar-text: #cbd5e1;
            --sidebar-hover-bg: #334155;
            --sidebar-active-bg: #475569;
            --text-color: #0f172a;
            --accent-color: #3b82f6;
            --border-color: #e2e8f0;
            --code-bg: #f1f5f9;
            --success-bg: #dcfce7;
            --success-color: #166534;
            --error-bg: #fee2e2;
            --error-color: #991b1b;
            --header-height: 64px;
            --content-max-width: 1200px;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji';
            line-height: 1.7;
            margin: 0;
            background-color: var(--primary-bg);
            color: var(--text-color);
            display: flex;
        }

        #sidebar {
            width: 280px;
            background-color: var(--sidebar-bg);
            color: var(--sidebar-text);
            padding: 20px;
            height: calc(100vh - var(--header-height));
            top: var(--header-height);
            left: 0;
            overflow-y: auto;
            position: fixed;
            border-right: 1px solid var(--border-color);
            z-index: 1000;
            transition: transform 0.3s ease-in-out;
        }

        #sidebar h2 {
            margin-top: 0;
            color: var(--secondary-bg);
            font-size: 1.5rem;
        }

        #sidebar ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }

        #sidebar>ul>li>a {
            font-weight: 600;
            font-size: 1.1rem;
            margin-top: 15px;
        }

        #sidebar ul ul {
            padding-left: 15px;
            border-left: 1px solid #475569;
            margin-left: 5px;
        }

        #sidebar a {
            text-decoration: none;
            color: var(--sidebar-text);
            display: block;
            padding: 8px 10px;
            border-radius: 6px;
            transition: background-color 0.2s ease;
        }

        #sidebar a:hover {
            background-color: var(--sidebar-hover-bg);
        }

        #sidebar a.active {
            background-color: var(--accent-color);
            color: white;
        }

        #main-content {
            margin-left: 280px;
            padding: calc(var(--header-height) + 16px) 40px 25px 40px;
            width: calc(100% - 280px);
            transition: margin-left 0.3s ease-in-out;
        }

        section {
            background-color: var(--secondary-bg);
            padding: 25px;
            margin-bottom: 30px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            scroll-margin-top: calc(var(--header-height) + 16px);
        }

        h1,
        h2,
        h3,
        h4,
        h5 {
            color: #1e293b;
        }

        h1,
        h2,
        h3 {
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }

        h1 {
            font-size: 2.2rem;
        }

        h2 {
            font-size: 1.8rem;
        }

        h3 {
            font-size: 1.4rem;
        }

        h4 {
            font-size: 1.2rem;
        }

        h5 {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
        }

        pre {
            background-color: var(--code-bg);
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            border: 1px solid var(--border-color);
            margin-top: 10px;
        }

        code {
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
            background-color: var(--code-bg);
            padding: 3px 6px;
            border-radius: 4px;
        }

        pre>code {
            padding: 0;
            background: none;
        }

        .exercise {
            border: 1px dashed var(--accent-color);
            padding: 20px;
            margin-top: 25px;
            border-radius: 8px;
            background-color: #fafcff;
        }

        .exercise textarea {
            width: 100%;
            min-height: 150px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            padding: 10px;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
            font-size: 14px;
            margin-top: 10px;
            box-sizing: border-box;
        }

        .exercise-solution {
            display: none;
            margin-top: 15px;
            border-left: 3px solid var(--accent-color);
            padding-left: 15px;
            background-color: #f8f9fa;
        }

        .validator-result {
            padding: 12px;
            border-radius: 6px;
            margin-top: 10px;
            font-weight: 500;
        }

        .validator-result.success {
            background-color: var(--success-bg);
            color: var(--success-color);
        }

        .validator-result.error {
            background-color: var(--error-bg);
            color: var(--error-color);
        }

        button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 10px;
            margin-right: 10px;
            font-weight: 500;
            transition: background-color 0.2s ease;
        }

        button:hover {
            background-color: #2563eb;
        }

        button.secondary {
            background-color: #64748b;
        }

        button.secondary:hover {
            background-color: #475569;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th,
        td {
            border: 1px solid var(--border-color);
            padding: 12px;
            text-align: left;
        }

        th {
            background-color: var(--primary-bg);
        }

        blockquote {
            border-left: 4px solid var(--accent-color);
            padding-left: 15px;
            margin-left: 0;
            font-style: italic;
            color: #475569;
        }

        .live-example {
            border: 1px solid var(--border-color);
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            background-color: #fafbff;
        }

        /* Top navigation bar */
        #topbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height);
            background-color: var(--secondary-bg);
            border-bottom: 1px solid var(--border-color);
            z-index: 1002;
        }

        #topbar .topbar-inner {
            max-width: var(--content-max-width);
            margin: 0 auto;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            padding: 0 16px;
        }

        #topbar .brand {
            font-weight: 700;
            color: #1e293b;
        }

        #topbar nav a {
            text-decoration: none;
            color: var(--text-color);
            padding: 8px 10px;
        }

        #topbar nav a:hover {
            background-color: var(--primary-bg);
        }

        /* Centered content container */
        .container {
            max-width: var(--content-max-width);
            margin: 0 auto;
        }

        /* --- Responsive Styles --- */
        #menu-toggle {
            display: none;
            /* Hidden by default on large screens */
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 1003;
            background-color: var(--sidebar-bg);
            color: white;
            border: 1px solid var(--sidebar-hover-bg);
            width: 40px;
            height: 40px;
            padding: 0;
            font-size: 24px;
            line-height: 40px;
            text-align: center;
        }

        #overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }

        /* Styles for screens smaller than 992px */
        @media (max-width: 991px) {
            #menu-toggle {
                display: block;
            }

            #sidebar {
                transform: translateX(-100%);
            }

            #sidebar.visible {
                transform: translateX(0);
            }

            #main-content {
                margin-left: 0;
                width: 100%;
                padding: calc(var(--header-height) + 8px) 20px 20px 20px;
            }

            #topbar nav {
                display: none;
            }

            #overlay.visible {
                display: block;
            }
        }

        /* Extra small adjustments */
        @media (max-width: 600px) {
            h1 {
                font-size: 1.8rem;
            }

            h2 {
                font-size: 1.5rem;
            }

            h3 {
                font-size: 1.25rem;
            }

            table {
                display: block;
                overflow-x: auto;
                white-space: nowrap;
            }
        }

        /* Very large screens (e.g., TV) */
        @media (min-width: 1600px) {
            html {
                font-size: 18px;
            }

            :root {
                --content-max-width: 1400px;
            }
        }
    </style>
</head>

<body>

    <button id="menu-toggle" aria-label="Toggle Menu" aria-controls="sidebar" aria-expanded="false">&#9776;</button>
    <div id="overlay"></div>

    <header id="topbar" role="banner">
        <div class="topbar-inner margin-top:">
            <div><img src="./Images/PixelToCode.png" style="height: 70px;"></img></div>
            <div class="brand">PixelToCode</div>
            <nav aria-label="Hoofdnavigatie">
                <a href="#html">HTML</a>
                <a href="#css">CSS</a>
                <a href="#javascript">JavaScript</a>
                <a href="#typescript">TypeScript</a>
            </nav>
        </div>
    </header>

    <nav id="sidebar">
        <h2>Studiegids</h2>
        <ul>
            <li><a href="#html">HTML</a>
                <ul>
                    <li><a href="#html-doc-meta">Document & Metadata</a></li>
                    <li><a href="#html-sections">Secties & Semantiek</a></li>
                    <li><a href="#html-text">Tekst & Inline</a></li>
                    <li><a href="#html-lists-tables">Lijsten & Tabellen</a></li>
                    <li><a href="#html-media">Media & Inbedding</a></li>
                    <li><a href="#html-forms">Formulieren</a></li>
                    <li><a href="#html-interactive">Interactieve Elementen</a></li>
                    <li><a href="#html-layout-overview">Layout Overzicht</a></li>
                    <li><a href="#html-actuele-elementen">Actuele Elementen</a></li>
                    <li><a href="#html-actuele-attributen">Actuele Attributen</a></li>
                    <li><a href="#html-aria">ARIA</a></li>
                    <li><a href="#html-cheatsheet">Cheatsheet</a></li>
                </ul>
            </li>
            <li><a href="#css">CSS</a>
                <ul>
                    <li><a href="#css-basics">Basis & Selectors</a></li>
                    <li><a href="#css-pseudo-classes">Pseudo-classes</a></li>
                    <li><a href="#css-pseudo-elements">Pseudo-elements</a></li>
                    <li><a href="#css-box-model">Box Model & Sizing</a></li>
                    <li><a href="#css-layout">Layout (Flex & Grid)</a></li>
                    <li><a href="#css-typography">Typografie & Tekst</a></li>
                    <li><a href="#css-backgrounds">Achtergronden & Effecten</a></li>
                    <li><a href="#css-motion">Transities & Animaties</a></li>
                    <li><a href="#css-responsive">Responsive Design</a></li>
                    <li><a href="#css-cheatsheet">Cheatsheet</a></li>
                </ul>
            </li>
            <li><a href="#javascript">JavaScript</a>
                <ul>
                    <li><a href="#js-syntax">Syntax & Statements</a></li>
                    <li><a href="#js-comments">Comments</a></li>
                    <li><a href="#js-variables">Variabelen (var, let, const)</a></li>
                    <li><a href="#js-operators">Operatoren</a></li>
                    <li><a href="#js-data-types">Datatypes</a></li>
                    <li><a href="#js-functions">Functies</a></li>
                    <li><a href="#js-objects">Objecten</a></li>
                    <li><a href="#js-arrays">Arrays</a></li>
                    <li><a href="#js-conditionals">Conditionals (If/Else, Switch)</a></li>
                    <li><a href="#js-loops">Loops (For, While)</a></li>
                    <li><a href="#js-iterators">Iterators</a></li>
                    <li><a href="#js-typeof">typeof</a></li>
                    <li><a href="#js-tostring">toString()</a></li>
                    <li><a href="#js-cheatsheet">Cheatsheet</a></li>
                </ul>
            </li>
            <li><a href="#typescript">TypeScript</a>
                <ul>
                    <li><a href="#ts-intro">Introductie & Setup</a></li>
                    <li><a href="#ts-types">Types (Basis & Geavanceerd)</a></li>
                    <li><a href="#ts-interfaces">Interfaces & Classes</a></li>
                    <li><a href="#ts-enums">Enums & Generics</a></li>
                    <li><a href="#ts-modules">Modules</a></li>
                    <li><a href="#ts-dom">DOM-manipulatie</a></li>
                    <li><a href="#ts-cheatsheet">Cheatsheet</a></li>
                </ul>
            </li>
        </ul>
    </nav>

    <main id="main-content">
        <div class="container">
            <h1>Interactieve Studiegids Webdesign</h1>
            <p>Welkom bij je persoonlijke, interactieve studiegids. Gebruik de navigatie aan de linkerkant om snel door
                de onderwerpen te bladeren. Elk hoofdstuk bevat theorie, codevoorbeelden en oefeningen om je kennis te
                testen.</p>

            <!-- ====================================================================== -->
            <!-- ============================= HTML =================================== -->
            <!-- ====================================================================== -->
            <section id="html">
                <h2>HTML: HyperText Markup Language</h2>
                <p>HTML vormt de ruggengraat van elke webpagina. Het definieert de structuur en de semantische betekenis
                    van de content.</p>
            </section>

            <section id="html-doc-meta">
                <h3>Document & Metadata</h3>
                <p>Deze elementen definiëren de algemene eigenschappen van een HTML-document.</p>

                <h4><code>&lt;!DOCTYPE html&gt;</code></h4>
                <p>Activeert de "standards mode" in browsers. Dit moet altijd de allereerste regel van je document zijn.
                </p>

                <h4><code>&lt;html&gt;</code></h4>
                <p>Het root-element van de pagina. Het `lang` attribuut is cruciaal voor toegankelijkheid en SEO.</p>
                <pre><code>&lt;html lang="nl"&gt;...&lt;/html&gt;</code></pre>

                <h4><code>&lt;head&gt;</code></h4>
                <p>Bevat alle metadata: scripts, stylesheets, en andere informatie die niet direct op de pagina
                    zichtbaar is.</p>

                <h4><code>&lt;title&gt;</code></h4>
                <p>De titel van de pagina, zichtbaar in de browser-tab en in zoekmachineresultaten. Vereist in elk
                    document.</p>
                <pre><code>&lt;title&gt;Mijn Studiegids Webdesign&lt;/title&gt;</code></pre>

                <h4><code>&lt;meta&gt;</code></h4>
                <p>Voor diverse metadata zoals tekenset, viewport-instellingen voor mobiele apparaten, en
                    paginabeschrijving.</p>
                <pre><code>&lt;meta charset="UTF-8"&gt;
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
&lt;meta name="description" content="Een korte beschrijving van de pagina."&gt;</code></pre>

                <h4><code>&lt;link&gt;</code></h4>
                <p>Linkt naar externe bronnen, voornamelijk stylesheets, maar ook voor iconen, fonts, en PWA-manifesten.
                </p>
                <pre><code>&lt;link rel="stylesheet" href="styles.css"&gt;
&lt;link rel="icon" href="/favicon.ico"&gt;</code></pre>

                <h4><code>&lt;script&gt;</code> & <code>&lt;noscript&gt;</code></h4>
                <p>Laadt en executeert JavaScript. Het `defer` attribuut stelt de executie uit tot na het parsen van de
                    HTML. `async` laadt en voert uit zodra mogelijk. `noscript` toont een fallback als JavaScript
                    uitgeschakeld is.</p>
                <pre><code>&lt;script src="app.js" defer&gt;&lt;/script&gt;
&lt;noscript&gt;JavaScript is vereist voor deze site.&lt;/noscript&gt;</code></pre>

                <div class="exercise">
                    <h4>Oefening H1-01: Documentkop opzetten</h4>
                    <p>Maak een correcte HTML5-documentkop met een doctype, Nederlandse taal, UTF-8 charset, een
                        mobielvriendelijke viewport en een titel.</p>
                    <textarea id="ex-h1-01" placeholder="Plaats hier je volledige HTML-structuur..."></textarea>
                    <button class="check-btn" data-exercise="h1-01">Controleer</button>
                    <button class="solution-btn secondary">Toon Oplossing</button>
                    <div class="validator-result"></div>
                    <div class="exercise-solution">
                        <pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="nl"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Mijn Oefenpagina&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
                    </div>
                </div>
            </section>

            <section id="html-sections">
                <h3>Secties & Semantiek</h3>
                <p>Semantische HTML gebruikt elementen die hun betekenis duidelijk maken, wat goed is voor
                    toegankelijkheid (schermlezers) en SEO.</p>
                <ul>
                    <li><code>&lt;body&gt;</code>: Bevat alle zichtbare content.</li>
                    <li><code>&lt;header&gt;</code>: Introductiecontent of navigatiehulpmiddelen. Kan per document of
                        per sectie/artikel gebruikt worden.</li>
                    <li><code>&lt;nav&gt;</code>: Een sectie met navigatielinks. Geef het een `aria-label` als er
                        meerdere zijn.</li>
                    <li><code>&lt;main&gt;</code>: De unieke, centrale content van de pagina. Er mag maar één
                        `&lt;main&gt;` element per pagina zijn.</li>
                    <li><code>&lt;section&gt;</code>: Een thematische groepering van content, typisch met een kop.</li>
                    <li><code>&lt;article&gt;</code>: Zelfstandige, op zichzelf staande content (bv. een blogpost,
                        nieuwsartikel).</li>
                    <li><code>&lt;aside&gt;</code>: Content die indirect gerelateerd is aan de hoofdcontent (bv. een
                        sidebar).</li>
                    <li><code>&lt;footer&gt;</code>: Voettekst voor een document of sectie (bv. auteur, copyright).</li>
                    <li><code>&lt;address&gt;</code>: Contactinformatie voor het dichtstbijzijnde artikel of de body.
                    </li>
                    <li><code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code>: Koppen voor het structureren van content.
                        Gebruik ze hiërarchisch.</li>
                </ul>
                <div class="exercise">
                    <h4>Oefening H2-01: Semantische layout</h4>
                    <p>Structureer een eenvoudige blogpostpagina met een header, navigatie, hoofdcontent met een
                        artikel, een sidebar en een footer.</p>
                    <textarea id="ex-h2-01" placeholder="Plaats hier je body-structuur..."></textarea>
                    <button class="check-btn" data-exercise="h2-01">Controleer</button>
                    <button class="solution-btn secondary">Toon Oplossing</button>
                    <div class="validator-result"></div>
                    <div class="exercise-solution">
                        <pre><code>&lt;header&gt;
    &lt;h1&gt;Mijn Blog&lt;/h1&gt;
&lt;/header&gt;
&lt;nav aria-label="Hoofdnavigatie"&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;a href="#"&gt;Home&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/nav&gt;
&lt;main&gt;
    &lt;article&gt;
        &lt;h2&gt;Titel van de post&lt;/h2&gt;
        &lt;p&gt;Inhoud van de post...&lt;/p&gt;
    &lt;/article&gt;
&lt;/main&gt;
&lt;aside&gt;
    &lt;h3&gt;Over de auteur&lt;/h3&gt;
&lt;/aside&gt;
&lt;footer&gt;
    &lt;p&gt;&copy; 2025&lt;/p&gt;
&lt;/footer&gt;</code></pre>
                    </div>
                </div>
            </section>

            <section id="html-text">
                <h3>Tekst & Inline Semantiek</h3>
                <p>Deze elementen geven betekenis aan specifieke stukjes tekst binnen een groter blok, zoals een
                    paragraaf. Dit is cruciaal voor SEO, toegankelijkheid en de standaard styling van de browser.</p>

                <h4><code>&lt;p&gt;</code>: Paragraaf</h4>
                <p>Het <code>&lt;p&gt;</code>-element groepeert een alinea tekst. Browsers voegen doorgaans een
                    witruimte (marge) boven en onder elke paragraaf toe om ze visueel te scheiden.</p>
                <pre><code>&lt;p&gt;Dit is de eerste paragraaf. Het bevat meerdere zinnen die samen een logisch geheel vormen.&lt;/p&gt;
&lt;p&gt;Dit is een tweede, afzonderlijke paragraaf.&lt;/p&gt;</code></pre>
                <div class="live-example">
                    <p>Dit is de eerste paragraaf. Het bevat meerdere zinnen die samen een logisch geheel vormen.</p>
                    <p>Dit is een tweede, afzonderlijke paragraaf.</p>
                </div>

                <h4><code>&lt;a&gt;</code>: Anker (Hyperlink)</h4>
                <p>Het anker-element (<code>&lt;a&gt;</code>) maakt een hyperlink naar andere webpagina's, bestanden,
                    locaties binnen dezelfde pagina, of e-mailadressen. Het <code>href</code>-attribuut is essentieel en
                    bevat de bestemming van de link.</p>
                <pre><code>&lt;p&gt;Bezoek onze &lt;a href="#"&gt;homepage&lt;/a&gt; of stuur ons een &lt;a href="mailto:info@example.com"&gt;e-mail&lt;/a&gt;.&lt;/p&gt;</code></pre>
                <div class="live-example">
                    <p>Bezoek onze <a href="#">homepage</a> of stuur ons een <a
                            href="mailto:info@example.com">e-mail</a>.</p>
                </div>

                <h4><code>&lt;strong&gt;</code> & <code>&lt;em&gt;</code>: Belangrijkheid en Nadruk</h4>
                <p>Deze elementen voegen semantische betekenis toe. <code>&lt;strong&gt;</code> markeert tekst die van
                    groot belang is (bv. een waarschuwing). <code>&lt;em&gt;</code> (emphasis) legt nadruk op een woord
                    of zin, wat de betekenis kan veranderen. Visueel worden ze vaak als <strong>vet</strong> en
                    <em>cursief</em> weergegeven.
                </p>
                <pre><code>&lt;p&gt;&lt;strong&gt;Waarschuwing:&lt;/strong&gt; raak de draden niet aan.&lt;/p&gt;
&lt;p&gt;Ik ben &lt;em&gt;zeer&lt;/em&gt; benieuwd naar het resultaat.&lt;/p&gt;</code></pre>
                <div class="live-example">
                    <p><strong>Waarschuwing:</strong> raak de draden niet aan.</p>
                    <p>Ik ben <em>zeer</em> benieuwd naar het resultaat.</p>
                </div>

                <h4><code>&lt;span&gt;</code>: Generieke Inline Container</h4>
                <p>De <code>&lt;span&gt;</code> is een inline-element zonder enige semantische betekenis. Het is puur
                    bedoeld als een 'haakje' om een specifiek stukje tekst te kunnen stijlen met CSS of te manipuleren
                    met JavaScript, zonder de betekenis van de tekst te veranderen.</p>
                <pre><code>&lt;p&gt;Dit is normale tekst, maar &lt;span style="color: red; font-weight: bold;"&gt;dit stukje&lt;/span&gt; is rood en vet gemaakt met een span.&lt;/p&gt;</code></pre>
                <div class="live-example">
                    <p>Dit is normale tekst, maar <span style="color: red; font-weight: bold;">dit stukje</span> is rood
                        en vet gemaakt met een span.</p>
                </div>

                <h4><code>&lt;br&gt;</code>: Regeleinde</h4>
                <p>Het <code>&lt;br&gt;</code> (break) element forceert een regeleinde. Het is een leeg element. Gebruik
                    het spaarzaam, bijvoorbeeld in adressen of gedichten waar de regeleindes belangrijk zijn. Gebruik
                    geen <code>&lt;br&gt;</code> om witruimte tussen paragrafen te creëren; gebruik daarvoor CSS
                    margins.</p>
                <pre><code>&lt;p&gt;Mijn Adres:&lt;br&gt;Voorbeeldstraat 123&lt;br&gt;1000 Brussel&lt;/p&gt;</code></pre>
                <div class="live-example">
                    <p>Mijn Adres:<br>Voorbeeldstraat 123<br>1000 Brussel</p>
                </div>

                <h4><code>&lt;q&gt;</code> & <code>&lt;blockquote&gt;</code>: Citaten</h4>
                <p>Gebruik <code>&lt;q&gt;</code> voor korte, inline citaten. Browsers plaatsen hier automatisch
                    aanhalingstekens omheen. Voor langere citaten die een eigen alinea vormen, gebruik je
                    <code>&lt;blockquote&gt;</code>. Dit element wordt door browsers meestal ingesprongen weergegeven.
                </p>
                <pre><code>&lt;p&gt;De spreker zei, &lt;q&gt;Dit is een korte, maar krachtige boodschap.&lt;/q&gt;&lt;/p&gt;
&lt;blockquote cite="http://example.com"&gt;
  Dit is een langer citaat dat een volledig blok tekst beslaat. Het wordt vaak gebruikt voor getuigenissen of belangrijke passages uit een andere bron.
&lt;/blockquote&gt;</code></pre>
                <div class="live-example">
                    <p>De spreker zei, <q>Dit is een korte, maar krachtige boodschap.</q></p>
                    <blockquote cite="http://example.com">
                        Dit is een langer citaat dat een volledig blok tekst beslaat. Het wordt vaak gebruikt voor
                        getuigenissen of belangrijke passages uit een andere bron.
                    </blockquote>
                </div>

                <h4><code>&lt;code&gt;</code> & <code>&lt;pre&gt;</code>: Computercode</h4>
                <p>Het <code>&lt;code&gt;</code>-element wordt gebruikt om een stukje computercode te markeren. Voor
                    codeblokken van meerdere regels, waarbij witruimte en regeleindes behouden moeten blijven, plaats je
                    het <code>&lt;code&gt;</code>-element binnen een <code>&lt;pre&gt;</code> (preformatted text)
                    element.</p>
                <pre><code>&lt;p&gt;Gebruik de functie &lt;code&gt;getElementById()&lt;/code&gt; om een element te selecteren.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function hello() {
  console.log("Hello, world!");
}&lt;/code&gt;&lt;/pre&gt;</code></pre>
                <div class="live-example">
                    <p>Gebruik de functie <code>getElementById()</code> om een element te selecteren.</p>
                    <pre><code>function hello() {
  console.log("Hello, world!");
}</code></pre>
                </div>

                <h4><code>&lt;time&gt;</code>: Datum en Tijd</h4>
                <p>Het <code>&lt;time&gt;</code>-element geeft een machine-leesbare vorm van een datum of tijd. Dit
                    helpt zoekmachines en andere computersystemen om de datum correct te interpreteren. Het
                    <code>datetime</code>-attribuut bevat de gestandaardiseerde waarde.
                </p>
                <pre><code>&lt;p&gt;De vergadering is gepland op &lt;time datetime="2025-10-26 10:00"&gt;26 oktober om 10:00 uur&lt;/time&gt;.&lt;/p&gt;</code></pre>
                <div class="live-example">
                    <p>De vergadering is gepland op <time datetime="2025-10-26 10:00">26 oktober om 10:00 uur</time>.
                    </p>
                </div>
            </section>

            <section id="html-lists-tables">
                <h3>Lijsten & Tabellen</h3>
                <h4>Lijsten</h4>
                <p>Lijsten worden gebruikt om gerelateerde items te groeperen. HTML biedt verschillende soorten lijsten
                    voor verschillende doeleinden.</p>

                <h5>HTML Lijst-elementen</h5>
                <table>
                    <thead>
                        <tr>
                            <th>Element</th>
                            <th>Omschrijving</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>&lt;ul&gt;</code></td>
                            <td><strong>Unordered list</strong>: maakt een on­geordende lijst met opsommingstekens
                                (bullets).</td>
                        </tr>
                        <tr>
                            <td><code>&lt;ol&gt;</code></td>
                            <td><strong>Ordered list</strong>: maakt een geordende lijst met nummers of letters.</td>
                        </tr>
                        <tr>
                            <td><code>&lt;li&gt;</code></td>
                            <td><strong>List item</strong>: een lijstitem binnen <code>&lt;ul&gt;</code> of
                                <code>&lt;ol&gt;</code>.
                            </td>
                        </tr>
                        <tr>
                            <td><code>&lt;dl&gt;</code></td>
                            <td><strong>Description list</strong>: maakt een lijst van termen en beschrijvingen.</td>
                        </tr>
                        <tr>
                            <td><code>&lt;dt&gt;</code></td>
                            <td><strong>Description term</strong>: geeft de term aan in een <code>&lt;dl&gt;</code>.
                            </td>
                        </tr>
                        <tr>
                            <td><code>&lt;dd&gt;</code></td>
                            <td><strong>Description detail</strong>: geeft de beschrijving van de term in een
                                <code>&lt;dl&gt;</code>.
                            </td>
                        </tr>
                    </tbody>
                </table>

                <h5>HTML Lijst-attributen</h5>
                <p>Je kunt het gedrag van geordende lijsten aanpassen met de volgende attributen:</p>
                <table>
                    <caption>Attributen voor <code>&lt;ol&gt;</code></caption>
                    <thead>
                        <tr>
                            <th>Attribuut</th>
                            <th>Waarden</th>
                            <th>Beschrijving</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>type</code></td>
                            <td><code>1</code>, <code>A</code>, <code>a</code>, <code>I</code>, <code>i</code></td>
                            <td>Bepaalt het nummeringstype van de lijst.</td>
                        </tr>
                        <tr>
                            <td><code>start</code></td>
                            <td>Getal</td>
                            <td>Het startnummer voor de nummering.</td>
                        </tr>
                        <tr>
                            <td><code>reversed</code></td>
                            <td>(geen waarde)</td>
                            <td>Keert de nummeringsvolgorde om.</td>
                        </tr>
                    </tbody>
                </table>
                <table>
                    <caption>Attribuut voor <code>&lt;li&gt;</code> (binnen een <code>&lt;ol&gt;</code>)</caption>
                    <thead>
                        <tr>
                            <th>Attribuut</th>
                            <th>Waarden</th>
                            <th>Beschrijving</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>value</code></td>
                            <td>Getal</td>
                            <td>Wijzigt de nummering van één specifiek item en de volgende items.</td>
                        </tr>
                    </tbody>
                </table>

                <h5>CSS-eigenschappen voor lijsten</h5>
                <p>Voor de styling van lijsten gebruik je CSS. Hiermee heb je volledige controle over het uiterlijk van
                    de markers (bullets en nummers).</p>
                <table>
                    <thead>
                        <tr>
                            <th>Eigenschap</th>
                            <th>Beschrijving</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>list-style-type</code></td>
                            <td>Bepaalt het type opsommingsteken (bv. <code>disc</code>, <code>square</code>,
                                <code>decimal</code>, <code>lower-roman</code>).
                            </td>
                        </tr>
                        <tr>
                            <td><code>list-style-position</code></td>
                            <td>Plaatst de marker <code>inside</code> of <code>outside</code> de tekstblok van het
                                lijstitem.</td>
                        </tr>
                        <tr>
                            <td><code>list-style-image</code></td>
                            <td>Vervangt de marker door een afbeelding.</td>
                        </tr>
                        <tr>
                            <td><code>list-style</code></td>
                            <td>Een shorthand om de bovenstaande drie eigenschappen in één regel te combineren.</td>
                        </tr>
                        <tr>
                            <td><code>::marker</code></td>
                            <td>Een pseudo-element om de marker zelf direct te stijlen (kleur, grootte, etc.).</td>
                        </tr>
                        <tr>
                            <td><code>counter-reset</code> & <code>counter-increment</code></td>
                            <td>Gebruikt voor geavanceerde, op maat gemaakte nummering die verder gaat dan de
                                standaardopties.</td>
                        </tr>
                    </tbody>
                </table>

                <h5>Voorbeelden van Lijst-styling</h5>
                <h6>1. Ongeordende lijst met CSS-styling</h6>
                <pre><code>&lt;ul class="custom-list"&gt;
  &lt;li&gt;Koffie&lt;/li&gt;
  &lt;li&gt;Thee&lt;/li&gt;
  &lt;li&gt;Melk&lt;/li&gt;
&lt;/ul&gt;

&lt;style&gt;
.custom-list {
  list-style-type: square;
  list-style-position: inside;
}
&lt;/style&gt;</code></pre>
                <div class="live-example">
                    <style>
                        .custom-list {
                            list-style-type: square;
                            list-style-position: inside;
                        }
                    </style>
                    <ul class="custom-list">
                        <li>Koffie</li>
                        <li>Thee</li>
                        <li>Melk</li>
                    </ul>
                </div>

                <h6>2. Geordende lijst met aangepaste marker</h6>
                <pre><code>&lt;ol class="styled-list"&gt;
  &lt;li&gt;HTML&lt;/li&gt;
  &lt;li&gt;CSS&lt;/li&gt;
  &lt;li&gt;JavaScript&lt;/li&gt;
&lt;/ol&gt;

&lt;style&gt;
.styled-list li::marker {
  color: red;
  font-weight: bold;
}
&lt;/style&gt;</code></pre>
                <div class="live-example">
                    <style>
                        .styled-list li::marker {
                            color: red;
                            font-weight: bold;
                        }
                    </style>
                    <ol class="styled-list">
                        <li>HTML</li>
                        <li>CSS</li>
                        <li>JavaScript</li>
                    </ol>
                </div>

                <h6>3. Volledig aangepaste genummerde lijst via CSS-counters</h6>
                <pre><code>&lt;ol class="custom-counter"&gt;
  &lt;li&gt;Stap één&lt;/li&gt;
  &lt;li&gt;Stap twee&lt;/li&gt;
  &lt;li&gt;Stap drie&lt;/li&gt;
&lt;/ol&gt;

&lt;style&gt;
.custom-counter {
  counter-reset: step;
  list-style: none;
  padding-left: 0;
}
.custom-counter li {
  counter-increment: step;
}
.custom-counter li::before {
  content: counter(step) ") ";
  font-weight: bold;
  color: blue;
  margin-right: 5px;
}
&lt;/style&gt;</code></pre>
                <div class="live-example">
                    <style>
                        .custom-counter {
                            counter-reset: step;
                            list-style: none;
                            padding-left: 0;
                        }

                        .custom-counter li {
                            counter-increment: step;
                        }

                        .custom-counter li::before {
                            content: counter(step) ") ";
                            font-weight: bold;
                            color: blue;
                            margin-right: 5px;
                        }
                    </style>
                    <ol class="custom-counter">
                        <li>Stap één</li>
                        <li>Stap twee</li>
                        <li>Stap drie</li>
                    </ol>
                </div>

                <h4 style="margin-top: 2rem;">HTML Tabellen: Structuur en Semantiek</h4>
                <p>HTML-tabellen worden gebruikt om data in rijen en kolommen te presenteren. Een correcte structuur is
                    essentieel voor zowel de weergave als de toegankelijkheid. De basiselementen zijn
                    <code>&lt;table&gt;</code>, <code>&lt;tr&gt;</code> (rij), <code>&lt;td&gt;</code> (datacel) en
                    <code>&lt;th&gt;</code> (kopcel).
                </p>
                <pre><code>&lt;table&gt;
  &lt;caption&gt;Openingstijden&lt;/caption&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th scope="col"&gt;Dag&lt;/th&gt;
      &lt;th scope="col"&gt;Voormiddag&lt;/th&gt;
      &lt;th scope="col"&gt;Namiddag&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th scope="row"&gt;Maandag - Vrijdag&lt;/th&gt;
      &lt;td&gt;09:00 - 12:00&lt;/td&gt;
      &lt;td&gt;13:00 - 17:00&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th scope="row"&gt;Zaterdag&lt;/th&gt;
      &lt;td&gt;10:00 - 12:00&lt;/td&gt;
      &lt;td&gt;Gesloten&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</code></pre>
                <div class="live-example">
                    <table>
                        <caption>Openingstijden</caption>
                        <thead>
                            <tr>
                                <th scope="col">Dag</th>
                                <th scope="col">Voormiddag</th>
                                <th scope="col">Namiddag</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <th scope="row">Maandag - Vrijdag</th>
                                <td>09:00 - 12:00</td>
                                <td>13:00 - 17:00</td>
                            </tr>
                            <tr>
                                <th scope="row">Zaterdag</th>
                                <td>10:00 - 12:00</td>
                                <td>Gesloten</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h5>Table Headers (Kopcellen)</h5>
                <p>Kopcellen (<code>&lt;th&gt;</code>) zijn cruciaal. Ze geven context aan de data in een kolom of rij.
                    Het <code>scope</code>-attribuut (met waarden <code>col</code> voor kolom of <code>row</code> voor
                    rij) verbindt de kop expliciet met de cellen, wat van onschatbare waarde is voor schermlezers.</p>

                <h5>Colspan & Rowspan</h5>
                <p>Met <code>colspan</code> en <code>rowspan</code> kun je cellen over meerdere kolommen of rijen laten
                    uitstrekken. Dit is handig voor het groeperen van gerelateerde informatie en het creëren van
                    complexere tabelstructuren.</p>
                <pre><code>&lt;table&gt;
  &lt;caption&gt;Resultaten per kwartaal&lt;/caption&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th rowspan="2"&gt;Product&lt;/th&gt;
      &lt;th colspan="2"&gt;Eerste Helft&lt;/th&gt;
      &lt;th colspan="2"&gt;Tweede Helft&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;Q1&lt;/th&gt;
      &lt;th&gt;Q2&lt;/th&gt;
      &lt;th&gt;Q3&lt;/th&gt;
      &lt;th&gt;Q4&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;Laptop X&lt;/th&gt;
      &lt;td&gt;150&lt;/td&gt;
      &lt;td&gt;200&lt;/td&gt;
      &lt;td&gt;220&lt;/td&gt;
      &lt;td&gt;250&lt;/td&gt;
    &lt;/tr&gt;
     &lt;tr&gt;
      &lt;th&gt;Totaal&lt;/th&gt;
      &lt;td colspan="4"&gt;820 stuks verkocht&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</code></pre>
                <div class="live-example">
                    <table>
                        <caption>Resultaten per kwartaal</caption>
                        <thead>
                            <tr>
                                <th rowspan="2">Product</th>
                                <th colspan="2">Eerste Helft</th>
                                <th colspan="2">Tweede Helft</th>
                            </tr>
                            <tr>
                                <th>Q1</th>
                                <th>Q2</th>
                                <th>Q3</th>
                                <th>Q4</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <th>Laptop X</th>
                                <td>150</td>
                                <td>200</td>
                                <td>220</td>
                                <td>250</td>
                            </tr>
                            <tr>
                                <th>Totaal</th>
                                <td colspan="4">820 stuks verkocht</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h5>Padding & Spacing (via CSS)</h5>
                <p>De ruimte binnen en tussen tabelcellen wordt volledig beheerd door CSS. <code>padding</code> creëert
                    ruimte binnen een cel (tussen de inhoud en de rand), terwijl <code>border-spacing</code> de ruimte
                    tussen de cellen zelf definieert. Let op: <code>border-spacing</code> werkt alleen als
                    <code>border-collapse</code> is ingesteld op <code>separate</code>.
                </p>
                <pre><code>table.spaced-out {
  border-collapse: separate;
  border-spacing: 10px 5px; /* 10px horizontaal, 5px verticaal */
}

table.spaced-out th,
table.spaced-out td {
  padding: 15px;
  border: 1px solid var(--accent-color);
}</code></pre>
                <div class="live-example">
                    <style>
                        table.spaced-out {
                            border-collapse: separate;
                            border-spacing: 10px 5px;
                            width: 100%;
                        }

                        table.spaced-out th,
                        table.spaced-out td {
                            padding: 15px;
                            border: 1px solid var(--accent-color);
                        }
                    </style>
                    <table class="spaced-out">
                        <thead>
                            <tr>
                                <th>Header 1</th>
                                <th>Header 2</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Data 1</td>
                                <td>Data 2</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h5>HTML Borders (via CSS)</h5>
                <p>Randen worden ook met CSS toegepast. De meest voorkomende aanpak is het gebruik van
                    <code>border-collapse: collapse;</code> op de <code>&lt;table&gt;</code>, waardoor de randen van
                    aangrenzende cellen samenvloeien tot één enkele rand. Vervolgens definieer je de stijl van de rand
                    op de <code>&lt;th&gt;</code> en <code>&lt;td&gt;</code> elementen.
                </p>
                <pre><code>table.clean-border {
  border-collapse: collapse;
  width: 100%;
}

table.clean-border th,
table.clean-border td {
  border: 1px solid var(--border-color);
  padding: 12px;
}</code></pre>
                <div class="live-example">
                    <style>
                        table.clean-border {
                            border-collapse: collapse;
                            width: 100%;
                        }

                        table.clean-border th,
                        table.clean-border td {
                            border: 1px solid var(--border-color);
                            padding: 12px;
                        }
                    </style>
                    <table class="clean-border">
                        <thead>
                            <tr>
                                <th>Header 1</th>
                                <th>Header 2</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Data 1</td>
                                <td>Data 2</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h5>HTML Sizes (via CSS)</h5>
                <p>De afmetingen van een tabel en de kolommen moeten met CSS worden ingesteld voor een flexibel en
                    responsive ontwerp. Je kunt een vaste breedte instellen (bv. in <code>px</code>), maar het is beter
                    om relatieve eenheden zoals percentages (<code>%</code>) of <code>fr</code>-eenheden (in CSS Grid)
                    te gebruiken. Dit zorgt ervoor dat de tabel zich aanpast aan verschillende schermformaten.</p>
                <pre><code>table.responsive-size {
  width: 100%; /* Tabel vult de container */
  table-layout: fixed; /* Kolombreedtes worden bepaald door de eerste rij */
}

table.responsive-size th:first-child {
  width: 50%; /* De eerste kolom neemt de helft van de ruimte in */
}

table.responsive-size th:not(:first-child) {
  width: 25%; /* De andere twee kolommen nemen elk een kwart in */
}</code></pre>
                <div class="live-example">
                    <style>
                        table.responsive-size {
                            width: 100%;
                            table-layout: fixed;
                        }

                        table.responsive-size th,
                        table.responsive-size td {
                            border: 1px solid var(--border-color);
                            padding: 8px;
                        }

                        table.responsive-size th:first-child {
                            width: 50%;
                        }

                        table.responsive-size th:not(:first-child) {
                            width: 25%;
                        }
                    </style>
                    <table class="responsive-size">
                        <thead>
                            <tr>
                                <th>Product (50%)</th>
                                <th>Prijs (25%)</th>
                                <th>Voorraad (25%)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Item A</td>
                                <td>€20</td>
                                <td>100</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h5>Table Colgroup</h5>
                <p>Met <code>&lt;colgroup&gt;</code> en <code>&lt;col&gt;</code> kun je stijlen toepassen op volledige
                    kolommen zonder elke cel afzonderlijk te moeten targeten. Dit is vooral handig voor het instellen
                    van achtergrondkleuren of breedtes. Plaats <code>&lt;colgroup&gt;</code> direct na de
                    <code>&lt;caption&gt;</code> en voor de <code>&lt;thead&gt;</code>.
                </p>
                <pre><code>&lt;table&gt;
  &lt;caption&gt;Styling met Colgroup&lt;/caption&gt;
  &lt;colgroup&gt;
    &lt;col span="1"&gt; &lt;!-- Geen speciale stijl --&gt;
    &lt;col style="background-color: #eff6ff;"&gt; &lt;!-- Blauwachtige achtergrond --&gt;
    &lt;col style="background-color: #f0fdf4;"&gt; &lt;!-- Groenachtige achtergrond --&gt;
  &lt;/colgroup&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Naam&lt;/th&gt;
      &lt;th&gt;Score A&lt;/th&gt;
      &lt;th&gt;Score B&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;Team 1&lt;/th&gt;
      &lt;td&gt;85&lt;/td&gt;
      &lt;td&gt;92&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</code></pre>
                <div class="live-example">
                    <table>
                        <caption>Styling met Colgroup</caption>
                        <colgroup>
                            <col span="1">
                            <col style="background-color: #eff6ff;">
                            <col style="background-color: #f0fdf4;">
                        </colgroup>
                        <thead>
                            <tr>
                                <th>Naam</th>
                                <th>Score A</th>
                                <th>Score B</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <th>Team 1</th>
                                <td>85</td>
                                <td>92</td>
                            </tr>
                            <tr>
                                <th>Team 2</th>
                                <td>88</td>
                                <td>90</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h5>Table Styling</h5>
                <p>Voor geavanceerde styling kun je de kracht van CSS-selectors gebruiken. Denk aan het markeren van
                    rijen wanneer de gebruiker eroverheen zweeft (<code>:hover</code>) of het afwisselen van rijkleuren
                    (<code>:nth-child</code>) voor betere leesbaarheid. Dit maakt je tabellen niet alleen mooier, maar
                    ook gebruiksvriendelijker.</p>
                <pre><code>table.stylish-table {
  border-collapse: collapse;
  width: 100%;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.stylish-table th {
  background-color: var(--sidebar-bg);
  color: white;
  font-weight: 600;
}

.stylish-table tr:nth-child(even) {
  background-color: var(--primary-bg);
}

.stylish-table tr:hover {
  background-color: #dbeafe; /* Lichtblauwe highlight bij hover */
  cursor: pointer;
}</code></pre>
                <div class="live-example">
                    <style>
                        table.stylish-table {
                            border-collapse: collapse;
                            width: 100%;
                            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                            border: none;
                            /* remove default borders */
                        }

                        .stylish-table th,
                        .stylish-table td {
                            border: none;
                            padding: 12px;
                        }

                        .stylish-table th {
                            background-color: var(--sidebar-bg);
                            color: white;
                            font-weight: 600;
                        }

                        .stylish-table tr:nth-child(even) {
                            background-color: var(--primary-bg);
                        }

                        .stylish-table tr:hover {
                            background-color: #dbeafe;
                            cursor: pointer;
                        }
                    </style>
                    <table class="stylish-table">
                        <thead>
                            <tr>
                                <th>Product</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Laptop Pro</td>
                                <td>Op voorraad</td>
                            </tr>
                            <tr>
                                <td>Muis Basic</td>
                                <td>Niet op voorraad</td>
                            </tr>
                            <tr>
                                <td>Keyboard Plus</td>
                                <td>Op voorraad</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="exercise">
                    <h4>Oefening H4-01: Toegankelijke tabel</h4>
                    <p>Maak een tabel met een titel (caption), een kop (thead) met twee kolomkoppen (th met
                        `scope="col"`) en een body (tbody) met twee rijen. De eerste cel van elke rij moet een rijkop
                        zijn (th met `scope="row"`).</p>
                    <textarea id="ex-h4-01" placeholder="Plaats hier je tabel..."></textarea>
                    <button class="check-btn" data-exercise="h4-01">Controleer</button>
                    <button class="solution-btn secondary">Toon Oplossing</button>
                    <div class="validator-result"></div>
                    <div class="exercise-solution">
                        <pre><code>&lt;table&gt;
    &lt;caption&gt;Cursusplanning&lt;/caption&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th scope="col"&gt;Vak&lt;/th&gt;
            &lt;th scope="col"&gt;Docent&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;th scope="row"&gt;HTML&lt;/th&gt;
            &lt;td&gt;Dhr. De Vries&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th scope="row"&gt;CSS&lt;/th&gt;
            &lt;td&gt;Mevr. Jansen&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;</code></pre>
                    </div>
                </div>
            </section>

            <section id="html-media">
                <h3>Media & Inbedding</h3>
                <p>Moderne webpagina's zijn zelden alleen tekst. Met HTML kun je eenvoudig afbeeldingen, video, audio en
                    zelfs complete andere webpagina's insluiten om je content te verrijken.</p>

                <h4><code>&lt;img&gt;</code>: Afbeeldingen</h4>
                <p>Het <code>&lt;img&gt;</code>-element is de standaardmanier om een afbeelding te tonen. Het is een
                    leeg element, wat betekent dat het geen sluittag heeft. De belangrijkste attributen zijn:</p>
                <ul>
                    <li><code>src</code> (source): Het pad naar het afbeeldingsbestand. Dit is verplicht.</li>
                    <li><code>alt</code> (alternative text): Een beschrijving van de afbeelding. Essentieel voor
                        toegankelijkheid (schermlezers) en SEO. Dit is ook verplicht.</li>
                    <li><code>width</code> en <code>height</code>: De afmetingen van de afbeelding in pixels. Het
                        opgeven hiervan helpt de browser om ruimte te reserveren, wat het verspringen van de layout
                        (layout shift) tijdens het laden voorkomt.</li>
                    <li><code>loading="lazy"</code>: Een moderne optimalisatie die de browser instrueert om de
                        afbeelding pas te laden als deze in de buurt van de viewport komt.</li>
                </ul>
                <pre><code>&lt;img 
  src="https://placehold.co/400x250/3b82f6/ffffff?text=Mijn+Afbeelding" 
  alt="Een blauwe placeholder afbeelding met witte tekst" 
  width="400" 
  height="250" 
  loading="lazy"&gt;</code></pre>
                <div class="live-example">
                    <img src="https://placehold.co/400x250/3b82f6/ffffff?text=Mijn+Afbeelding"
                        alt="Een blauwe placeholder afbeelding met witte tekst" width="400" height="250" loading="lazy"
                        style="max-width: 100%; height: auto;">
                </div>

                <h4><code>&lt;picture&gt;</code> & <code>&lt;source&gt;</code>: Geavanceerde Afbeeldingen</h4>
                <p>Het <code>&lt;picture&gt;</code>-element geeft je meer controle over welke afbeelding wordt getoond.
                    Het werkt als een container voor meerdere <code>&lt;source&gt;</code>-elementen en één
                    <code>&lt;img&gt;</code>-element als fallback. Dit is nuttig voor twee hoofddoelen:
                </p>
                <ol>
                    <li><strong>Art Direction:</strong> Verschillende afbeeldingen tonen op basis van de schermgrootte
                        (bv. een brede afbeelding op desktop en een bijgesneden, vierkante versie op mobiel).</li>
                    <li><strong>Moderne Formaten:</strong> Efficiëntere afbeeldingsformaten zoals WebP of AVIF aanbieden
                        aan browsers die deze ondersteunen, met een JPG of PNG als fallback voor oudere browsers.</li>
                </ol>
                <pre><code>&lt;picture&gt;
  &lt;!-- Toon deze bron als de browser AVIF ondersteunt --&gt;
  &lt;source srcset="https://placehold.co/800x400/16a34a/ffffff?text=Modern+AVIF" type="image/avif"&gt;
  &lt;!-- Toon anders deze bron als de browser WebP ondersteunt --&gt;
  &lt;source srcset="https://placehold.co/800x400/f97316/ffffff?text=Modern+WebP" type="image/webp"&gt;
  &lt;!-- Fallback voor oudere browsers --&gt;
  &lt;img src="https://placehold.co/800x400/be123c/ffffff?text=Standaard+JPG" alt="Placeholder" width="800" height="400"&gt;
&lt;/picture&gt;</code></pre>
                <div class="live-example">
                    <picture>
                        <source srcset="https://placehold.co/800x400/16a34a/ffffff?text=Modern+AVIF" type="image/avif">
                        <source srcset="https://placehold.co/800x400/f97316/ffffff?text=Modern+WebP" type="image/webp">
                        <img src="https://placehold.co/800x400/be123c/ffffff?text=Standaard+JPG" alt="Placeholder"
                            width="800" height="400" style="max-width: 100%; height: auto;">
                    </picture>
                </div>

                <h4><code>&lt;video&gt;</code> & <code>&lt;audio&gt;</code>: Multimedia</h4>
                <p>Met <code>&lt;video&gt;</code> en <code>&lt;audio&gt;</code> kun je mediabestanden direct in je
                    pagina insluiten zonder afhankelijk te zijn van externe plugins. Belangrijke attributen zijn:</p>
                <ul>
                    <li><code>controls</code>: Toont de standaard afspeelbediening van de browser (play, pauze, volume,
                        etc.).</li>
                    <li><code>autoplay</code>: Start het afspelen automatisch. Let op: de meeste browsers vereisen dat
                        het <code>muted</code> attribuut ook aanwezig is om <code>autoplay</code> te laten werken.</li>
                    <li><code>muted</code>: Demt het geluid.</li>
                    <li><code>loop</code>: Herhaalt de media automatisch na het einde.</li>
                    <li><code>poster</code>: (Alleen voor <code>&lt;video&gt;</code>) Een afbeelding die wordt getoond
                        voordat de video wordt afgespeeld.</li>
                </ul>
                <p>Net als bij <code>&lt;picture&gt;</code>, kun je meerdere <code>&lt;source&gt;</code>-elementen
                    gebruiken om verschillende bestandsformaten aan te bieden.</p>
                <pre><code>&lt;video controls width="100%" poster="https://placehold.co/640x360/1e293b/ffffff?text=Video+Poster"&gt;
  &lt;source src="movie.webm" type="video/webm"&gt;
  &lt;source src="movie.mp4" type="video/mp4"&gt;
  Sorry, je browser ondersteunt geen ingesloten video's.
&lt;/video&gt;

&lt;audio controls&gt;
  &lt;source src="sound.opus" type="audio/opus"&gt;
  &lt;source src="sound.mp3" type="audio/mpeg"&gt;
  Sorry, je browser ondersteunt geen ingesloten audio.
&lt;/audio&gt;</code></pre>
                <div class="live-example">
                    <video controls width="100%" poster="https://placehold.co/640x360/1e293b/ffffff?text=Video+Poster"
                        style="max-width: 100%; height: auto;">
                        <!-- Omdat we geen echte videobronnen hebben, is alleen de poster zichtbaar -->
                        Sorry, je browser ondersteunt geen ingesloten video's.
                    </video>
                    <br><br>
                    <audio controls style="width: 100%;">
                        <!-- Omdat we geen echte audiobronnen hebben, is alleen de player zichtbaar -->
                        Sorry, je browser ondersteunt geen ingesloten audio.
                    </audio>
                </div>

                <h4><code>&lt;iframe&gt;</code>: Ingesloten content</h4>
                <p>Een <code>&lt;iframe&gt;</code> (Inline Frame) maakt een genest browservenster binnen je eigen
                    pagina. Hiermee kun je content van een volledig andere website insluiten, zoals een YouTube-video,
                    een Google Maps-kaart of een social media feed.</p>
                <ul>
                    <li><code>src</code>: De URL van de pagina die je wilt insluiten.</li>
                    <li><code>title</code>: Een beschrijving van de inhoud van de iframe. Dit is zeer belangrijk voor
                        toegankelijkheid.</li>
                    <li><code>width</code> en <code>height</code>: De afmetingen van het iframe-venster.</li>
                    <li><code>allowfullscreen</code>: Staat de inhoud van de iframe toe om in volledig scherm te worden
                        weergegeven.</li>
                    <li><code>sandbox</code>: Een beveiligingsattribuut om de rechten van de ingesloten content te
                        beperken (bv. het uitvoeren van scripts of het openen van pop-ups).</li>
                </ul>
                <pre><code>&lt;iframe 
  src="https://www.openstreetmap.org/export/embed.html?bbox=4.6,51.3,4.7,51.4" 
  width="100%" 
  height="350" 
  style="border:1px solid black;" 
  title="Een interactieve kaart van een regio"&gt;
&lt;/iframe&gt;</code></pre>
                <div class="live-example">
                    <iframe src="https://www.openstreetmap.org/export/embed.html?bbox=4.9883,51.213,5.007,51.219"
                        width="100%" height="350" style="border:1px solid black;"
                        title="Een interactieve kaart van een regio"></iframe>
                </div>
            </section>

            <section id="html-forms">
                <h3>Formulieren</h3>
                <p>Formulieren zijn essentieel voor gebruikersinteractie, van inloggen tot het versturen van een
                    contactbericht. Een goed gestructureerd formulier is toegankelijk en gebruiksvriendelijk.</p>

                <h4>Het <code>&lt;form&gt;</code> Element</h4>
                <p>Alles wat met een formulier te maken heeft, staat binnen een <code>&lt;form&gt;</code>-tag. Dit
                    element heeft zelf geen visuele weergave, maar fungeert als een container die de formulierelementen
                    groepeert en bepaalt hoe de data wordt verstuurd.</p>

                <h5>Formulierattributen</h5>
                <p>De belangrijkste attributen voor het <code>&lt;form&gt;</code>-element zijn:</p>
                <table>
                    <thead>
                        <tr>
                            <th>Attribuut</th>
                            <th>Beschrijving</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>action</code></td>
                            <td>De URL waar de formuliergegevens naartoe worden gestuurd voor verwerking.</td>
                        </tr>
                        <tr>
                            <td><code>method</code></td>
                            <td>De HTTP-methode die wordt gebruikt: <code>GET</code> (data in URL) of <code>POST</code>
                                (data in body).</td>
                        </tr>
                        <tr>
                            <td><code>autocomplete</code></td>
                            <td>Kan op <code>on</code> of <code>off</code> worden gezet om de browser te laten helpen
                                bij het automatisch invullen.</td>
                        </tr>
                        <tr>
                            <td><code>novalidate</code></td>
                            <td>Schakelt de ingebouwde browser-validatie uit.</td>
                        </tr>
                        <tr>
                            <td><code>enctype</code></td>
                            <td>Specificeert hoe de formulierdata moet worden gecodeerd bij het versturen (belangrijk
                                voor file uploads: <code>multipart/form-data</code>).</td>
                        </tr>
                        <tr>
                            <td><code>target</code></td>
                            <td>Geeft aan waar het antwoord na het versturen moet worden weergegeven (bv.
                                <code>_blank</code> voor een nieuw tabblad).
                            </td>
                        </tr>
                    </tbody>
                </table>

                <h4>Code voorbeelden</h4>

                <table>
                    <thead>
                        <tr>
                            <th>Attribuut</th>
                            <th>Waarde</th>
                            <th>Beschrijving</th>
                            <th>Voorbeeld</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>action</code></td>
                            <td>URL</td>
                            <td>De URL waar de formuliergegevens naartoe worden gestuurd voor verwerking.</td>
                            <td><code>action="/submit.php"</code></td>
                        </tr>
                        <tr>
                            <td><code>method</code></td>
                            <td>GET/POST</td>
                            <td>De HTTP-methode die wordt gebruikt: <code>GET</code> (data in URL) of <code>POST</code>
                                (data in body).</td>
                            <td><code>method="post"</code></td>
                        </tr>
                        <tr>
                            <td><code>autocomplete</code></td>
                            <td>on/off</td>
                            <td>Kan op <code>on</code> of <code>off</code> worden gezet om de browser te laten helpen
                                bij het automatisch invullen.</td>
                            <td><code>autocomplete="off"</code></td>
                        </tr>
                        <tr>
                            <td><code>novalidate</code></td>
                            <td>(geen waarde)</td>
                            <td>Schakelt de ingebouwde browser-validatie uit.</td>
                            <td><code>novalidate</code></td>
                        </tr>
                        <tr>
                            <td><code>enctype</code></td>
                            <td>application/x-www-form-urlencoded<br>multipart/form-data<br>text/plain</td>
                            <td>Specificeert hoe de formulierdata moet worden gecodeerd bij het versturen (belangrijk
                                voor file uploads: <code>multipart/form-data</code>).</td>
                            <td><code>enctype="multipart/form-data"</code></td>
                        </tr>
                        <tr>
                            <td><code>target</code></td>
                            <td>_blank<br>_self<br>_parent<br>_top</td>
                            <td>Geeft aan waar het antwoord na het versturen moet worden weergegeven (bv.
                                <code>_blank</code> voor een nieuw tabblad).
                            </td>
                            <td><code>target="_blank"</code></td>
                        </tr>
                    </tbody>
                </table>

                <div class="live-example">
                    <form action="#" method="get" target="_blank" style="border:1px solid #ccc;padding:10px;">
                        <label for="search">Zoeken:</label>
                        <input type="text" id="search" name="q">
                        <button type="submit">Versturen</button>
                    </form>
                </div>

                <h4>Formulierelementen</h4>
                <p>Binnen een formulier gebruik je verschillende elementen om gebruikersinvoer te verzamelen:</p>
                <table>
                    <thead>
                        <tr>
                            <th>Element</th>
                            <th>Beschrijving</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>&lt;input&gt;</code></td>
                            <td>Het meest veelzijdige element, met vele types (zie hieronder).</td>
                        </tr>
                        <tr>
                            <td><code>&lt;label&gt;</code></td>
                            <td>Een label dat een beschrijving geeft voor een formulierveld. Cruciaal voor
                                toegankelijkheid.</td>
                        </tr>
                        <tr>
                            <td><code>&lt;select&gt;</code></td>
                            <td>Een dropdown-menu.</td>
                        </tr>
                        <tr>
                            <td><code>&lt;textarea&gt;</code></td>
                            <td>Een invoerveld voor meerdere regels tekst.</td>
                        </tr>
                        <tr>
                            <td><code>&lt;button&gt;</code></td>
                            <td>Een klikbare knop.</td>
                        </tr>
                        <tr>
                            <td><code>&lt;fieldset&gt;</code> & <code>&lt;legend&gt;</code></td>
                            <td>Groepeert gerelateerde velden, met <code>&lt;legend&gt;</code> als titel voor de groep.
                            </td>
                        </tr>
                        <tr>
                            <td><code>&lt;datalist&gt;</code></td>
                            <td>Biedt een lijst met vooraf gedefinieerde opties voor een
                                <code>&lt;input&gt;</code>-veld.
                            </td>
                        </tr>
                        <tr>
                            <td><code>&lt;output&gt;</code></td>
                            <td>Toont het resultaat van een berekening.</td>
                        </tr>
                    </tbody>
                </table>

                <h4>Code voorbeelden</h4>

                <h4>Formulierelementen</h4>
                <p>Binnen een formulier gebruik je verschillende elementen om gebruikersinvoer te verzamelen:</p>
                <table>
                    <thead>
                        <tr>
                            <th>Element</th>
                            <th>Beschrijving</th>
                            <th>Voorbeeld</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code><input></code></td>
                            <td>Het meest veelzijdige element, met vele types (zie hieronder).</td>
                            <td><code><input type="text" name="username"></code></td>
                        </tr>
                        <tr>
                            <td><code><label></code></td>
                            <td>Een label dat een beschrijving geeft voor een formulierveld. Cruciaal voor
                                toegankelijkheid.</td>
                            <td><code><label for="username">Gebruikersnaam:</label></code></td>
                        </tr>
                        <tr>
                            <td><code><select></code></td>
                            <td>Een dropdown-menu.</td>
                            <td><code><select name="country"><option>Nederland</option></select></code></td>
                        </tr>
                        <tr>
                            <td><code><textarea></code></td>
                            <td>Een invoerveld voor meerdere regels tekst.</td>
                            <td><code><textarea name="comment"></textarea></code></td>
                        </tr>
                        <tr>
                            <td><code><button></code></td>
                            <td>Een klikbare knop.</td>
                            <td><code><button type="submit">Versturen</button></code></td>
                        </tr>
                        <tr>
                            <td><code><fieldset></code> & <code><legend></code></td>
                            <td>Groepeert gerelateerde velden, met <code><legend></code> als titel voor de groep.</td>
                            <td><code><fieldset><legend>Persoonlijke gegevens</legend>...</fieldset></code></td>
                        </tr>
                        <tr>
                            <td><code><datalist></code></td>
                            <td>Biedt een lijst met vooraf gedefinieerde opties voor een <code><input></code>-veld.</td>
                            <td><code><input list="browsers"><datalist id="browsers"><option value="Chrome"></datalist></code>
                            </td>
                        </tr>
                        <tr>
                            <td><code><output></code></td>
                            <td>Toont het resultaat van een berekening.</td>
                            <td><code><output name="result" for="a b"></output></code></td>
                        </tr>
                    </tbody>
                </table>

                <h4>HTML <code>&lt;input&gt;</code> Types</h4>
                <p>Het <code>type</code>-attribuut van het <code>&lt;input&gt;</code>-element is het belangrijkst, omdat
                    het de functionaliteit van het veld volledig verandert. Hier zijn enkele veelvoorkomende types:</p>
                <table>
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Beschrijving</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>text</code></td>
                            <td>Standaard eenregelig tekstveld.</td>
                        </tr>
                        <tr>
                            <td><code>password</code></td>
                            <td>Verbergt de ingevoerde karakters.</td>
                        </tr>
                        <tr>
                            <td><code>email</code></td>
                            <td>Valideert op een e-mailformaat.</td>
                        </tr>
                        <tr>
                            <td><code>number</code></td>
                            <td>Voor numerieke invoer, toont vaak pijltjes.</td>
                        </tr>
                        <tr>
                            <td><code>checkbox</code></td>
                            <td>Een aanvinkvakje (meerdere keuzes mogelijk).</td>
                        </tr>
                        <tr>
                            <td><code>radio</code></td>
                            <td>Een keuzerondje (één keuze binnen een groep met dezelfde `name`).</td>
                        </tr>
                        <tr>
                            <td><code>date</code></td>
                            <td>Een datumkiezer.</td>
                        </tr>
                        <tr>
                            <td><code>file</code></td>
                            <td>Laat de gebruiker een bestand selecteren.</td>
                        </tr>
                        <tr>
                            <td><code>range</code></td>
                            <td>Een schuifregelaar voor een numerieke waarde.</td>
                        </tr>
                        <tr>
                            <td><code>color</code></td>
                            <td>Een kleurkiezer.</td>
                        </tr>
                        <tr>
                            <td><code>submit</code></td>
                            <td>Een knop die het formulier verstuurt.</td>
                        </tr>
                        <tr>
                            <td><code>reset</code></td>
                            <td>Een knop die alle velden naar hun beginwaarde herstelt.</td>
                        </tr>
                    </tbody>
                </table>

                <h4>Code voorbeelden</h4>

                <h4>HTML <code><input></code> Types</h4>
                <p>Het <code>type</code>-attribuut van het <code><input></code>-element is het belangrijkst, omdat het
                    de functionaliteit van het veld volledig verandert. Hier zijn enkele veelvoorkomende types:</p>
                <table>
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Beschrijving</th>
                            <th>Voorbeeld</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>text</code></td>
                            <td>Standaard eenregelig tekstveld.</td>
                            <td><code><input type="text" name="naam"></code></td>
                        </tr>
                        <tr>
                            <td><code>password</code></td>
                            <td>Verbergt de ingevoerde karakters.</td>
                            <td><code><input type="password" name="wachtwoord"></code></td>
                        </tr>
                        <tr>
                            <td><code>email</code></td>
                            <td>Valideert op een e-mailformaat.</td>
                            <td><code><input type="email" name="email" required></code></td>
                        </tr>
                        <tr>
                            <td><code>number</code></td>
                            <td>Voor numerieke invoer, toont vaak pijltjes.</td>
                            <td><code><input type="number" name="leeftijd" min="0" max="120"></code></td>
                        </tr>
                        <tr>
                            <td><code>checkbox</code></td>
                            <td>Een aanvinkvakje (meerdere keuzes mogelijk).</td>
                            <td><code><input type="checkbox" name="hobby" value="sport"></code></td>
                        </tr>
                        <tr>
                            <td><code>radio</code></td>
                            <td>Een keuzerondje (één keuze binnen een groep met dezelfde `name`).</td>
                            <td><code><input type="radio" name="geslacht" value="man"></code></td>
                        </tr>
                        <tr>
                            <td><code>date</code></td>
                            <td>Een datumkiezer.</td>
                            <td><code><input type="date" name="geboortedatum"></code></td>
                        </tr>
                        <tr>
                            <td><code>file</code></td>
                            <td>Laat de gebruiker een bestand selecteren.</td>
                            <td><code><input type="file" name="cv" accept=".pdf,.doc"></code></td>
                        </tr>
                        <tr>
                            <td><code>range</code></td>
                            <td>Een schuifregelaar voor een numerieke waarde.</td>
                            <td><code><input type="range" name="volume" min="0" max="100"></code></td>
                        </tr>
                        <tr>
                            <td><code>color</code></td>
                            <td>Een kleurkiezer.</td>
                            <td><code><input type="color" name="favoriete_kleur"></code></td>
                        </tr>
                        <tr>
                            <td><code>submit</code></td>
                            <td>Een knop die het formulier verstuurt.</td>
                            <td><code><input type="submit" value="Versturen"></code></td>
                        </tr>
                        <tr>
                            <td><code>reset</code></td>
                            <td>Een knop die alle velden naar hun beginwaarde herstelt.</td>
                            <td><code><input type="reset" value="Resetten"></code></td>
                        </tr>
                    </tbody>
                </table>

                <h4>HTML Input Attributen</h4>
                <p>Naast <code>type</code> zijn er vele andere attributen om het gedrag van een
                    <code>&lt;input&gt;</code> te specificeren:
                </p>
                <table>
                    <thead>
                        <tr>
                            <th>Attribuut</th>
                            <th>Beschrijving</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>value</code></td>
                            <td>De initiële waarde van het veld.</td>
                        </tr>
                        <tr>
                            <td><code>required</code></td>
                            <td>Geeft aan dat het veld verplicht ingevuld moet worden.</td>
                        </tr>
                        <tr>
                            <td><code>placeholder</code></td>
                            <td>Toont een hint in het veld die verdwijnt zodra de gebruiker begint te typen.</td>
                        </tr>
                        <tr>
                            <td><code>pattern</code></td>
                            <td>Een reguliere expressie waaraan de invoer moet voldoen.</td>
                        </tr>
                        <tr>
                            <td><code>multiple</code></td>
                            <td>Staat toe dat meerdere waarden worden geselecteerd (voor <code>email</code> en
                                <code>file</code>).
                            </td>
                        </tr>
                        <tr>
                            <td><code>step</code></td>
                            <td>Definieert de stapgrootte voor numerieke of datum-gebaseerde input types.</td>
                        </tr>
                        <tr>
                            <td><code>maxlength</code></td>
                            <td>De maximale lengte van de invoer.</td>
                        </tr>
                    </tbody>
                </table>

                <div class="exercise">
                    <h4>Oefening H6-01: Login formulier</h4>
                    <p>Maak een eenvoudig login-formulier met velden voor e-mail en wachtwoord. Zorg ervoor dat elk veld
                        een correct gekoppeld <code>label</code> heeft en dat het e-mailveld <code>required</code> is.
                    </p>
                    <textarea id="ex-h6-01" placeholder="Plaats hier je formulier..."></textarea>
                    <button class="check-btn" data-exercise="h6-01">Controleer</button>
                    <button class="solution-btn secondary">Toon Oplossing</button>
                    <div class="validator-result"></div>
                    <div class="exercise-solution">
                        <pre><code>&lt;form action="/login" method="post"&gt;
    &lt;div&gt;
        &lt;label for="email"&gt;E-mailadres:&lt;/label&gt;
        &lt;input type="email" id="email" name="user_email" required&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;label for="password"&gt;Wachtwoord:&lt;/label&gt;
        &lt;input type="password" id="password" name="user_password"&gt;
    &lt;/div&gt;
    &lt;button type="submit"&gt;Inloggen&lt;/button&gt;
&lt;/form&gt;</code></pre>
                    </div>
                </div>
            </section>

            <section id="html-interactive">
                <h3>Interactieve Elementen</h3>
                <ul>
                    <li><code>&lt;details&gt;</code> & <code>&lt;summary&gt;</code>: Creëert een uitklapbaar
                        "accordeon"-widget. De `summary` is de altijd zichtbare titel.</li>
                    <li><code>&lt;dialog&gt;</code>: Een dialoogvenster of pop-up. Kan modaal gemaakt worden met
                        JavaScript (`.showModal()`).</li>
                    <li><code>&lt;canvas&gt;</code>: Een tekengebied dat via JavaScript gemanipuleerd kan worden voor
                        grafieken, animaties of games.</li>
                </ul>
                <pre><code>&lt;details&gt;
    &lt;summary&gt;Klik hier voor meer info&lt;/summary&gt;
    &lt;p&gt;Dit is de verborgen informatie.&lt;/p&gt;
&lt;/details&gt;

&lt;dialog id="myDialog"&gt;
  &lt;p&gt;Dit is een dialoogvenster.&lt;/p&gt;
  &lt;button onclick="document.getElementById('myDialog').close()"&gt;Sluiten&lt;/button&gt;
&lt;/dialog&gt;
&lt;button onclick="document.getElementById('myDialog').showModal()"&gt;Toon dialoog&lt;/button&gt;</code></pre>

                <h4><code>&lt;div&gt;</code>: De Content Container</h4>
                <p>Het <code>&lt;div&gt;</code>-element is een van de meest gebruikte elementen in HTML. Het staat voor
                    "division" (sectie) en fungeert als een generieke container zonder semantische betekenis. Zijn
                    primaire doel is het groeperen van andere HTML-elementen, die je vervolgens als één blok kunt
                    stijlen met CSS of manipuleren met JavaScript.</p>
                <p>Standaard is een <code>&lt;div&gt;</code> een blok-element, wat betekent dat het de volledige
                    beschikbare breedte inneemt en een regeleinde voor en na zichzelf creëert.</p>

                <h5><code>&lt;div&gt;</code> als container</h5>
                <p>Je kunt een <code>&lt;div&gt;</code> gebruiken om gerelateerde content, zoals een titel en een paar
                    paragrafen, te bundelen tot een logische sectie.</p>
                <pre><code>&lt;div style="border: 1px solid #ccc; padding: 10px; border-radius: 5px;"&gt;
  &lt;h2&gt;Londen&lt;/h2&gt;
  &lt;p&gt;Londen is de hoofdstad van Engeland.&lt;/p&gt;
  &lt;p&gt;Londen heeft meer dan 9 miljoen inwoners.&lt;/p&gt;
&lt;/div&gt;</code></pre>
                <div class="live-example">
                    <div style="border: 1px solid #ccc; padding: 10px; border-radius: 5px;">
                        <h2>Londen</h2>
                        <p>Londen is de hoofdstad van Engeland.</p>
                        <p>Londen heeft meer dan 9 miljoen inwoners.</p>
                    </div>
                </div>

                <h5>Een <code>&lt;div&gt;</code> centreren</h5>
                <p>Als een <code>&lt;div&gt;</code> niet de volledige breedte inneemt en je deze wilt centreren, kun je
                    de CSS-eigenschap <code>margin</code> op <code>auto</code> instellen.</p>
                <pre><code>&lt;div style="width: 300px; margin: auto; border: 1px solid #ccc; padding: 10px;"&gt;
  &lt;h2&gt;Gecentreerd&lt;/h2&gt;
  &lt;p&gt;Deze div is gecentreerd.&lt;/p&gt;
&lt;/div&gt;</code></pre>
                <div class="live-example">
                    <div
                        style="width: 300px; max-width: 100%; margin: auto; border: 1px solid #ccc; padding: 10px; border-radius: 5px;">
                        <h2>Gecentreerd</h2>
                        <p>Deze div is gecentreerd.</p>
                    </div>
                </div>

                <h5><code>&lt;div&gt;</code>-elementen naast elkaar plaatsen</h5>
                <p>Omdat <code>&lt;div&gt;</code>-elementen blok-elementen zijn, verschijnen ze standaard onder elkaar.
                    Om ze naast elkaar te plaatsen, heb je CSS nodig. De meest moderne en aanbevolen methoden hiervoor
                    zijn Flexbox en Grid.</p>

                <h5>Flexbox-methode</h5>
                <p>Plaats de <code>&lt;div&gt;</code>-elementen in een container en geef die container
                    <code>display: flex;</code>.
                </p>
                <pre><code>&lt;div class="flex-container"&gt;
  &lt;div&gt;Londen&lt;/div&gt;
  &lt;div&gt;Oslo&lt;/div&gt;
  &lt;div&gt;Rome&lt;/div&gt;
&lt;/div&gt;

&lt;style&gt;
.flex-container {
  display: flex;
  gap: 10px; /* Ruimte tussen de items */
}
.flex-container > div {
  flex: 1; /* Verdeel de ruimte gelijkmatig */
  border: 1px solid #ccc;
  padding: 10px;
}
&lt;/style&gt;</code></pre>
                <div class="live-example">
                    <style>
                        .flex-container {
                            display: flex;
                            gap: 10px;
                        }

                        .flex-container>div {
                            flex: 1;
                            border: 1px solid #ccc;
                            padding: 10px;
                            border-radius: 5px;
                        }
                    </style>
                    <div class="flex-container">
                        <div><b>Londen</b>
                            <p>Hoofdstad van Engeland.</p>
                        </div>
                        <div><b>Oslo</b>
                            <p>Hoofdstad van Noorwegen.</p>
                        </div>
                        <div><b>Rome</b>
                            <p>Hoofdstad van Italië.</p>
                        </div>
                    </div>
                </div>

                <h5>Grid-methode</h5>
                <p>Plaats de <code>&lt;div&gt;</code>-elementen in een container en geef die container
                    <code>display: grid;</code> en definieer de kolommen met <code>grid-template-columns</code>.
                </p>
                <pre><code>&lt;div class="grid-container"&gt;
  &lt;div&gt;Londen&lt;/div&gt;
  &lt;div&gt;Oslo&lt;/div&gt;
  &lt;div&gt;Rome&lt;/div&gt;
&lt;/div&gt;

&lt;style&gt;
.grid-container {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr; /* Drie kolommen met gelijke breedte */
  gap: 10px;
}
.grid-container > div {
  border: 1px solid #ccc;
  padding: 10px;
}
&lt;/style&gt;</code></pre>
                <div class="live-example">
                    <style>
                        .grid-container {
                            display: grid;
                            grid-template-columns: 1fr 1fr 1fr;
                            gap: 10px;
                        }

                        .grid-container>div {
                            border: 1px solid #ccc;
                            padding: 10px;
                            border-radius: 5px;
                        }
                    </style>
                    <div class="grid-container">
                        <div><b>Londen</b>
                            <p>Hoofdstad van Engeland.</p>
                        </div>
                        <div><b>Oslo</b>
                            <p>Hoofdstad van Noorwegen.</p>
                        </div>
                        <div><b>Rome</b>
                            <p>Hoofdstad van Italië.</p>
                        </div>
                    </div>
                </div>
            </section>

            <section id="html-layout-overview">
                <h3>Overzicht HTML Layout Elements</h3>

                <h4><code>&lt;html&gt;</code></h4>
                <p>Functie: Het root-element van elk HTML-document. Alles staat binnen <code>&lt;html&gt;</code> ...
                    <code>&lt;/html&gt;</code>.
                </p>
                <pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;</code></pre>
                <div class="live-example">
                    <p>Dit is het root-element, het is niet direct zichtbaar maar omvat de hele pagina.</p>
                </div>

                <h4><code>&lt;body&gt;</code></h4>
                <p>Functie: Bevat alle zichtbare inhoud van de webpagina.</p>
                <pre><code>&lt;body&gt;
  &lt;h1&gt;Welkom!&lt;/h1&gt;
&lt;/body&gt;</code></pre>
                <div class="live-example">
                    <h1>Welkom!</h1>
                </div>

                <h4><code>&lt;header&gt;</code></h4>
                <p>Functie: Bovenste sectie van een pagina of artikel, vaak met titel, logo of navigatie.</p>
                <pre><code>&lt;header&gt;
  &lt;h1&gt;Mijn Website&lt;/h1&gt;
&lt;/header&gt;</code></pre>
                <div class="live-example">
                    <header style="border: 1px solid var(--border-color); padding: 10px; border-radius: 5px;">
                        <h1>Mijn Website</h1>
                    </header>
                </div>

                <h4><code>&lt;nav&gt;</code></h4>
                <p>Functie: Bevat navigatielinks naar andere pagina’s of secties.</p>
                <pre><code>&lt;nav&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href="/"&gt;Home&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/over"&gt;Over&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;</code></pre>
                <div class="live-example">
                    <nav>
                        <ul style="list-style: none; padding: 0; display: flex; gap: 15px;">
                            <li><a href="#html-layout-overview">Home</a></li>
                            <li><a href="#html-layout-overview">Over</a></li>
                        </ul>
                    </nav>
                </div>

                <h4><code>&lt;main&gt;</code></h4>
                <p>Functie: Het hoofdinhoudsgedeelte van een pagina, uniek per pagina.</p>
                <pre><code>&lt;main&gt;
  &lt;article&gt;Dit is de belangrijkste content.&lt;/article&gt;
&lt;/main&gt;</code></pre>
                <div class="live-example">
                    <main style="border: 1px solid var(--border-color); padding: 10px; border-radius: 5px;">
                        <article>Dit is de belangrijkste content.</article>
                    </main>
                </div>

                <h4><code>&lt;section&gt;</code></h4>
                <p>Functie: Groepeert gerelateerde inhoud in een logisch blok.</p>
                <pre><code>&lt;section&gt;
  &lt;h2&gt;Diensten&lt;/h2&gt;
  &lt;p&gt;Wij bieden...&lt;/p&gt;
&lt;/section&gt;</code></pre>
                <div class="live-example">
                    <section style="border: 1px solid var(--border-color); padding: 10px; border-radius: 5px;">
                        <h2>Diensten</h2>
                        <p>Wij bieden...</p>
                    </section>
                </div>

                <h4><code>&lt;article&gt;</code></h4>
                <p>Functie: Zelfstandig inhoudsblok dat los kan staan, zoals een blogpost of nieuwsartikel.</p>
                <pre><code>&lt;article&gt;
  &lt;h2&gt;Nieuws&lt;/h2&gt;
  &lt;p&gt;Vandaag is...&lt;/p&gt;
&lt;/article&gt;</code></pre>
                <div class="live-example">
                    <article style="border: 1px solid var(--border-color); padding: 10px; border-radius: 5px;">
                        <h2>Nieuws</h2>
                        <p>Vandaag is...</p>
                    </article>
                </div>

                <h4><code>&lt;aside&gt;</code></h4>
                <p>Functie: Bevat extra informatie zoals een sidebar, gerelateerde links of advertenties.</p>
                <pre><code>&lt;aside&gt;
  &lt;h3&gt;Gerelateerd&lt;/h3&gt;
  &lt;ul&gt;
    &lt;li&gt;Artikel 1&lt;/li&gt;
  &lt;/ul&gt;
&lt;/aside&gt;</code></pre>
                <div class="live-example">
                    <aside
                        style="border: 1px solid var(--border-color); padding: 10px; border-radius: 5px; background-color: #f9fafb;">
                        <h3>Gerelateerd</h3>
                        <ul>
                            <li>Artikel 1</li>
                        </ul>
                    </aside>
                </div>

                <h4><code>&lt;footer&gt;</code></h4>
                <p>Functie: Onderste sectie van een pagina of artikel, vaak met contactgegevens of copyright.</p>
                <pre><code>&lt;footer&gt;
  &lt;p&gt;&copy; 2025 Mijn Bedrijf&lt;/p&gt;
&lt;/footer&gt;</code></pre>
                <div class="live-example">
                    <footer style="border: 1px solid var(--border-color); padding: 10px; border-radius: 5px;">
                        <p>© 2025 Mijn Bedrijf</p>
                    </footer>
                </div>

                <h4><code>&lt;div&gt;</code></h4>
                <p>Functie: Algemeen container-element zonder semantiek, puur voor groepering of styling.</p>
                <pre><code>&lt;div class="container"&gt;
  &lt;p&gt;Inhoud&lt;/p&gt;
&lt;/div&gt;</code></pre>
                <div class="live-example">
                    <div class="container"
                        style="border: 1px solid var(--accent-color); padding: 10px; border-radius: 5px;">
                        <p>Inhoud in een div.</p>
                    </div>
                </div>

                <h4><code>&lt;span&gt;</code></h4>
                <p>Functie: Inline container voor tekst of kleine elementen, vaak gebruikt voor styling.</p>
                <pre><code>&lt;p&gt;Dit is &lt;span class="highlight"&gt;belangrijk&lt;/span&gt;!&lt;/p&gt;</code></pre>
                <div class="live-example">
                    <p>Dit is <span class="highlight"
                            style="background-color: #fef08a; padding: 2px 4px; border-radius: 3px;">belangrijk</span>!
                    </p>
                </div>

                <h4><code>&lt;details&gt;</code> en <code>&lt;summary&gt;</code></h4>
                <p>Functie: Creëert een opklapbare container voor extra informatie. <code>&lt;summary&gt;</code> is de
                    titel.</p>
                <pre><code>&lt;details&gt;
  &lt;summary&gt;Meer info&lt;/summary&gt;
  &lt;p&gt;Uitgebreide beschrijving...&lt;/p&gt;
&lt;/details&gt;</code></pre>
                <div class="live-example">
                    <details>
                        <summary>Meer info</summary>
                        <p>Uitgebreide beschrijving...</p>
                    </details>
                </div>

                <h4><code>&lt;dialog&gt;</code></h4>
                <p>Functie: Venster voor modals of pop-ups.</p>
                <pre><code>&lt;dialog id="layoutDialog"&gt;
  &lt;p&gt;Dit is een dialoogvenster&lt;/p&gt;
&lt;/dialog&gt;
&lt;button onclick="layoutDialog.showModal()"&gt;Toon dialoog&lt;/button&gt;</code></pre>
                <div class="live-example">
                    <dialog id="layoutDialog">
                        <p>Dit is een dialoogvenster</p>
                        <form method="dialog"><button>Sluiten</button></form>
                    </dialog>
                    <button onclick="document.getElementById('layoutDialog').showModal()">Toon dialoog</button>
                </div>

                <h4><code>&lt;fieldset&gt;</code></h4>
                <p>Functie: Groepeert gerelateerde formulierelementen, vaak met een <code>&lt;legend&gt;</code> als
                    titel.</p>
                <pre><code>&lt;fieldset&gt;
  &lt;legend&gt;Persoonlijke info&lt;/legend&gt;
  &lt;input type="text" placeholder="Naam"&gt;
&lt;/fieldset&gt;</code></pre>
                <div class="live-example">
                    <fieldset>
                        <legend>Persoonlijke info</legend>
                        <input type="text" placeholder="Naam">
                    </fieldset>
                </div>
            </section>

            <section id="html-actuele-elementen">
                <h3>Actuele HTML-elementen & Samenvatting</h3>
                <p>Voor een volledige en actuele lijst van alle HTML-elementen kun je het beste de officiële
                    documentatie raadplegen.</p>
                <ul>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element" target="_blank"
                            rel="noopener">MDN Web Docs: HTML element reference</a></li>
                    <li><a href="https://html.spec.whatwg.org/multipage/" target="_blank" rel="noopener">HTML Living
                            Standard</a></li>
                </ul>

                <h4>Aanbeveling Elementen</h4>
                <p>Gebruik actuele HTML5-elementen voor een betere structuur, toegankelijkheid en SEO. Voorbeelden zijn:
                </p>
                <p><code>&lt;article&gt;</code>, <code>&lt;section&gt;</code>, <code>&lt;nav&gt;</code>,
                    <code>&lt;canvas&gt;</code>, <code>&lt;template&gt;</code>, <code>&lt;video&gt;</code>,
                    <code>&lt;audio&gt;</code>, <code>&lt;details&gt;</code>, <code>&lt;dialog&gt;</code>,
                    <code>&lt;picture&gt;</code>, <code>&lt;ruby&gt;</code>, <code>&lt;time&gt;</code>,
                    <code>&lt;track&gt;</code>, <code>&lt;progress&gt;</code>, <code>&lt;data&gt;</code>,
                    <code>&lt;datalist&gt;</code>, <code>&lt;mark&gt;</code>, <code>&lt;meter&gt;</code>,
                    <code>&lt;figure&gt;</code>, <code>&lt;figcaption&gt;</code>, <code>&lt;footer&gt;</code>,
                    <code>&lt;header&gt;</code>, <code>&lt;output&gt;</code>, <code>&lt;wbr&gt;</code>.
                </p>

                <h4><code>&lt;figure&gt;</code> en <code>&lt;figcaption&gt;</code></h4>
                <p>Wordt gebruikt om content zoals afbeeldingen, diagrammen of codefragmenten te groeperen met een
                    bijschrift (<code>&lt;figcaption&gt;</code>).</p>
                <pre><code>&lt;figure&gt;
  &lt;img src="https://placehold.co/200x100" alt="Verkoopcijfers Q3"&gt;
  &lt;figcaption&gt;Fig. 1: Verkoopcijfers voor het derde kwartaal.&lt;/figcaption&gt;
&lt;/figure&gt;</code></pre>
                <div class="live-example">
                    <figure>
                        <img src="https://placehold.co/200x100/e2e8f0/334155?text=Grafiek" alt="Verkoopcijfers Q3">
                        <figcaption>Fig. 1: Verkoopcijfers voor het derde kwartaal.</figcaption>
                    </figure>
                </div>

                <h4><code>&lt;progress&gt;</code> en <code>&lt;meter&gt;</code></h4>
                <p><code>&lt;progress&gt;</code> toont de voortgang van een taak. <code>&lt;meter&gt;</code>
                    representeert een scalaire meting binnen een bekend bereik (zoals schijfgebruik).</p>
                <pre><code>&lt;label for="file"&gt;Bestand downloaden:&lt;/label&gt;
&lt;progress id="file" value="70" max="100"&gt; 70% &lt;/progress&gt;

&lt;label for="disk"&gt;Schijfgebruik:&lt;/label&gt;
&lt;meter id="disk" value="0.6"&gt;60%&lt;/meter&gt;</code></pre>
                <div class="live-example">
                    <label for="file-live">Bestand downloaden:</label>
                    <progress id="file-live" value="70" max="100"> 70% </progress>
                    <br>
                    <label for="disk-live">Schijfgebruik:</label>
                    <meter id="disk-live" value="0.6">60%</meter>
                </div>

                <h4>Te vermijden verouderde (deprecated) elementen</h4>
                <p>Vermijd verouderde tags die voor styling werden gebruikt. Gebruik CSS voor presentatie. Voorbeelden
                    van te vermijden tags zijn:</p>
                <p><code>&lt;font&gt;</code>, <code>&lt;center&gt;</code>, <code>&lt;applet&gt;</code>,
                    <code>&lt;dir&gt;</code>, <code>&lt;strike&gt;</code>, <code>&lt;big&gt;</code>.
                </p>
            </section>

            <section id="html-actuele-attributen">
                <h3>Actuele HTML-attributen</h3>
                <p>Attributen geven extra informatie over HTML-elementen en worden altijd in de start-tag
                    gespecificeerd. Ze bestaan meestal uit een naam/waarde-paar zoals <code>name="value"</code>.</p>

                <h4>Globale Attributen</h4>
                <p>Globale attributen kunnen op vrijwel elk HTML-element worden toegepast.</p>

                <h5><code>class</code> en <code>id</code></h5>
                <p><code>id</code> geeft een element een unieke identificatie. <code>class</code> wijst een of meer
                    klassen toe voor styling en scripting. Een <code>id</code> moet uniek zijn op de hele pagina; een
                    <code>class</code> kan hergebruikt worden.
                </p>
                <pre><code>&lt;div id="main-content" class="container dark-theme"&gt;...&lt;/div&gt;</code></pre>
                <div class="live-example">
                    <div id="main-content-example" class="container-example dark-theme-example"
                        style="border: 1px solid var(--border-color); padding: 10px;">Dit div-element heeft
                        id="main-content-example" en class="container-example dark-theme-example".</div>
                </div>

                <h5><code>style</code></h5>
                <p>Voegt inline CSS-stijlen toe direct aan een element. Gebruik dit met mate; externe stylesheets zijn
                    over het algemeen beter voor onderhoud.</p>
                <pre><code>&lt;p style="color: red; font-weight: bold;"&gt;Deze tekst is rood en vet.&lt;/p&gt;</code></pre>
                <div class="live-example">
                    <p style="color: red; font-weight: bold;">Deze tekst is rood en vet.</p>
                </div>

                <h5><code>title</code></h5>
                <p>Biedt extra, adviserende informatie over een element. Browsers tonen dit vaak als een tooltip wanneer
                    je met de muis over het element beweegt.</p>
                <pre><code>&lt;button title="Klik hier om het formulier te verzenden"&gt;Verstuur&lt;/button&gt;</code></pre>
                <div class="live-example">
                    <button title="Klik hier om het formulier te verzenden">Verstuur</button>
                </div>

                <h5><code>lang</code> en <code>dir</code></h5>
                <p><code>lang</code> specificeert de taal van de inhoud van een element. <code>dir</code> specificeert
                    de tekstrichting (<code>ltr</code> voor links-naar-rechts, <code>rtl</code> voor rechts-naar-links).
                </p>
                <pre><code>&lt;p lang="fr"&gt;Bonjour le monde!&lt;/p&gt;</code></pre>
                <div class="live-example">
                    <p lang="fr">Bonjour le monde!</p>
                    <p dir="rtl">.مرحبا بالعالم</p>
                </div>

                <h5><code>hidden</code></h5>
                <p>Een booleaans attribuut dat aangeeft dat een element nog niet (of niet langer) relevant is. De
                    browser zal het element niet weergeven.</p>
                <pre><code>&lt;p hidden&gt;Deze paragraaf is verborgen.&lt;/p&gt;</code></pre>
                <div class="live-example">
                    <p>Er is een verborgen paragraaf na deze zin (bekijk de broncode).</p>
                    <p hidden>Deze paragraaf is verborgen.</p>
                </div>

                <h5><code>tabindex</code></h5>
                <p>Beïnvloedt de navigatievolgorde met het toetsenbord (Tab-toets). Een waarde van <code>0</code> maakt
                    een element focusseerbaar in de natuurlijke volgorde. Een negatieve waarde (bv. <code>-1</code>)
                    maakt het focusseerbaar via script, maar niet via de Tab-toets.</p>
                <pre><code>&lt;div tabindex="0"&gt;Dit element kan focus krijgen.&lt;/div&gt;</code></pre>
                <div class="live-example">
                    <p>Probeer met de Tab-toets naar de volgende box te navigeren.</p>
                    <div tabindex="0" style="border: 1px solid #ccc; padding: 10px; outline: none;"
                        onfocus="this.style.borderColor='var(--accent-color)'" onblur="this.style.borderColor='#ccc'">
                        Dit element kan focus krijgen.</div>
                </div>

                <h5><code>contenteditable</code></h5>
                <p>Geeft aan dat de gebruiker de inhoud van het element direct in de browser kan bewerken.</p>
                <pre><code>&lt;p contenteditable="true"&gt;Je kunt deze tekst aanpassen.&lt;/p&gt;</code></pre>
                <div class="live-example">
                    <p contenteditable="true" style="border: 1px dashed #ccc; padding: 5px;">Je kunt deze tekst
                        aanpassen.</p>
                </div>

                <h5><code>data-*</code></h5>
                <p>Hiermee kun je aangepaste data-attributen toevoegen om willekeurige informatie op te slaan, die je
                    later kunt gebruiken met JavaScript.</p>
                <pre><code>&lt;div data-user-id="12345" data-role="admin"&gt;Gebruikersinformatie&lt;/div&gt;</code></pre>
                <div class="live-example">
                    <div data-user-id="12345" data-role="admin">Dit element bevat custom data-attributen (niet
                        zichtbaar, maar bruikbaar voor JS).</div>
                </div>

                <h4>Veelgebruikte specifieke attributen</h4>

                <h5><code>href</code>, <code>src</code>, en <code>alt</code></h5>
                <p><code>href</code> (hypertext reference) specificeert de URL voor een link (<code>&lt;a&gt;</code>).
                    <code>src</code> (source) specificeert de bron voor media-elementen zoals <code>&lt;img&gt;</code>,
                    <code>&lt;script&gt;</code>, en <code>&lt;video&gt;</code>. <code>alt</code> (alternative text)
                    biedt een tekstueel alternatief voor een afbeelding, wat cruciaal is voor toegankelijkheid.
                </p>
                <pre><code>&lt;a href="/about"&gt;Over ons&lt;/a&gt;
&lt;img src="logo.png" alt="Logo van het bedrijf"&gt;</code></pre>
                <div class="live-example">
                    <a href="#html-actuele-attributen">Dit is een link.</a>
                    <br>
                    <img src="https://placehold.co/150x50/e2e8f0/334155?text=Logo" alt="Logo van het bedrijf">
                </div>

                <h5><code>placeholder</code>, <code>required</code>, <code>disabled</code></h5>
                <p>Deze attributen worden vaak gebruikt in formulieren. <code>placeholder</code> toont een hint in een
                    invoerveld. <code>required</code> geeft aan dat een veld ingeveld moet worden. <code>disabled</code>
                    schakelt een invoerveld uit.</p>
                <pre><code>&lt;input type="email" placeholder="naam@voorbeeld.com" required&gt;
&lt;button type="submit" disabled&gt;Verstuur (uitgeschakeld)&lt;/button&gt;</code></pre>
                <div class="live-example">
                    <input type="email" placeholder="naam@voorbeeld.com" required
                        style="padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
                    <button type="submit" disabled>Verstuur (uitgeschakeld)</button>
                </div>

                <h5><code>async</code> en <code>defer</code></h5>
                <p>Deze booleaanse attributen voor het <code>&lt;script&gt;</code>-element beïnvloeden hoe een extern
                    script wordt geladen en uitgevoerd. <code>defer</code> voert het script uit nadat de pagina is
                    geparsed. <code>async</code> voert het uit zodra het is gedownload, wat de paginaparsing kan
                    onderbreken.</p>
                <pre><code>&lt;script src="analytics.js" async&gt;&lt;/script&gt;
&lt;script src="app.js" defer&gt;&lt;/script&gt;</code></pre>
            </section>

            <section id="html-aria">
                <h3>ARIA (Accessible Rich Internet Applications)</h3>
                <p>ARIA-attributen helpen om de toegankelijkheid van dynamische webapplicaties te verbeteren, vooral
                    voor gebruikers van schermlezers. Gebruik het waar native HTML semantiek tekortschiet.</p>
                <ul>
                    <li><code>role</code>: Definieert de rol van een element (bv. `role="button"`, `role="navigation"`).
                    </li>
                    <li><code>aria-label</code>: Geeft een toegankelijke naam aan een element zonder zichtbare tekst.
                    </li>
                    <li><code>aria-labelledby</code>: Verwijst naar de `id` van een ander element dat als label dient.
                    </li>
                    <li><code>aria-hidden="true"</code>: Verbergt een element voor toegankelijkheidstechnologie.</li>
                    <li><code>aria-expanded="true/false"</code>: Geeft aan of een uitklapbaar element open of gesloten
                        is.</li>
                </ul>
                <pre><code>&lt;button aria-label="Sluit venster"&gt;X&lt;/button&gt;
&lt;div role="tabpanel" aria-labelledby="tab1"&gt;...&lt;/div&gt;</code></pre>
            </section>

            <section id="html-cheatsheet">
                <h3>HTML Cheatsheet</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Categorie</th>
                            <th>Elementen</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Structuur</strong></td>
                            <td><code>&lt;!DOCTYPE html&gt;</code>, <code>&lt;html&gt;</code>,
                                <code>&lt;head&gt;</code>, <code>&lt;body&gt;</code>, <code>&lt;main&gt;</code>,
                                <code>&lt;header&gt;</code>, <code>&lt;footer&gt;</code>, <code>&lt;nav&gt;</code>,
                                <code>&lt;section&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;aside&gt;</code>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Tekst</strong></td>
                            <td><code>&lt;h1&gt;</code>-<code>&lt;h6&gt;</code>, <code>&lt;p&gt;</code>,
                                <code>&lt;span&gt;</code>, <code>&lt;a&gt;</code>, <code>&lt;strong&gt;</code>,
                                <code>&lt;em&gt;</code>, <code>&lt;blockquote&gt;</code>, <code>&lt;code&gt;</code>,
                                <code>&lt;pre&gt;</code>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Lijsten</strong></td>
                            <td><code>&lt;ul&gt;</code>, <code>&lt;ol&gt;</code>, <code>&lt;li&gt;</code>,
                                <code>&lt;dl&gt;</code>, <code>&lt;dt&gt;</code>, <code>&lt;dd&gt;</code>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Tabellen</strong></td>
                            <td><code>&lt;table&gt;</code>, <code>&lt;thead&gt;</code>, <code>&lt;tbody&gt;</code>,
                                <code>&lt;tr&gt;</code>, <code>&lt;th&gt;</code>, <code>&lt;td&gt;</code>,
                                <code>&lt;caption&gt;</code>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Media</strong></td>
                            <td><code>&lt;img&gt;</code>, <code>&lt;video&gt;</code>, <code>&lt;audio&gt;</code>,
                                <code>&lt;picture&gt;</code>, <code>&lt;source&gt;</code>, <code>&lt;iframe&gt;</code>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Formulieren</strong></td>
                            <td><code>&lt;form&gt;</code>, <code>&lt;label&gt;</code>, <code>&lt;input&gt;</code>,
                                <code>&lt;textarea&gt;</code>, <code>&lt;select&gt;</code>, <code>&lt;option&gt;</code>,
                                <code>&lt;button&gt;</code>, <code>&lt;fieldset&gt;</code>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- ====================================================================== -->
            <!-- ============================== CSS =================================== -->
            <!-- ====================================================================== -->
            <section id="css">
                <h2>CSS: Cascading Style Sheets</h2>
                <p>CSS is verantwoordelijk voor de presentatie en styling van je HTML-document. Het bepaalt hoe
                    elementen eruitzien, van kleuren en lettertypen tot complexe layouts.</p>
            </section>

            <section id="css-basics">
                <h3>Basis & Selectors</h3>
                <p>CSS wordt toegepast via regels. Een regel bestaat uit een selector en een declaratieblok.</p>
                <pre><code>selector {
    property: value;
}</code></pre>

                <h4>Selectors</h4>
                <ul>
                    <li><strong>Type Selector</strong>: Selecteert op elementnaam (<code>p</code>, <code>div</code>).
                    </li>
                    <li><strong>Class Selector</strong>: Selecteert op class-attribuut (<code>.mijn-klasse</code>).</li>
                    <li><strong>ID Selector</strong>: Selecteert op id-attribuut (<code>#mijn-id</code>). Uniek per
                        pagina.</li>
                    <li><strong>Attribute Selector</strong>: Selecteert op aanwezigheid of waarde van een attribuut
                        (<code>[type="text"]</code>).</li>
                    <li><strong>Pseudo-classes</strong>: Selecteert op een bepaalde staat (<code>:hover</code>,
                        <code>:focus</code>, <code>:nth-child(n)</code>).
                    </li>
                    <li><strong>Pseudo-elements</strong>: Stijlt een deel van een element (<code>::before</code>,
                        <code>::after</code>, <code>::first-letter</code>).
                    </li>
                    <li><strong>Combinators</strong>: <code>div p</code> (descendant), <code>div > p</code> (child),
                        <code>h2 + p</code> (adjacent sibling), <code>h2 ~ p</code> (general sibling).
                    </li>
                </ul>

                <h4>De Cascade & Specificiteit</h4>
                <p>De "cascade" bepaalt welke stijlregel wint als er meerdere van toepassing zijn. De volgorde is:
                    1. Belangrijkheid (`!important`)
                    2. Specificiteit (ID > Class/Attribute/Pseudo-class > Type/Pseudo-element)
                    3. Volgorde in de broncode (de laatste wint).
                </p>
            </section>

            <section id="css-pseudo-classes">
                <h3>CSS Pseudo-classes — betekenis & gebruik</h3>
                <p>Een pseudo-class wordt toegevoegd aan een selector om een element te selecteren in een bepaalde staat
                    of positie, zoals wanneer je er met je muis over beweegt, of wanneer het het eerste of laatste kind
                    van een ander element is.</p>

                <h4>Structureel & document</h4>
                <h5><code>:root</code></h5>
                <p>Selecteert het hoogste element in de DOM-tree. In HTML is dit altijd het
                    <code>&lt;html&gt;</code>-element. Het is de ideale plek om globale CSS-variabelen te definiëren die
                    je in je hele stylesheet wilt gebruiken.
                </p>
                <pre><code>:root {
  --main-font-size: 16px;
  --primary-color: #3b82f6;
}

body {
  font-size: var(--main-font-size);
  color: var(--primary-color);
}</code></pre>
                <div class="live-example">
                    <style>
                        .example-root {
                            color: var(--accent-color);
                            font-weight: bold;
                        }
                    </style>
                    <p class="example-root">Deze tekst gebruikt de accentkleur die globaal is gedefinieerd in :root.</p>
                </div>

                <h5><code>:empty</code></h5>
                <p>Selecteert elk element dat geen kinderen heeft. Dit omvat ook tekstelementen of zelfs witruimte. Het
                    is handig om lege elementen te verbergen die anders ongewenste ruimte zouden innemen.</p>
                <pre><code>/* Verberg een lege alert-box */
.alert:empty {
  display: none;
}</code></pre>
                <div class="live-example">
                    <style>
                        .alert-box {
                            border: 1px solid #ccc;
                            padding: 10px;
                            margin-top: 5px;
                        }

                        .alert-box:empty {
                            display: none;
                        }
                    </style>
                    <div class="alert-box">Ik ben een alert.</div>
                    <div class="alert-box"></div>
                    <p>De tweede (lege) alert-box hierboven is verborgen met <code>:empty</code>.</p>
                </div>

                <h5><code>:first-child</code> / <code>:last-child</code> / <code>:only-child</code></h5>
                <p>Deze selecteren elementen op basis van hun positie binnen een ouder-element.
                    <code>:first-child</code> selecteert het eerste kind, <code>:last-child</code> het laatste, en
                    <code>:only-child</code> een element dat het enige kind is.
                </p>
                <pre><code>/* Geen border-top voor het eerste item */
.list-item:first-child {
  border-top: none;
}

/* Een andere achtergrond voor het laatste item */
.list-item:last-child {
  background-color: #f0f0f0;
}

/* Speciale styling als er maar één item is */
.list-item:only-child {
  font-weight: bold;
}</code></pre>
                <div class="live-example">
                    <style>
                        .example-list .item:first-child {
                            font-weight: bold;
                            color: #3b82f6;
                        }

                        .example-list .item:last-child {
                            font-style: italic;
                            color: #8b5cf6;
                        }

                        .example-list-single .item:only-child {
                            border: 1px solid #10b981;
                            padding: 5px;
                        }
                    </style>
                    <div class="example-list">
                        <p class="item">Eerste item (vet en blauw)</p>
                        <p class="item">Tweede item</p>
                        <p class="item">Laatste item (cursief en paars)</p>
                    </div>
                    <div class="example-list-single">
                        <p class="item">Enig kind (met een rand)</p>
                    </div>
                </div>

                <h5><code>:nth-child(n)</code></h5>
                <p>De "nth-child" selector is zeer krachtig. Je kunt elementen selecteren op basis van hun positie met
                    een formule (an+b) of sleutelwoorden zoals <code>even</code> (2n) en <code>odd</code> (2n+1). Dit is
                    perfect voor "zebra-striping" in tabellen of lijsten.</p>
                <pre><code>/* Geef elke even rij in een tabel een lichte achtergrond */
tbody tr:nth-child(even) {
  background-color: #f8f9fa;
}

/* Selecteer het derde lijstitem */
li:nth-child(3) {
  color: var(--accent-color);
}</code></pre>
                <div class="live-example">
                    <style>
                        .nth-example li:nth-child(odd) {
                            background-color: #eff6ff;
                        }
                    </style>
                    <ul class="nth-example">
                        <li>Item 1 (oneven)</li>
                        <li>Item 2</li>
                        <li>Item 3 (oneven)</li>
                        <li>Item 4</li>
                    </ul>
                </div>

                <h5><code>:first-of-type</code> / <code>:last-of-type</code></h5>
                <p>Deze lijken op <code>:first-child</code>, maar ze selecteren het eerste of laatste element van een
                    specifiek *type* binnen een ouder. Dit is handig als de elementen gemengd zijn.</p>
                <pre><code>article div:first-of-type {
  /* Stijlt de eerste div in het artikel, zelfs als een h2 ervoor staat */
  font-style: italic;
}

article p:last-of-type {
  /* Stijlt de laatste paragraaf in het artikel */
  margin-bottom: 0;
}</code></pre>
                <div class="live-example">
                    <style>
                        .oftype-example p:first-of-type {
                            font-weight: bold;
                        }
                    </style>
                    <div class="oftype-example">
                        <h4>Titel</h4>
                        <p>Dit is de eerste paragraaf (vet).</p>
                        <p>Dit is de tweede paragraaf.</p>
                    </div>
                </div>

                <h4>Links & locaties</h4>
                <h5><code>:link</code> / <code>:visited</code></h5>
                <p><code>:link</code> stijlt een hyperlink die nog niet is bezocht. <code>:visited</code> stijlt een
                    link die de gebruiker al heeft bezocht. Vanwege privacyredenen zijn de stijlen die je op
                    <code>:visited</code> kunt toepassen beperkt (voornamelijk kleur).
                </p>
                <pre><code>a:link {
  color: #3b82f6; /* Blauw voor onbezochte links */
}

a:visited {
  color: #8b5cf6; /* Paars voor bezochte links */
}</code></pre>
                <div class="live-example">
                    <p>Klik op de link. Een onbezochte link is blauw, een bezochte is paars.</p>
                    <a href="#css-pseudo-classes">Voorbeeld link</a>
                </div>

                <h5><code>:any-link</code></h5>
                <p>Dit is een handige shorthand die zowel <code>:link</code> als <code>:visited</code> selecteert.
                    Hiermee kun je gemeenschappelijke stijlen instellen voor alle links, ongeacht hun bezochte status.
                </p>
                <pre><code>/* Geef alle links een onderlijning bij hover */
nav a:any-link:hover {
  text-decoration: underline;
}</code></pre>
                <div class="live-example">
                    <style>
                        .anylink-example a:any-link {
                            font-family: serif;
                        }
                    </style>
                    <p class="anylink-example">Deze <a href="#css-pseudo-classes">link</a> heeft een serif lettertype,
                        ongeacht of hij bezocht is.</p>
                </div>

                <h5><code>:target</code></h5>
                <p>Selecteert het element waarvan de <code>id</code> overeenkomt met de fragment-identifier in de URL
                    (de tekst na de '#'). Dit wordt vaak gebruikt om een specifiek deel van een pagina te markeren of om
                    "CSS-only" tabs te maken.</p>
                <pre><code>/* Markeer een sectie wanneer ernaar gelinkt wordt */
section:target {
  background-color: #fefce8; /* Lichtgeel */
  border-left: 4px solid #facc15;
}</code></pre>
                <div class="live-example">
                    <p><a href="#target-example">Klik hier</a> om de onderstaande box te "targeten".</p>
                    <div id="target-example" style="padding: 10px; border: 1px solid #ccc; transition: all 0.3s;">Deze
                        box zal van stijl veranderen.</div>
                    <style>
                        #target-example:target {
                            background: #fefce8;
                            border-color: #facc15;
                        }
                    </style>
                </div>

                <h4>Interactie & focus</h4>
                <h5><code>:hover</code> / <code>:active</code></h5>
                <p><code>:hover</code> wordt actief wanneer de gebruiker met de muis over een element beweegt.
                    <code>:active</code> is voor de korte periode dat een element wordt aangeklikt.
                </p>
                <pre><code>button {
  transition: transform 0.1s ease;
}

button:hover {
  background-color: #2563eb; /* Donkerder blauw */
}

button:active {
  transform: scale(0.95); /* Maak de knop kleiner bij klikken */
}</code></pre>
                <div class="live-example">
                    <style>
                        .interaction-btn {
                            background-color: #3b82f6;
                            color: white;
                            border: none;
                            padding: 10px 15px;
                            border-radius: 5px;
                            cursor: pointer;
                            transition: all 0.2s;
                        }

                        .interaction-btn:hover {
                            background-color: #2563eb;
                        }

                        .interaction-btn:active {
                            transform: scale(0.95);
                            background-color: #1d4ed8;
                        }
                    </style>
                    <button class="interaction-btn">Beweeg & Klik</button>
                </div>

                <h5><code>:focus</code> / <code>:focus-visible</code> / <code>:focus-within</code></h5>
                <p><code>:focus</code> stijlt een element dat focus heeft (bv. een inputveld waarin je typt).
                    <code>:focus-visible</code> is een slimmere versie die de focusstijl meestal alleen toont bij
                    toetsenbordnavigatie. <code>:focus-within</code> stijlt een *ouderelement* als een van zijn
                    *kinderen* de focus heeft.
                </p>
                <pre><code>/* Stijl een input wanneer het focus heeft */
input:focus {
  outline: 2px solid var(--accent-color);
  border-color: transparent;
}

/* Stijl het hele formulier-item als de input focus heeft */
.form-group:focus-within {
  background-color: #eff6ff;
}</code></pre>
                <div class="live-example">
                    <style>
                        .focus-example-group {
                            padding: 10px;
                            border: 1px solid #ccc;
                            border-radius: 5px;
                            transition: background-color 0.3s;
                        }

                        .focus-example-group:focus-within {
                            background-color: #eff6ff;
                            border-color: #93c5fd;
                        }

                        .focus-example-group input {
                            border: 1px solid #ccc;
                            padding: 5px;
                            border-radius: 3px;
                        }

                        .focus-example-group input:focus {
                            outline: none;
                        }
                    </style>
                    <div class="focus-example-group">
                        <label for="focus-input">Klik hier: </label>
                        <input type="text" id="focus-input" placeholder="Typ iets...">
                    </div>
                </div>

                <h4>Formulieren & UI</h4>
                <h5><code>:checked</code></h5>
                <p>Selecteert een checkbox of radio-button die is aangevinkt.</p>
                <pre><code>/* Stijl het label naast een aangevinkte checkbox */
input[type="checkbox"]:checked + label {
  text-decoration: line-through;
  color: #6b7280;
}</code></pre>
                <div class="live-example">
                    <style>
                        .checked-example input:checked+label {
                            text-decoration: line-through;
                            color: #6b7280;
                        }
                    </style>
                    <div class="checked-example">
                        <input type="checkbox" id="task1">
                        <label for="task1">Taak 1</label>
                    </div>
                </div>

                <h5><code>:disabled</code> / <code>:enabled</code></h5>
                <p>Selecteert formulierelementen die respectievelijk uit- of ingeschakeld zijn. Dit is handig om visueel
                    duidelijk te maken dat een veld niet kan worden gebruikt.</p>
                <pre><code>input:disabled {
  background-color: #e5e7eb;
  cursor: not-allowed;
}</code></pre>
                <div class="live-example">
                    <style>
                        .disabled-example input:disabled {
                            background-color: #e5e7eb;
                            cursor: not-allowed;
                        }
                    </style>
                    <div class="disabled-example">
                        <input type="text" value="Je kunt hier niet typen" disabled>
                    </div>
                </div>

                <h5><code>:required</code> / <code>:optional</code></h5>
                <p>Selecteert formuliervelden die respectievelijk het <code>required</code> attribuut hebben of niet.
                </p>
                <pre><code>/* Voeg een asterisk toe aan het label van een verplicht veld */
label.for-required::after {
  content: ' *';
  color: #ef4444;
}</code></pre>
                <div class="live-example">
                    <style>
                        .required-example input:required {
                            border-left: 3px solid #f87171;
                        }

                        .required-example input:optional {
                            border-left: 3px solid #a3e635;
                        }
                    </style>
                    <div class="required-example">
                        <p>Naam (verplicht):</p>
                        <input type="text" required>
                        <p>Hobby (optioneel):</p>
                        <input type="text">
                    </div>
                </div>

                <h5><code>:valid</code> / <code>:invalid</code></h5>
                <p>Stijlt een input-element op basis van de ingebouwde HTML5-validatie. Een
                    <code>&lt;input type="email"&gt;</code> is bijvoorbeeld <code>:invalid</code> totdat er een geldig
                    e-mailadres is ingevoerd.
                </p>
                <pre><code>input:invalid {
  border-color: #ef4444; /* Rode rand voor ongeldige invoer */
}

input:valid {
  border-color: #22c55e; /* Groene rand voor geldige invoer */
}</code></pre>
                <div class="live-example">
                    <style>
                        .validation-example input:invalid {
                            border-color: #ef4444;
                        }

                        .validation-example input:valid {
                            border-color: #22c55e;
                        }
                    </style>
                    <div class="validation-example">
                        <p>Voer een e-mailadres in:</p>
                        <input type="email" placeholder="naam@voorbeeld.com">
                    </div>
                </div>

                <h4>Relationeel</h4>
                <h5><code>:not(selector)</code></h5>
                <p>De "negatie" pseudo-class. Het selecteert elk element dat *niet* overeenkomt met de selector tussen
                    de haakjes.</p>
                <pre><code>/* Geef alle navigatielinks een stijl, behalve de actieve */
nav a:not(.active) {
  opacity: 0.7;
}</code></pre>
                <div class="live-example">
                    <style>
                        .not-example p:not(.highlight) {
                            color: #9ca3af;
                        }
                    </style>
                    <div class="not-example">
                        <p>Grijze tekst.</p>
                        <p class="highlight">Normale tekst.</p>
                        <p>Grijze tekst.</p>
                    </div>
                </div>

                <h5><code>:has(selector)</code></h5>
                <p>De langverwachte "parent selector". Het selecteert een element als het een of meer kinderen bevat die
                    overeenkomen met de selector tussen de haakjes. Dit opent veel nieuwe mogelijkheden.</p>
                <pre><code>/* Stijl een 'figure' element anders als het een 'figcaption' bevat */
figure:has(figcaption) {
  border: 1px solid var(--border-color);
  padding: 1rem;
}</code></pre>
                <div class="live-example">
                    <style>
                        .has-example .card:has(img) {
                            background-color: #f3f4f6;
                        }
                    </style>
                    <div class="has-example">
                        <div class="card" style="padding: 10px; border: 1px solid #ccc; margin-bottom: 5px;">
                            <p>Kaart zonder afbeelding.</p>
                        </div>
                        <div class="card" style="padding: 10px; border: 1px solid #ccc;">
                            <img src="https://placehold.co/100x50/e2e8f0/334155?text=Img" alt="placeholder">
                            <p>Deze kaart heeft een afbeelding en krijgt een achtergrondkleur.</p>
                        </div>
                    </div>
                </div>
            </section>

            <section id="css-pseudo-elements">
                <h3>CSS Pseudo-elements — betekenis & gebruik</h3>
                <p>Een pseudo-element (te herkennen aan de dubbele punt <code>::</code>) gedraagt zich als een extra
                    element dat je in de DOM invoegt en kunt stijlen met CSS, zonder dat je de HTML hoeft aan te passen.
                </p>

                <h5><code>::before</code> / <code>::after</code></h5>
                <p>Dit zijn de meest gebruikte pseudo-elementen. Ze voegen content toe respectievelijk *vóór* of *ná* de
                    content van het geselecteerde element. De <code>content</code> eigenschap is vereist, maar kan leeg
                    zijn (<code>content: '';</code>) als je het alleen voor styling gebruikt (bv. als vorm of
                    achtergrondlaag).</p>
                <pre><code>/* Voeg een citaat-icoon toe voor een blockquote */
blockquote::before {
  content: '“';
  font-size: 3em;
  color: var(--accent-color);
  float: left;
  margin-right: 0.2em;
}</code></pre>
                <div class="live-example">
                    <style>
                        .before-example::before {
                            content: '► ';
                            color: var(--accent-color);
                        }
                    </style>
                    <p class="before-example">Deze regel heeft een pijl ervoor.</p>
                </div>

                <h5><code>::first-letter</code></h5>
                <p>Selecteert de eerste letter van de eerste regel van een block-level element. Perfect voor het maken
                    van een "drop cap" (een grote, gestileerde beginletter).</p>
                <pre><code>article p:first-of-type::first-letter {
  font-size: 2.5rem;
  font-weight: bold;
  color: #1e293b;
  margin-right: 0.1em;
  float: left;
}</code></pre>
                <div class="live-example">
                    <style>
                        .first-letter-example::first-letter {
                            font-size: 2em;
                            color: var(--accent-color);
                            font-weight: bold;
                        }
                    </style>
                    <p class="first-letter-example">De eerste letter van deze paragraaf is groot en gekleurd.</p>
                </div>

                <h5><code>::first-line</code></h5>
                <p>Selecteert de eerste opgemaakte regel van een block-level element. De lengte van deze regel hangt af
                    van de breedte van het element, de lettergrootte, etc.</p>
                <pre><code>p::first-line {
  font-variant: small-caps;
  font-weight: 600;
}</code></pre>
                <div class="live-example">
                    <style>
                        .first-line-example::first-line {
                            font-weight: bold;
                        }
                    </style>
                    <p class="first-line-example">De eerste regel van deze tekst is vet. Als je het venster smaller of
                        breder maakt, zie je dat de stijl zich aanpast aan wat de eerste regel is.</p>
                </div>

                <h5><code>::marker</code></h5>
                <p>Stijlt de marker (de bullet of het nummer) van een lijstitem (<code>&lt;li&gt;</code>). Dit geeft je
                    eindelijk controle over de kleur, grootte en zelfs de content van de opsommingstekens.</p>
                <pre><code>ul li::marker {
  color: var(--accent-color);
  font-size: 1.2em;
}

/* Je kunt zelfs de bullet vervangen */
ol li::marker {
  content: '✔ ';
  color: #22c55e;
}</code></pre>
                <div class="live-example">
                    <style>
                        .marker-example li::marker {
                            content: '✅ ';
                        }
                    </style>
                    <ul class="marker-example">
                        <li>Item met custom marker</li>
                        <li>Nog een item</li>
                    </ul>
                </div>

                <h5><code>::selection</code></h5>
                <p>Stijlt het gedeelte van de tekst dat door de gebruiker is geselecteerd (gemarkeerd met de muis of het
                    toetsenbord). Je kunt voornamelijk de kleur en achtergrondkleur aanpassen.</p>
                <pre><code>::selection {
  background-color: var(--accent-color);
  color: white;
}</code></pre>
                <div class="live-example">
                    <style>
                        .selection-example::selection {
                            background-color: #fde047;
                            color: #1e293b;
                        }
                    </style>
                    <p class="selection-example">Selecteer deze tekst om de aangepaste selectiekleur te zien.</p>
                </div>

                <h5><code>::placeholder</code></h5>
                <p>Hiermee kun je de placeholder-tekst in een <code>&lt;input&gt;</code> of
                    <code>&lt;textarea&gt;</code> stijlen.
                </p>
                <pre><code>input::placeholder {
  color: #9ca3af;
  font-style: italic;
  opacity: 1; /* Firefox heeft dit nodig */
}</code></pre>
                <div class="live-example">
                    <style>
                        .placeholder-example::placeholder {
                            color: #fb7185;
                            font-style: italic;
                        }
                    </style>
                    <input type="text" class="placeholder-example" placeholder="Dit is een gestijlde placeholder">
                </div>

                <h5><code>::backdrop</code></h5>
                <p>Wanneer een element in fullscreen-modus wordt gezet (zoals een <code>&lt;video&gt;</code>) of wanneer
                    een <code>&lt;dialog&gt;</code> modaal wordt geopend, wordt er een <code>::backdrop</code>-laag
                    getoond achter het element en boven de rest van de pagina. Met dit pseudo-element kun je die laag
                    stijlen.</p>
                <pre><code>/* Geef de achtergrond van een modaal dialoogvenster een donkere, semi-transparante kleur */
dialog::backdrop {
  background-color: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(3px);
}</code></pre>
                <div class="live-example">
                    <style>
                        #backdrop-dialog::backdrop {
                            background-color: rgba(13, 98, 255, 0.2);
                            backdrop-filter: blur(2px);
                        }
                    </style>
                    <button onclick="document.getElementById('backdrop-dialog').showModal()">Toon Dialoog</button>
                    <dialog id="backdrop-dialog">
                        <p>De achtergrond (backdrop) van dit dialoogvenster is gestijld.</p>
                        <button onclick="document.getElementById('backdrop-dialog').close()">Sluiten</button>
                    </dialog>
                </div>
            </section>

            <section id="css-box-model">
                <h3>Box Model & Sizing</h3>
                <p>Elk HTML-element kan worden gezien als een doos. Het CSS box model beschrijft hoe deze doos is
                    opgebouwd.</p>
                <ul>
                    <li><code>content</code>: De daadwerkelijke inhoud (tekst, afbeelding).</li>
                    <li><code>padding</code>: De binnenmarge, ruimte tussen de content en de border.</li>
                    <li><code>border</code>: De rand rond de padding en content.</li>
                    <li><code>margin</code>: De buitenmarge, ruimte rondom het element.</li>
                </ul>

                <h4><code>box-sizing</code></h4>
                <p>Deze eigenschap bepaalt hoe de totale breedte en hoogte van een element wordt berekend.</p>
                <ul>
                    <li><code>content-box</code> (default): `width` en `height` zijn alleen van toepassing op de
                        content. Padding en border komen erbij.</li>
                    <li><code>border-box</code>: `width` en `height` omvatten de content, padding én border. Dit is vaak
                        intuïtiever om mee te werken.</li>
                </ul>
                <pre><code>*, *::before, *::after {
    box-sizing: border-box;
}</code></pre>
                <div class="exercise">
                    <h4>Oefening C1-01: Box Model</h4>
                    <p>Maak een `div` met de class `box`. Geef het een breedte van 200px, een border van 5px solid
                        black, en 20px padding. Zorg ervoor dat de totale breedte van de `div` (inclusief border en
                        padding) exact 200px is.</p>
                    <textarea id="ex-c1-01" placeholder="Plaats hier je CSS-regel..."></textarea>
                    <button class="check-btn" data-exercise="c1-01">Controleer</button>
                    <button class="solution-btn secondary">Toon Oplossing</button>
                    <div class="validator-result"></div>
                    <div class="exercise-solution">
                        <pre><code>.box {
    box-sizing: border-box;
    width: 200px;
    border: 5px solid black;
    padding: 20px;
}</code></pre>
                    </div>
                </div>
            </section>

            <section id="css-layout">
                <h3>Layout (Flexbox & Grid)</h3>

                <h4>Flexbox</h4>
                <p>Een eendimensionaal layoutsysteem, ideaal voor het uitlijnen van items in een rij of kolom.</p>
                <ul>
                    <li><strong>Container eigenschappen</strong>:
                        <ul>
                            <li><code>display: flex;</code>: Activeert flexbox.</li>
                            <li><code>flex-direction: row | column;</code>: Bepaalt de hoofdas.</li>
                            <li><code>justify-content</code>: Uitlijning op de hoofdas (bv. <code>center</code>,
                                <code>space-between</code>).
                            </li>
                            <li><code>align-items</code>: Uitlijning op de kruisas (bv. <code>center</code>,
                                <code>stretch</code>).
                            </li>
                            <li><code>gap</code>: Ruimte tussen de flex-items.</li>
                        </ul>
                    </li>
                    <li><strong>Item eigenschappen</strong>:
                        <ul>
                            <li><code>flex-grow</code>, <code>flex-shrink</code>, <code>flex-basis</code>: Bepalen hoe
                                items groeien, krimpen en hun basisgrootte hebben. Vaak gebruikt via de `flex`
                                shorthand.</li>
                        </ul>
                    </li>
                </ul>

                <h4>Grid</h4>
                <p>Een tweedimensionaal layoutsysteem, perfect voor complexe layouts met zowel rijen als kolommen.</p>
                <ul>
                    <li><strong>Container eigenschappen</strong>:
                        <ul>
                            <li><code>display: grid;</code>: Activeert grid.</li>
                            <li><code>grid-template-columns</code> & <code>grid-template-rows</code>: Definieert de
                                kolommen en rijen (bv. <code>1fr 1fr 2fr</code>, <code>repeat(3, 1fr)</code>).</li>
                            <li><code>gap</code>: Ruimte tussen de grid-cellen.</li>
                        </ul>
                    </li>
                    <li><strong>Item eigenschappen</strong>:
                        <ul>
                            <li><code>grid-column</code> & <code>grid-row</code>: Bepaalt over welke gridlijnen een item
                                zich uitstrekt.</li>
                        </ul>
                    </li>
                </ul>
                <div class="exercise">
                    <h4>Oefening C3-01: Responsive Grid</h4>
                    <p>Maak een container met de class `card-container` die `display: grid` gebruikt. Zorg ervoor dat de
                        kolommen zich automatisch aanpassen: ze moeten minimaal 250px breed zijn en de beschikbare
                        ruimte opvullen. Gebruik `repeat`, `auto-fit`, en `minmax`.</p>
                    <textarea id="ex-c3-01" placeholder="Plaats hier je CSS-regel..."></textarea>
                    <button class="check-btn" data-exercise="c3-01">Controleer</button>
                    <button class="solution-btn secondary">Toon Oplossing</button>
                    <div class="validator-result"></div>
                    <div class="exercise-solution">
                        <pre><code>.card-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1rem;
}</code></pre>
                    </div>
                </div>

                <hr>

                <h4>Uitgebreide gids voor CSS Layout: Flexbox &amp; Grid</h4>

                <h5>Introductie</h5>
                <p>Cascading Style Sheets (CSS) bieden verschillende technieken om de lay-out van webpagina’s te
                    bepalen. Twee moderne en krachtige methoden hiervoor zijn <strong>Flexbox</strong> (Flexible Box
                    Layout) en <strong>CSS Grid</strong> (Grid Layout). Flexbox is een één-dimensionaal lay-outmodel dat
                    speciaal ontworpen is om elementen efficiënter te ordenen binnen een rij of kolom (verwijzing:
                    dev.to). Flexbox werkt in één richting tegelijk (horizontaal of verticaal), wat het positioneren en
                    uitlijnen van elementen in een container sterk vereenvoudigt.</p>
                <p>CSS Grid daarentegen is twee-dimensionaal en maakt het mogelijk om elementen in zowel rijen als
                    kolommen te plaatsen, waardoor complexere lay-outs kunnen worden opgebouwd (verwijzing:
                    developer.mozilla.org). In tegenstelling tot Flexbox, dat zich op een enkele as richt, beheert Grid
                    rijen en kolommen tegelijkertijd.</p>
                <p>In deze gids bespreken we alle eigenschappen (properties) van zowel Flexbox als Grid. We leggen kort
                    uit wat elke eigenschap doet, hoe je deze kunt gebruiken en waarvoor ze bedoeld zijn. We geven
                    codevoorbeelden bij elke eigenschap, zodat je als beginnende CSS-ontwikkelaar kunt zien hoe ze in de
                    praktijk werken. Geen enkel detail wordt overgeslagen – na het doornemen van dit document heb je een
                    compleet overzicht van CSS Flexbox &amp; Grid lay-outs, inclusief tips voor het gebruik ervan.</p>

                <h5>CSS Flexbox Layout</h5>
                <p>Flexbox (de Flexibele Box Layout Module) is ideaal voor het maken van responsieve ontwerpen in één
                    dimensie. Je definieert een flex-container die de flex-items (directe kinderen) bevat. Met Flexbox
                    kun je de beschikbare ruimte verdelen en de positie van de items op de hoofdas en de kruis-as
                    regelen.</p>

                <h6>Flexbox: Hoofdas en kruis-as begrijpen</h6>
                <p>Flexbox gebruikt een concept van twee assen om layout te sturen: de hoofdas (main axis) en de
                    kruis-as (cross axis). De hoofdas is de primaire as waarin flex-items geplaatst worden, en wordt
                    bepaald door de eigenschap <code>flex-direction</code> (developer.mozilla.org). Standaard is dit
                    horizontaal (van links naar rechts, bij <code>flex-direction: row</code>), maar het kan ook
                    verticaal zijn (bij <code>flex-direction: column</code>). De kruis-as staat altijd loodrecht op de
                    hoofdas (developer.mozilla.org).</p>
                <ul>
                    <li>Als de hoofdas horizontaal is (rij-richting), loopt de kruis-as verticaal.</li>
                    <li>Als de hoofdas verticaal is (kolom-richting), loopt de kruis-as horizontaal.</li>
                </ul>
                <p>Dit assenstelsel is belangrijk om te begrijpen hoe eigenschappen als <code>justify-content</code>
                    (uitlijning langs de hoofdas) en <code>align-items</code> (uitlijning langs de kruis-as) werken. In
                    plaats van absolute termen als “links/rechts” of “boven/onder” te gebruiken, spreken we over start
                    en eind van de assen, zodat het ook werkt in verschillende schrijfwijzen (bijvoorbeeld voor
                    RTL-talen) (developer.mozilla.org).</p>

                <h5>Eigenschappen van de flex-container</h5>
                <p>Een flex-container is een element met <code>display: flex</code> of
                    <code>display: inline-flex</code>. De container-eigenschappen bepalen hoe de flex-items erin zich
                    gedragen en hoe ze worden uitgelijnd. Hieronder behandelen we alle relevante eigenschappen voor de
                    flex-container.
                </p>

                <h6>display: flex / display: inline-flex</h6>
                <p>Om Flexbox te gebruiken, moet je eerst een container element definiëren als flex-container. Dit doe
                    je door de <code>display</code> property op <code>flex</code> te zetten (blok-level) of op
                    <code>inline-flex</code> (inline-level). Hiermee creëer je een nieuwe flex context: alle directe
                    kinderen van dit element worden dan flex-items (dev.to).
                </p>
                <pre><code>.container { display: flex; }
.inline-container { display: inline-flex; }</code></pre>
                <div class="live-demo">
                    <div style="margin-bottom:8px; font-weight:600;">display: flex</div>
                    <div style="display:flex; gap:8px; border:1px solid #ddd; padding:8px;">
                        <div style="background:#eef; padding:6px 10px;">Item 1</div>
                        <div style="background:#eef; padding:6px 10px;">Item 2</div>
                        <div style="background:#eef; padding:6px 10px;">Item 3</div>
                    </div>
                    <div style="margin:12px 0 8px; font-weight:600;">display: inline-flex</div>
                    <span style="display:inline-flex; gap:8px; border:1px solid #ddd; padding:8px;">
                        <span style="background:#efe; padding:6px 10px;">A</span>
                        <span style="background:#efe; padding:6px 10px;">B</span>
                        <span style="background:#efe; padding:6px 10px;">C</span>
                    </span>
                </div>

                <h6>flex-direction</h6>
                <p>De eigenschap <code>flex-direction</code> bepaalt de richting van de hoofdas en daarmee de ordening
                    van flex-items in de container. Mogelijke waarden zijn: <code>row</code>, <code>row-reverse</code>,
                    <code>column</code>, <code>column-reverse</code> (w3schools.com).
                </p>
                <pre><code>.row { display:flex; flex-direction: row; }
.column { display:flex; flex-direction: column; }</code></pre>
                <div class="live-demo">
                    <div style="display:flex; gap:8px; border:1px solid #ddd; padding:8px; margin-bottom:10px;">
                        <div style="background:#f6e; padding:6px 10px;">Row 1</div>
                        <div style="background:#f6e; padding:6px 10px;">Row 2</div>
                        <div style="background:#f6e; padding:6px 10px;">Row 3</div>
                    </div>
                    <div style="display:flex; flex-direction:column; gap:8px; border:1px solid #ddd; padding:8px;">
                        <div style="background:#ffe; padding:6px 10px;">Col 1</div>
                        <div style="background:#ffe; padding:6px 10px;">Col 2</div>
                        <div style="background:#ffe; padding:6px 10px;">Col 3</div>
                    </div>
                </div>

                <h6>flex-wrap</h6>
                <p>Standaard probeert een flex-container alle items op één regel te plaatsen. De eigenschap
                    <code>flex-wrap</code> bepaalt of de flex-items op een nieuwe regel teruglopen als er onvoldoende
                    ruimte is. Waarden: <code>nowrap</code> (default), <code>wrap</code>, <code>wrap-reverse</code>
                    (w3schools.com).
                </p>
                <pre><code>.wrap { display:flex; flex-wrap: wrap; gap:8px; }</code></pre>
                <div class="live-demo">
                    <div
                        style="display:flex; flex-wrap:wrap; gap:8px; border:1px solid #ddd; padding:8px; max-width:260px;">
                        <div style="background:#def; padding:6px 10px;">1</div>
                        <div style="background:#def; padding:6px 10px;">2</div>
                        <div style="background:#def; padding:6px 10px;">3</div>
                        <div style="background:#def; padding:6px 10px;">4</div>
                        <div style="background:#def; padding:6px 10px;">5</div>
                    </div>
                </div>

                <h6>flex-flow (shorthand)</h6>
                <p><code>flex-flow</code> is een shorthand voor <code>flex-direction</code> en <code>flex-wrap</code>
                    (w3schools.com).</p>
                <pre><code>.flow { display:flex; flex-flow: row wrap; gap:8px; }</code></pre>
                <div class="live-demo">
                    <div
                        style="display:flex; flex-flow:row wrap; gap:8px; border:1px solid #ddd; padding:8px; max-width:260px;">
                        <div style="background:#fed; padding:6px 10px;">A</div>
                        <div style="background:#fed; padding:6px 10px;">B</div>
                        <div style="background:#fed; padding:6px 10px;">C</div>
                        <div style="background:#fed; padding:6px 10px;">D</div>
                    </div>
                </div>

                <h6>justify-content</h6>
                <p><code>justify-content</code> bepaalt hoe overgebleven ruimte langs de hoofdas wordt verdeeld:
                    <code>flex-start</code>, <code>flex-end</code>, <code>center</code>, <code>space-between</code>,
                    <code>space-around</code>, <code>space-evenly</code> (w3schools.com).
                </p>
                <pre><code>.jc-center { display:flex; justify-content:center; gap:8px; }
.jc-between { display:flex; justify-content:space-between; }</code></pre>
                <div class="live-demo" style="display:grid; gap:10px;">
                    <div style="display:flex; justify-content:flex-start; gap:8px; border:1px solid #ddd; padding:8px;">
                        <div style="background:#eaf; padding:6px 10px;">1</div>
                        <div style="background:#eaf; padding:6px 10px;">2</div>
                        <div style="background:#eaf; padding:6px 10px;">3</div>
                    </div>
                    <div style="display:flex; justify-content:center; gap:8px; border:1px solid #ddd; padding:8px;">
                        <div style="background:#eaf; padding:6px 10px;">1</div>
                        <div style="background:#eaf; padding:6px 10px;">2</div>
                        <div style="background:#eaf; padding:6px 10px;">3</div>
                    </div>
                    <div style="display:flex; justify-content:space-between; border:1px solid #ddd; padding:8px;">
                        <div style="background:#eaf; padding:6px 10px;">1</div>
                        <div style="background:#eaf; padding:6px 10px;">2</div>
                        <div style="background:#eaf; padding:6px 10px;">3</div>
                    </div>
                </div>

                <h6>align-items</h6>
                <p><code>align-items</code> richt de items uit op de kruis-as: <code>stretch</code> (default),
                    <code>flex-start</code>, <code>flex-end</code>, <code>center</code>, <code>baseline</code>
                    (w3schools.com).
                </p>
                <pre><code>.ai-end { display:flex; align-items:flex-end; height:120px; gap:8px; }</code></pre>
                <div class="live-demo">
                    <div
                        style="display:flex; align-items:flex-end; gap:8px; height:120px; border:1px solid #ddd; padding:8px;">
                        <div style="background:#dff; padding:6px 10px;">A</div>
                        <div style="background:#dff; padding:20px 10px; font-size:24px;">B</div>
                        <div style="background:#dff; padding:10px;">C</div>
                    </div>
                </div>

                <h6>align-content</h6>
                <p><code>align-content</code> verdeelt ruimte tussen meerdere flex-regels langs de kruis-as. Werkt
                    alleen bij wrapping en vrije ruimte. Waarden: <code>flex-start</code>, <code>flex-end</code>,
                    <code>center</code>, <code>space-between</code>, <code>space-around</code>,
                    <code>space-evenly</code>, <code>stretch</code> (w3schools.com).
                </p>
                <pre><code>.ac-around { display:flex; flex-wrap:wrap; align-content:space-around; height:180px; gap:8px; }</code></pre>
                <div class="live-demo">
                    <div
                        style="display:flex; flex-wrap:wrap; align-content:space-around; height:180px; gap:8px; border:1px solid #ddd; padding:8px; max-width:340px;">
                        <div style="background:#ffd; padding:6px 10px;">1</div>
                        <div style="background:#ffd; padding:6px 10px;">2</div>
                        <div style="background:#ffd; padding:6px 10px;">3</div>
                        <div style="background:#ffd; padding:6px 10px;">4</div>
                        <div style="background:#ffd; padding:6px 10px;">5</div>
                        <div style="background:#ffd; padding:6px 10px;">6</div>
                    </div>
                </div>

                <h6>gap, row-gap &amp; column-gap</h6>
                <p><code>gap</code> bepaalt de ruimte tussen flex-items; met twee waarden: eerst rijafstand, dan
                    kolomafstand. <code>row-gap</code> en <code>column-gap</code> zijn specifiek per as (dev.to).</p>
                <pre><code>.gap-10 { display:flex; flex-wrap:wrap; gap:10px; }
.gap-mixed { display:flex; flex-wrap:wrap; row-gap:5px; column-gap:20px; }</code></pre>
                <div class="live-demo" style="display:grid; gap:10px;">
                    <div
                        style="display:flex; flex-wrap:wrap; gap:10px; border:1px solid #ddd; padding:8px; max-width:280px;">
                        <div style="background:#f0f0f0; padding:6px 10px;">A</div>
                        <div style="background:#f0f0f0; padding:6px 10px;">B</div>
                        <div style="background:#f0f0f0; padding:6px 10px;">C</div>
                        <div style="background:#f0f0f0; padding:6px 10px;">D</div>
                    </div>
                    <div
                        style="display:flex; flex-wrap:wrap; row-gap:5px; column-gap:20px; border:1px solid #ddd; padding:8px; max-width:280px;">
                        <div style="background:#f0f0f0; padding:6px 10px;">A</div>
                        <div style="background:#f0f0f0; padding:6px 10px;">B</div>
                        <div style="background:#f0f0f0; padding:6px 10px;">C</div>
                        <div style="background:#f0f0f0; padding:6px 10px;">D</div>
                    </div>
                </div>

                <h6>place-content</h6>
                <p><code>place-content</code> is een shorthand voor <code>align-content</code> en
                    <code>justify-content</code>. Met twee waarden: eerst voor <code>align-content</code>, dan
                    <code>justify-content</code>; één waarde geldt voor beide (w3schools.com).
                </p>
                <pre><code>.pc-start-center { display:flex; flex-wrap:wrap; place-content:start center; height:180px; }</code></pre>
                <div class="live-demo">
                    <div
                        style="display:flex; flex-wrap:wrap; place-content:start center; height:160px; gap:8px; border:1px solid #ddd; padding:8px; max-width:340px;">
                        <div style="background:#e0f7ff; padding:6px 10px;">1</div>
                        <div style="background:#e0f7ff; padding:6px 10px;">2</div>
                        <div style="background:#e0f7ff; padding:6px 10px;">3</div>
                        <div style="background:#e0f7ff; padding:6px 10px;">4</div>
                    </div>
                </div>

                <h5>Eigenschappen van flex-items</h5>
                <p>Flex-items zijn de directe kinderen van een flex-container. Naast container-eigenschappen hebben
                    items ook eigenschappen om hun gedrag en positionering te beïnvloeden.</p>

                <h6>order</h6>
                <p>De eigenschap <code>order</code> wijzigt de visuele volgorde van een flex-item. Standaard is
                    <code>order: 0</code>. Lagere waarden komen eerder (w3schools.com).
                </p>
                <pre><code>.item-a { order: 1; }
.item-b { order: 2; }
.item-c { order: -1; }</code></pre>
                <div class="live-demo">
                    <div style="display:flex; gap:8px; border:1px solid #ddd; padding:8px;">
                        <div style="background:#f9e; padding:6px 10px; order:1;">A (1)</div>
                        <div style="background:#f9e; padding:6px 10px; order:2;">B (2)</div>
                        <div style="background:#f9e; padding:6px 10px; order:-1;">C (-1)</div>
                    </div>
                </div>

                <h6>flex-grow</h6>
                <p><code>flex-grow</code> bepaalt hoeveel een item groeit wanneer er vrije ruimte is. Waarde 0 groeit
                    niet (default); hogere waarden verdelen de ruimte in verhouding (w3schools.com, dev.to).</p>
                <pre><code>.g1 { flex-grow:1; }
.g2 { flex-grow:2; }
.g0 { flex-grow:0; }</code></pre>
                <div class="live-demo">
                    <div style="display:flex; gap:8px; border:1px solid #ddd; padding:8px;">
                        <div style="background:#dfe; padding:6px 10px; flex-grow:1;">1</div>
                        <div style="background:#dfe; padding:6px 10px; flex-grow:2;">2</div>
                        <div style="background:#dfe; padding:6px 10px; flex-grow:0; white-space:nowrap;">0</div>
                    </div>
                </div>

                <h6>flex-shrink</h6>
                <p><code>flex-shrink</code> bepaalt hoe items krimpen wanneer er te weinig ruimte is. Standaard
                    <code>1</code>; <code>0</code> betekent niet krimpen (w3schools.com).
                </p>
                <pre><code>.s0 { flex-shrink:0; }
.s2 { flex-shrink:2; }</code></pre>
                <div class="live-demo">
                    <div style="display:flex; gap:8px; border:1px solid #ddd; padding:8px; max-width:260px;">
                        <div style="background:#ffd; padding:6px 10px; flex:0 0 140px;">Basis 140px</div>
                        <div style="background:#ffd; padding:6px 10px; flex:1 2 140px;">Shrink 2</div>
                        <div style="background:#ffd; padding:6px 10px; flex:0 0 140px; flex-shrink:0;">Geen shrink</div>
                    </div>
                </div>

                <h6>flex-basis</h6>
                <p><code>flex-basis</code> specificeert de initiële hoofdas-grootte van een item voordat groei/krimp
                    wordt toegepast (w3schools.com).</p>
                <pre><code>.b200 { flex-basis:200px; }
.b50p { flex-basis:50%; }
.bauto { flex-basis:auto; }</code></pre>
                <div class="live-demo">
                    <div style="display:flex; gap:8px; border:1px solid #ddd; padding:8px;">
                        <div style="background:#eef; padding:6px 10px; flex:0 1 200px;">200px basis</div>
                        <div style="background:#eef; padding:6px 10px; flex:1 1 0;">Gelijke verdeling (basis 0)</div>
                    </div>
                </div>

                <h6>flex (shorthand)</h6>
                <p><code>flex</code> combineert <code>flex-grow</code>, <code>flex-shrink</code> en
                    <code>flex-basis</code>. Voorbeelden: <code>flex: 1 1 auto</code>, <code>flex: 0 0 200px</code>,
                    <code>flex: none</code>, <code>flex: auto</code> (w3schools.com).
                </p>
                <pre><code>.flex1 { flex:1; }
.fixed200 { flex:0 0 200px; }</code></pre>
                <div class="live-demo">
                    <div style="display:flex; gap:8px; border:1px solid #ddd; padding:8px;">
                        <div style="background:#efe; padding:6px 10px; flex:1 1 0;">flex:1</div>
                        <div style="background:#efe; padding:6px 10px; flex:0 0 200px;">vast 200px</div>
                        <div style="background:#efe; padding:6px 10px; flex:1 1 0;">flex:1</div>
                    </div>
                </div>

                <h6>align-self</h6>
                <p><code>align-self</code> wijkt af van <code>align-items</code> voor een specifiek item. Waarden:
                    <code>auto</code>, <code>flex-start</code>, <code>flex-end</code>, <code>center</code>,
                    <code>baseline</code>, <code>stretch</code> (w3schools.com).
                </p>
                <pre><code>.special { align-self:flex-end; }</code></pre>
                <div class="live-demo">
                    <div
                        style="display:flex; align-items:center; gap:8px; height:120px; border:1px solid #ddd; padding:8px;">
                        <div style="background:#e9f; padding:6px 10px;">A</div>
                        <div style="background:#e9f; padding:6px 10px; align-self:flex-end;">B (self end)</div>
                        <div style="background:#e9f; padding:6px 10px;">C</div>
                    </div>
                </div>

                <h5>CSS Grid Layout</h5>
                <p>CSS Grid is een layout-systeem dat een rooster van rijen en kolommen creëert. Waar Flexbox
                    één-dimensionaal is, positioneert Grid elementen in twee dimensies en is ideaal voor complexere
                    layouts (freecodecamp.org).</p>

                <h6>display: grid / display: inline-grid</h6>
                <p>Activeer de grid layout via <code>display: grid</code> (block-level) of
                    <code>display: inline-grid</code> (inline-level).
                </p>
                <pre><code>.grid { display:grid; }
.inline-grid { display:inline-grid; }</code></pre>
                <div class="live-demo">
                    <div
                        style="display:grid; grid-template-columns:repeat(3, 1fr); gap:8px; border:1px solid #ddd; padding:8px; margin-bottom:10px;">
                        <div style="background:#eef; padding:6px 10px;">1</div>
                        <div style="background:#eef; padding:6px 10px;">2</div>
                        <div style="background:#eef; padding:6px 10px;">3</div>
                    </div>
                    <span
                        style="display:inline-grid; grid-template-columns:auto auto; gap:6px; border:1px solid #ddd; padding:6px;">
                        <span style="background:#efe; padding:4px 8px;">A</span>
                        <span style="background:#efe; padding:4px 8px;">B</span>
                        <span style="background:#efe; padding:4px 8px;">C</span>
                        <span style="background:#efe; padding:4px 8px;">D</span>
                    </span>
                </div>

                <h6>grid-template-columns en grid-template-rows</h6>
                <p>Definieer kolommen en rijen met lengtes, percentages, <code>fr</code>, <code>auto</code> en
                    combinaties. Functies zoals <code>repeat()</code> en <code>minmax()</code> helpen bij
                    responsiviteit.</p>
                <pre><code>.gtc {
  display:grid;
  grid-template-columns: 100px 1fr 2fr;
  grid-template-rows: 80px 200px;
  gap:8px;
}</code></pre>
                <div class="live-demo">
                    <div
                        style="display:grid; grid-template-columns:100px 1fr 2fr; grid-template-rows:80px 120px; gap:8px; border:1px solid #ddd; padding:8px;">
                        <div style="background:#ffd; padding:6px 10px;">100px</div>
                        <div style="background:#ffd; padding:6px 10px;">1fr</div>
                        <div style="background:#ffd; padding:6px 10px;">2fr</div>
                        <div style="background:#ffd; padding:6px 10px;">r2c1</div>
                        <div style="background:#ffd; padding:6px 10px;">r2c2</div>
                        <div style="background:#ffd; padding:6px 10px;">r2c3</div>
                    </div>
                </div>

                <h6>grid-template-areas</h6>
                <p>Definieer benoemde gebieden om items eenvoudig te positioneren.</p>
                <pre><code>.areas {
  display:grid;
  grid-template-columns: 1fr 3fr;
  grid-template-rows: auto auto;
  grid-template-areas:
    "sidebar main"
    "sidebar main";
  gap:8px;
}
.sidebar { grid-area: sidebar; }
.main { grid-area: main; }</code></pre>
                <div class="live-demo">
                    <div
                        style="display:grid; grid-template-columns:1fr 3fr; grid-template-rows:auto auto; grid-template-areas:'sidebar main' 'sidebar main'; gap:8px; border:1px solid #ddd; padding:8px;">
                        <div style="grid-area:sidebar; background:#eef; padding:6px 10px;">Sidebar</div>
                        <div style="grid-area:main; background:#efe; padding:6px 10px;">Main</div>
                    </div>
                </div>

                <h6>grid-template (shorthand)</h6>
                <p>Combineer rijen, kolommen en eventueel areas in één declaratie.</p>
                <pre><code>.tmpl {
  display:grid;
  grid-template:
    "header header" 50px
    "sidebar main"  1fr
    / 120px auto;
}</code></pre>
                <div class="live-demo">
                    <div
                        style="display:grid; grid-template:'header header' 50px 'sidebar main' 1fr / 120px auto; gap:8px; border:1px solid #ddd; padding:8px;">
                        <div style="grid-area:header; background:#eaf; padding:6px 10px;">Header</div>
                        <div style="grid-area:sidebar; background:#ffe; padding:6px 10px;">Sidebar</div>
                        <div style="grid-area:main; background:#def; padding:6px 10px;">Main</div>
                    </div>
                </div>

                <h6>gap, row-gap &amp; column-gap (Grid)</h6>
                <p>Net als bij Flexbox bepaal je met <code>gap</code> de gutters tussen cellen; met twee waarden: eerst
                    rijen, dan kolommen.</p>
                <pre><code>.grid-gap { display:grid; grid-template-columns:repeat(3,1fr); grid-template-rows:repeat(2,100px); gap:10px 20px; }</code></pre>
                <div class="live-demo">
                    <div
                        style="display:grid; grid-template-columns:repeat(3,1fr); grid-template-rows:repeat(2,80px); gap:10px 20px; border:1px solid #ddd; padding:8px;">
                        <div style="background:#f0f0f0;"></div>
                        <div style="background:#f0f0f0;"></div>
                        <div style="background:#f0f0f0;"></div>
                        <div style="background:#f0f0f0;"></div>
                        <div style="background:#f0f0f0;"></div>
                        <div style="background:#f0f0f0;"></div>
                    </div>
                </div>

                <h6>justify-items en align-items</h6>
                <p>Uitlijning van de inhoud binnen elke grid-cel. Waarden o.a. <code>stretch</code> (default),
                    <code>start</code>, <code>end</code>, <code>center</code>.
                </p>
                <pre><code>.ji-ai { display:grid; grid-template-columns:100px 100px; grid-template-rows:100px 100px; justify-items:center; align-items:start; }</code></pre>
                <div class="live-demo">
                    <div
                        style="display:grid; grid-template-columns:100px 100px; grid-template-rows:100px 100px; justify-items:center; align-items:start; gap:8px; border:1px solid #ddd; padding:8px;">
                        <div style="background:#eef; padding:6px 10px;">1</div>
                        <div style="background:#eef; padding:6px 10px;">2</div>
                        <div style="background:#eef; padding:6px 10px;">3</div>
                        <div style="background:#eef; padding:6px 10px;">4</div>
                    </div>
                </div>

                <h6>justify-content en align-content (Grid)</h6>
                <p>Positioneer het gehele grid binnen de container wanneer er vrije ruimte is. Waarden o.a.
                    <code>start</code>, <code>end</code>, <code>center</code>, <code>stretch</code>,
                    <code>space-between</code>, <code>space-around</code>, <code>space-evenly</code>.
                </p>
                <pre><code>.gc { display:grid; width:800px; grid-template-columns:200px 200px; justify-content:center; }
.gr { display:grid; height:220px; grid-template-rows:80px 80px; align-content:end; }</code></pre>
                <div class="live-demo" style="display:grid; gap:12px;">
                    <div
                        style="display:grid; width:100%; grid-template-columns:200px 200px; justify-content:center; gap:8px; border:1px solid #ddd; padding:8px;">
                        <div style="background:#dff; padding:6px 10px;">A</div>
                        <div style="background:#dff; padding:6px 10px;">B</div>
                    </div>
                    <div
                        style="display:grid; height:220px; grid-template-rows:80px 80px; align-content:end; gap:8px; border:1px solid #ddd; padding:8px;">
                        <div style="background:#ffd;">Rij 1</div>
                        <div style="background:#ffd;">Rij 2</div>
                    </div>
                </div>

                <h6>grid-auto-rows en grid-auto-columns</h6>
                <p>Grootte van impliciete rijen/kolommen wanneer content buiten de expliciete grid valt. Bijvoorbeeld:
                    <code>grid-auto-rows: 100px;</code>.
                </p>
                <pre><code>.auto-rows { display:grid; grid-template-columns:200px 200px; grid-template-rows:200px; grid-auto-rows:100px; gap:8px; }</code></pre>
                <div class="live-demo">
                    <div
                        style="display:grid; grid-template-columns:200px 200px; grid-template-rows:80px; grid-auto-rows:60px; gap:8px; border:1px solid #ddd; padding:8px;">
                        <div style="background:#eef;">1</div>
                        <div style="background:#eef;">2</div>
                        <div style="background:#eef;">3 (impliciet)</div>
                        <div style="background:#eef;">4 (impliciet)</div>
                    </div>
                </div>

                <h6>grid-auto-flow</h6>
                <p>Bepaalt automatische plaatsing: <code>row</code> (default), <code>column</code>, en de
                    <code>dense</code>-variant om gaten op te vullen.
                </p>
                <pre><code>.auto-flow-row { display:grid; grid-template-columns:repeat(3, 1fr); grid-auto-rows:60px; grid-auto-flow:row; gap:8px; }</code></pre>
                <div class="live-demo">
                    <div
                        style="display:grid; grid-template-columns:repeat(3,1fr); grid-auto-rows:60px; grid-auto-flow:row; gap:8px; border:1px solid #ddd; padding:8px;">
                        <div style="background:#def;">1</div>
                        <div style="background:#def;">2</div>
                        <div style="background:#def;">3</div>
                        <div style="background:#def;">4</div>
                        <div style="background:#def;">5</div>
                    </div>
                </div>

                <h6>grid (shorthand)</h6>
                <p>Shorthand om in één regel expliciete grid en auto-plaatshulp te combineren. Bijvoorbeeld:
                    <code>grid: 100px / auto auto auto;</code> of <code>grid: auto-flow 50px / 1fr 1fr;</code>
                    (w3schools.com).
                </p>
                <pre><code>.grid-short { display:grid; grid: auto-flow 50px / 1fr 1fr; gap:8px; }</code></pre>
                <div class="live-demo">
                    <div
                        style="display:grid; grid:auto-flow 40px / 1fr 1fr; gap:8px; border:1px solid #ddd; padding:8px;">
                        <div style="background:#f5f5f5;">A</div>
                        <div style="background:#f5f5f5;">B</div>
                        <div style="background:#f5f5f5;">C</div>
                    </div>
                </div>

                <h5>Eigenschappen van grid-items</h5>
                <p>Grid-items kunnen op specifieke plaatsen in het raster worden neergezet en zichzelf uitlijnen binnen
                    hun cel.</p>

                <h6>grid-column-start, grid-column-end, grid-row-start, grid-row-end</h6>
                <p>Specificeer start- en eindlijnen of gebruik <code>span</code> om meerdere tracks te beslaan
                    (w3schools.com).</p>
                <pre><code>.place { grid-column-start:2; grid-column-end:5; grid-row-start:1; grid-row-end:span 2; }</code></pre>
                <div class="live-demo">
                    <div
                        style="display:grid; grid-template-columns:repeat(4, 1fr); grid-template-rows:repeat(3, 60px); gap:8px; border:1px solid #ddd; padding:8px;">
                        <div style="background:#eee;">1</div>
                        <div style="background:#eee;">2</div>
                        <div style="background:#eee;">3</div>
                        <div style="background:#eee;">4</div>
                        <div
                            style="background:#cde; grid-column:2 / 5; grid-row:1 / span 2; display:flex; align-items:center; justify-content:center;">
                            Plaatsing</div>
                        <div style="background:#eee;">5</div>
                        <div style="background:#eee;">6</div>
                        <div style="background:#eee;">7</div>
                    </div>
                </div>

                <h6>grid-column en grid-row (shorthand)</h6>
                <p>Gebruik <code>grid-column: start / end</code> en <code>grid-row: start / end</code> voor compacte
                    positionering.</p>
                <pre><code>.span2 { grid-column: 2 / span 2; grid-row: 2 / 3; }</code></pre>
                <div class="live-demo">
                    <div
                        style="display:grid; grid-template-columns:repeat(4, 1fr); grid-template-rows:repeat(3, 60px); gap:8px; border:1px solid #ddd; padding:8px;">
                        <div style="background:#eee;">1</div>
                        <div style="background:#eee;">2</div>
                        <div style="background:#eee;">3</div>
                        <div style="background:#eee;">4</div>
                        <div
                            style="background:#eec; grid-column:2 / span 2; grid-row:2 / 3; display:flex; align-items:center; justify-content:center;">
                            span</div>
                        <div style="background:#eee;">5</div>
                        <div style="background:#eee;">6</div>
                        <div style="background:#eee;">7</div>
                    </div>
                </div>

                <h6>grid-area</h6>
                <p>Shorthand voor vier lijnen (<code>row-start / column-start / row-end / column-end</code>) of een naam
                    die correspondeert met <code>grid-template-areas</code> (w3schools.com).</p>
                <pre><code>.ga { grid-area: 1 / 2 / 3 / 5; }</code></pre>
                <div class="live-demo">
                    <div
                        style="display:grid; grid-template-columns:repeat(4, 1fr); grid-template-rows:repeat(3, 60px); gap:8px; border:1px solid #ddd; padding:8px;">
                        <div style="background:#eef;">1</div>
                        <div style="background:#eef;">2</div>
                        <div style="background:#eef;">3</div>
                        <div style="background:#eef;">4</div>
                        <div
                            style="background:#dfd; grid-area:1 / 2 / 3 / 5; display:flex; align-items:center; justify-content:center;">
                            area</div>
                        <div style="background:#eef;">5</div>
                        <div style="background:#eef;">6</div>
                        <div style="background:#eef;">7</div>
                    </div>
                </div>

                <h6>justify-self en align-self</h6>
                <p>Overschrijf <code>justify-items</code> en <code>align-items</code> per item. Waarden o.a.
                    <code>start</code>, <code>end</code>, <code>center</code>, <code>stretch</code> (w3schools.com).
                    <code>place-self</code> is de shorthand.
                </p>
                <pre><code>.self { justify-self:end; align-self:center; }</code></pre>
                <div class="live-demo">
                    <div
                        style="display:grid; grid-template-columns:120px 120px; grid-template-rows:80px 80px; justify-items:stretch; align-items:stretch; gap:8px; border:1px solid #ddd; padding:8px;">
                        <div style="background:#f0f0f0;">1</div>
                        <div style="background:#f0f0f0; justify-self:end; align-self:center;">2</div>
                        <div style="background:#f0f0f0;">3</div>
                        <div style="background:#f0f0f0;">4</div>
                    </div>
                </div>

                <h5>Overige overwegingen voor Grid</h5>
                <p><strong>Overlapping en stapelen</strong>: items kunnen overlappen; de DOM-volgorde bepaalt de
                    stapelvolgorde, te beïnvloeden met <code>z-index</code> (developer.mozilla.org).</p>
                <p><strong>Subgrids (geavanceerd)</strong>: nested grids kunnen kolom- en rijdefinities van de ouder
                    overnemen met <code>subgrid</code> (ondersteuning anno 2025 in moderne browsers).</p>
                <pre><code>.parent { display:grid; grid-template-columns:1fr 2fr; gap:10px; }
.child-container { display:grid; grid-template-columns:subgrid; grid-auto-rows:subgrid; }</code></pre>
                <div class="live-demo">
                    <div
                        style="display:grid; grid-template-columns:1fr 2fr; gap:10px; border:1px solid #ddd; padding:8px;">
                        <div style="background:#eef; padding:6px 10px;">Kolom 1</div>
                        <div style="background:#efe; padding:6px 10px;">Kolom 2</div>
                    </div>
                </div>

                <h5>Conclusie</h5>
                <p>We hebben de eigenschappen van CSS Flexbox en CSS Grid besproken met voorbeelden. Flexbox is ideaal
                    voor één dimensie (rij of kolom), Grid voor twee dimensies (rijen én kolommen). Combineer ze waar
                    zinvol: bijvoorbeeld Grid voor de paginalay-out en Flexbox binnen grid-items.</p>

                <details>
                    <summary><strong>Volledige referentietekst (zoals aangeleverd)</strong></summary>
                    <article class="reference-text">
                        <h5>Uitgebreide gids voor CSS Layout: Flexbox &amp; Grid</h5>
                        <h6>Introductie</h6>
                        <p>Cascading Style Sheets (CSS) bieden verschillende technieken om de lay-out van webpagina’s te
                            bepalen. Twee moderne en krachtige methoden hiervoor zijn Flexbox (Flexible Box Layout) en
                            CSS Grid (Grid Layout). Flexbox is een één-dimensionaal lay-outmodel dat speciaal ontworpen
                            is om elementen efficiënter te ordenen binnen een rij of kolom
                            dev.to
                            . Flexbox werkt in één richting tegelijk (horizontaal of verticaal), wat het positioneren en
                            uitlijnen van elementen in een container sterk vereenvoudigt. CSS Grid daarentegen is
                            twee-dimensionaal en maakt het mogelijk om elementen in zowel rijen als kolommen te
                            plaatsen, waardoor complexere lay-outs kunnen worden opgebouwd
                            developer.mozilla.org
                            . In tegenstelling tot Flexbox, dat zich op een enkele as richt, beheert Grid rijen en
                            kolommen tegelijkertijd.</p>
                        <p>In deze gids bespreken we alle eigenschappen (properties) van zowel Flexbox als Grid. We
                            leggen kort uit wat elke eigenschap doet, hoe je deze kunt gebruiken en waarvoor ze bedoeld
                            zijn. We geven codevoorbeelden bij elke eigenschap, zodat je als beginnende CSS-ontwikkelaar
                            kunt zien hoe ze in de praktijk werken. Geen enkel detail wordt overgeslagen – na het
                            doornemen van dit document heb je een compleet overzicht van CSS Flexbox &amp; Grid
                            lay-outs, inclusief tips voor het gebruik ervan.</p>
                        <h6>CSS Flexbox Layout</h6>
                        <p>Flexbox (de Flexibele Box Layout Module) is ideaal voor het maken van responsieve ontwerpen
                            in één dimensie. Je definieert een flex-container die de flex-items (directe kinderen)
                            bevat. Met Flexbox kun je de beschikbare ruimte verdelen en de positie van de items op de
                            hoofdas en de kruis-as regelen.</p>
                        <h6>Flexbox: Hoofdas en kruis-as begrijpen</h6>
                        <p>Flexbox gebruikt een concept van twee assen om layout te sturen: de hoofdas (main axis) en de
                            kruis-as (cross axis). De hoofdas is de primaire as waarin flex-items geplaatst worden, en
                            wordt bepaald door de eigenschap flex-direction
                            developer.mozilla.org
                            . Standaard is dit horizontaal (van links naar rechts, bij flex-direction: row), maar het
                            kan ook verticaal zijn (bij flex-direction: column). De kruis-as staat altijd loodrecht op
                            de hoofdas
                            developer.mozilla.org
                            .</p>
                        <p>Als de hoofdas horizontaal is (rij-richting), loopt de kruis-as verticaal door de container.
                        </p>
                        <p>Als de hoofdas verticaal is (kolom-richting), loopt de kruis-as horizontaal.</p>
                        <p>Dit assenstelsel is belangrijk om te begrijpen hoe eigenschappen als justify-content
                            (uitlijning langs de hoofdas) en align-items (uitlijning langs de kruis-as) werken. Verder
                            spreekt Flexbox over begin- en eindpunten van deze assen. In plaats van absolute termen als
                            “links/rechts” of “boven/onder” te gebruiken, spreken we over start en eind van de assen,
                            zodat het ook werkt in verschillende schrijfwijzen (bijvoorbeeld voor RTL-talen)
                            developer.mozilla.org
                            .</p>
                        <h6>Eigenschappen van de flex-container</h6>
                        <p>Een flex-container is een element met display: flex of display: inline-flex. De
                            container-eigenschappen bepalen hoe de flex-items erin zich gedragen en hoe ze worden
                            uitgelijnd. Hieronder behandelen we alle relevante eigenschappen voor de flex-container.</p>
                        <h6>display: flex / display: inline-flex</h6>
                        <p>Om Flexbox te gebruiken, moet je eerst een container element definiëren als flex-container.
                            Dit doe je door de display property op flex te zetten (voor een blok-level flex-container)
                            of op inline-flex (voor een inline-level flex-container). Hiermee creëer je een nieuwe flex
                            context: alle directe kinderen van dit element worden dan flex-items
                            dev.to
                            .</p>
                        <pre><code>.container {
  display: flex;      /* maakt dit element een flex-container */
}
.inline-container {
  display: inline-flex; /* inline flex-container, neemt slechts zo veel ruimte als nodig */
}
</code></pre>
                        <p>In het voorbeeld hierboven wordt .container een block-level flex-container (die de volledige
                            breedte van de ouder kan pakken), terwijl .inline-container een inline flex-container is
                            (die zich gedraagt als een inline-element in de tekststroom).</p>
                        <h6>flex-direction</h6>
                        <p>De eigenschap flex-direction bepaalt de richting van de hoofdas en daarmee de ordening van
                            flex-items in de container. Mogelijke waarden zijn: row, row-reverse, column, column-reverse
                            w3schools.com
                            w3schools.com
                            .</p>
                        <p>row (standaard): Plaatst de items in een rij, van links naar rechts (of van rechts naar links
                            in RTL-taal).</p>
                        <p>row-reverse: Plaatst de items in een rij maar keert de volgorde om (start rechts, einde
                            links).</p>
                        <p>column: Plaatst de items in een kolom, van boven naar beneden.</p>
                        <p>column-reverse: Plaatst de items in een kolom maar in omgekeerde volgorde (start onderaan,
                            einde bovenaan).</p>
                        <pre><code>.container {
  display: flex;
  flex-direction: row; /* items horizontaal, van links naar rechts */
}
.container-column {
  display: flex;
  flex-direction: column; /* items verticaal, van boven naar beneden */
}
</code></pre>
                        <p>In een row-richting is de hoofdas horizontaal (kruis-as verticaal). In een column-richting is
                            de hoofdas verticaal (kruis-as horizontaal). Met de omgekeerde waarden (*-reverse) wordt de
                            visuele volgorde van de items omgedraaid binnen de container.</p>
                        <h6>flex-wrap</h6>
                        <p>Standaard probeert een flex-container alle items op één regel te plaatsen. De eigenschap
                            flex-wrap bepaalt of de flex-items al dan niet op een nieuwe regel teruglopen (wrap) als er
                            onvoldoende ruimte is in één lijn. Mogelijke waarden zijn: nowrap (geen wrapping, default),
                            wrap (wel afbreken naar nieuwe regel), en wrap-reverse (afbreken maar met omgekeerde
                            volgorde van regels)
                            w3schools.com
                            w3schools.com
                            .</p>
                        <p>nowrap (standaard): Alle items blijven in één flexregel, ook als ze over de containergrenzen
                            heen lopen.</p>
                        <p>wrap: Flex-items breken over meerdere regels, indien nodig, van boven naar beneden. De eerste
                            regel ligt bovenaan.</p>
                        <p>wrap-reverse: Flex-items breken over meerdere regels, maar de stapelvolgorde van de regels is
                            omgekeerd. De eerste regel komt onderaan, volgende regels erboven.</p>
                        <pre><code>.container {
  display: flex;
  flex-wrap: wrap; /* items zullen naar een volgende regel gaan indien nodig */
}
.container-nowrap {
  display: flex;
  flex-wrap: nowrap; /* items blijven op één regel (kan overlopen) */
}
</code></pre>
                        <p>Tip: Wanneer je flex-wrap: wrap gebruikt in combinatie met flex-direction: column of
                            column-reverse, zal het afbreken zich horizontaal manifesteren (omdat in dat geval de kolom
                            de hoofdas is en de rijen de kruis-as).</p>
                        <h6>flex-flow</h6>
                        <p>flex-flow is een shorthand eigenschap waarmee je in één regel zowel flex-direction als
                            flex-wrap kunt instellen
                            w3schools.com
                            . De syntaxis is flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;;.</p>
                        <pre><code>.container {
  display: flex;
  flex-flow: row wrap;  /* gelijk aan flex-direction: row; flex-wrap: wrap; */
}
</code></pre>
                        <p>In bovenstaand voorbeeld worden de items in een rij geplaatst die naar behoefte doorgelopen
                            kan worden naar volgende regels. Je kunt elke geldige combinatie van richting en wrapping
                            gebruiken, bijvoorbeeld column nowrap (verticale kolom, niet afbreken) of row-reverse wrap
                            (omgekeerde rij, met wrapping).</p>
                        <h6>justify-content</h6>
                        <p>De eigenschap justify-content bepaalt hoe overgebleven ruimte langs de hoofdas wordt verdeeld
                            tussen de flex-items. Met andere woorden: het regelt de horizontale uitlijning van items als
                            de hoofdas horizontaal is (of verticale uitlijning als de hoofdas verticaal is). Mogelijke
                            waarden zijn onder andere flex-start, flex-end, center, space-between, space-around en
                            space-evenly
                            w3schools.com
                            .</p>
                        <p>flex-start: Plaatst alle items aan het begin van de hoofdas (links bij een rij)
                            w3schools.com
                            .</p>
                        <p>flex-end: Plaatst alle items aan het einde van de hoofdas (rechts bij een rij).</p>
                        <p>center: Centreert de items langs de hoofdas
                            w3schools.com
                            .</p>
                        <p>space-between: Verdeelt de items zodat de eerste aan het begin en de laatste aan het einde
                            staat, met gelijke ruimte tussen elk paar items
                            dev.to
                            .</p>
                        <p>space-around: Verdeelt de items met gelijke ruimte rondom elk item. Dit betekent half zoveel
                            ruimte aan de randen als ertussen, waardoor de uiterste items half een marge hebben tot de
                            container rand
                            dev.to
                            .</p>
                        <p>space-evenly: Verdeelt de items met gelijke ruimte tussen en aan de randen – overal evenveel
                            vrije ruimte
                            w3schools.com
                            .</p>
                        <p>Visualisatie van verschillende justify-content waarden (hoofdas horizontaal): van boven naar
                            beneden zie je flex-start, flex-end, center, space-between, space-around en space-evenly.
                            Merk op hoe de positie van de items en de tussenruimtes langs de hoofdas variëren per
                            waarde.
                            w3schools.com
                        </p>
                        <p>In de code gebruikt het er bijvoorbeeld zo uit:</p>
                        <pre><code>.container {
  display: flex;
  justify-content: center;    /* items gecentreerd op de hoofdas */
}
.container-space {
  display: flex;
  justify-content: space-between; /* ruimte tussen items, eerste en laatste aan randen */
}
</code></pre>
                        <p>Nota: justify-content heeft alleen effect als er ruimte over is langs de hoofdas. Als de
                            items precies de volledige container opvullen of overlopen, zal deze eigenschap geen
                            zichtbaar verschil maken
                            w3schools.com
                            w3schools.com
                            .</p>
                        <h6>align-items</h6>
                        <p>Waar justify-content de hoofdas betreft, richt align-items zich op de kruis-as (perpendicular
                            aan de hoofdas). Deze eigenschap bepaalt hoe de items als groep uitgelijnd worden op de
                            kruis-as (meestal verticaal als de items in een rij staan). Mogelijke waarden zijn stretch,
                            flex-start, flex-end, center, baseline en normal (waarbij stretch de default is)
                            w3schools.com
                            . Enkele veelgebruikte waarden:</p>
                        <p>stretch: Standaard waarde. De items strekken zich uit om de container op de kruis-as te
                            vullen (als er ruimte is). Dit betekent bijvoorbeeld dat alle flex-items even hoog worden
                            als de container hoogte (of breedte, als kolomrichting)
                            w3schools.com
                            .</p>
                        <p>flex-start: Plaatst de items aan het begin van de kruis-as (bij een horizontale hoofdas
                            betekent dit bovenaan de container)
                            w3schools.com
                            .</p>
                        <p>flex-end: Plaatst de items aan het einde van de kruis-as (onderaan bij een horizontale rij)
                            w3schools.com
                            .</p>
                        <p>center: Centreert de items langs de kruis-as (midden in de container)
                            w3schools.com
                            .</p>
                        <p>baseline: Lijnt items uit op hun tekst-baseline. Dit is handig als flex-items tekst of
                            inline-content bevatten met verschillende groottes; hun baselines (bijvoorbeeld onderkant
                            van letters) komen op één lijn te staan
                            w3schools.com
                            w3schools.com
                            .</p>
                        <p>Illustratie van verschillende align-items instellingen (kruis-as verticaal): Hier is de
                            container 200px hoog. Van links naar rechts worden de flex-items uitgelijnd met flex-start
                            (bovenaan), center (midden), flex-end (onderaan), stretch (uitgerekt tot volledige hoogte)
                            en baseline (uitgelijnd op de tekst-baseline)
                            w3schools.com
                            w3schools.com
                            . In het laatste voorbeeld hebben de cijfers verschillende font-grootten om te tonen hoe
                            baseline-align werkt.</p>
                        <p>Met CSS:</p>
                        <pre><code>.container {
  display: flex;
  height: 200px;
  align-items: flex-end;   /* items uitgelijnd naar onderkant container */
}
.container2 {
  display: flex;
  height: 200px;
  align-items: baseline;   /* items uitgelijnd op hun tekst-baseline */
}
</code></pre>
                        <p>Nota: align-items beïnvloedt alle flex-items in de container tegelijkertijd
                            developer.mozilla.org
                            . Als je één specifiek item anders wil uitlijnen, kun je dat item individueel aanpassen met
                            de eigenschap align-self op het item (zie verder)
                            developer.mozilla.org
                            .</p>
                        <h6>align-content</h6>
                        <p>De eigenschap align-content komt in werking wanneer er meerdere flex-regels (rows) zijn,
                            dankzij wrapping. Het regelt de verdeling van ruimte tussen de flex-regels langs de kruis-as
                            (bij een multi-line flexbox)
                            w3schools.com
                            . De waarden lijken op die van justify-content, maar dan voor de verzameling regels in
                            plaats van de items binnen één regel
                            w3schools.com
                            . Enkele belangrijke waarden zijn: flex-start, flex-end, center, space-between,
                            space-around, space-evenly en stretch.</p>
                        <p>flex-start: Stapelt de rijen aan de start van de kruis-as (bijv. allemaal bovenin de
                            container)
                            w3schools.com
                            .</p>
                        <p>flex-end: Stapelt de rijen aan de onderkant van de container
                            w3schools.com
                            .</p>
                        <p>center: Groepeert de rijen in het midden van de beschikbare hoogte
                            w3schools.com
                            .</p>
                        <p>space-between: Verdeelt de rijen gelijkmatig over de hoogte, eerste rij boven, laatste rij
                            onder, rest ertussen.</p>
                        <p>space-around: Gelijke ruimte boven en onder elke rij, waardoor de buitenranden half zoveel
                            ruimte krijgen als tussen de rijen.</p>
                        <p>space-evenly: Gelijke ruimte boven, tussen en onder alle rijen (overal gelijk).</p>
                        <p>stretch: Standaard. De rijen worden uitgerekt om de volledige hoogte van de container te
                            vullen (indien mogelijk)
                            w3schools.com
                            .</p>
                        <p>align-content heeft alleen effect als de flex-container meerdere regels heeft (flex-wrap:
                            wrap) én de totale hoogte van de items samen kleiner is dan de hoogte van de container (er
                            dus vrije ruimte is)
                            w3schools.com
                            w3schools.com
                            . Als de content al de container vult of als er slechts één regel is, doet align-content
                            niets.</p>
                        <pre><code>.container {
  display: flex;
  flex-wrap: wrap;
  height: 600px;
  align-content: space-around; /* verdeelt meerdere flex-regels met gelijke ruimte eromheen */
}
</code></pre>
                        <p>Bovenstaand voorbeeld zou, stel dat er drie rijen items zijn, die rijen verdelen met even
                            ruimte boven, tussen en onder de rijen binnen een 600px hoge container.</p>
                        <h6>gap, row-gap &amp; column-gap</h6>
                        <p>De eigenschap gap bepaalt de ruimte tussen flex-items (de zogenaamde gaps of gutters) binnen
                            de flex-container. Historisch gezien heette dit in de eerste instantie grid-gap voor
                            gridlayouts, maar tegenwoordig werkt gap ook voor flexbox containers
                            dev.to
                            . Je kunt hiermee gemakkelijk afstand tussen flexbox-items instellen zonder extra margins te
                            gebruiken.</p>
                        <p>gap: Shorthand voor het instellen van zowel de rij- als kolom-ruimte tussen items. Bij één
                            waarde geldt het zowel voor de rij- als kolomafstand; bij twee waarden is de eerste de
                            rijafstand (verticale ruimte tussen regels) en de tweede de kolomafstand (horizontale ruimte
                            tussen items binnen een regel)
                            dev.to
                            .</p>
                        <p>row-gap: Bepaalt alleen de verticale ruimte tussen flex-regels (alleen relevant als items
                            wrappen naar meerdere regels).</p>
                        <p>column-gap: Bepaalt alleen de horizontale ruimte tussen items binnen dezelfde flex-regel.</p>
                        <pre><code>.container {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;           /* 10px ruimte zowel tussen kolommen als tussen rijen */
}
.container2 {
  display: flex;
  flex-wrap: wrap;
  row-gap: 5px;        /* 5px tussen boven/onder elkaar liggende regels */
  column-gap: 20px;    /* 20px tussen items naast elkaar */
}
</code></pre>
                        <p>In het eerste voorbeeld krijgen alle flex-items 10px ruimte rondom elkaar (zowel naast als
                            onder/boven elkaar). In het tweede voorbeeld is de horizontale afstand groter (20px) dan de
                            verticale (5px). Als de flex-items niet wrappen (één regel), dan heeft row-gap geen effect.
                        </p>
                        <p>Opmerking: Gebruik van gap is vaak netter dan margins op de items, omdat gap geen extra
                            ruimte aan de randen van de container toevoegt – het verdeelt alleen de tussenruimtes. Het
                            is dus zeer handig voor consistente gutters in flex- en gridlayouts
                            dev.to
                            .</p>
                        <h6>place-content</h6>
                        <p>De eigenschap place-content is een shorthand waarmee je in één declaratie zowel align-content
                            als justify-content instelt
                            w3schools.com
                            w3schools.com
                            . Deze eigenschap is vooral nuttig in containers met zowel horizontale als verticale vrije
                            ruimte (bijvoorbeeld een flex-container met meerdere regels, of in grid – daarover later
                            meer).</p>
                        <p>Als je twee waarden opgeeft, is de eerste voor align-content (kruis-as) en de tweede voor
                            justify-content (hoofdas)
                            w3schools.com
                            . Voorbeeld: place-content: start center; zal de flex-regels aan de bovenkant van de
                            container groeperen en de items binnen elke regel horizontaal centreren. Dit staat gelijk
                            aan align-content: start; justify-content: center;
                            w3schools.com
                            .</p>
                        <p>Als je één waarde opgeeft, geldt die voor beide (align-content en justify-content)
                            w3schools.com
                            . Voorbeeld: place-content: end; is hetzelfde als zowel align-content: end als
                            justify-content: end (dus alle flex-regels naar onderen en items naar rechts, in een
                            standaard links-naar-rechts context)
                            w3schools.com
                            .</p>
                        <pre><code>.container {
  display: flex;
  flex-wrap: wrap;
  /* Bijv: alle rijen naar boven, items in het midden horizontaal */
  place-content: start center;
}
</code></pre>
                        <p>Bedenk wel dat, net als bij align-content, deze eigenschap alleen effect heeft als er vrije
                            ruimte is in de container (meerdere flexregels met ruimte over). In een single-line flexbox
                            doet place-content in feite niets omdat er geen meerdere lijnen zijn om te verdelen.</p>
                        <p>Merk op: Hoewel place-content ook geacht wordt te werken met flexbox (shorthand voor
                            align-content en justify-content)
                            w3schools.com
                            , komt het vooral tot zijn recht in CSS Grid layouts. In flexbox heeft align-content immers
                            alleen nut bij wrapping (meerdere regels). Desalniettemin kun je het veilig gebruiken voor
                            gemak en consistentie.</p>
                        <h6>Eigenschappen van flex-items</h6>
                        <p>Flex-items zijn de directe kinderen van een flex-container. Naast de eigenschappen die de
                            container erop loslaat, hebben individuele items ook eigenschappen om hun gedrag en
                            positionering binnen de flexbox te beïnvloeden. Hieronder behandelen we alle flex-item
                            eigenschappen.</p>
                        <h6>order</h6>
                        <p>Standaard worden flex-items weergegeven in de volgorde zoals ze in de HTML staan, van links
                            naar rechts of van boven naar onder. De eigenschap order kan gebruikt worden om de volgorde
                            van weergave van een flex-item binnen de container te wijzigen
                            w3schools.com
                            . Elk item heeft standaard order: 0 (nul). Items met een lagere order-waarde verschijnen
                            eerder dan items met een hogere waarde. Bij gelijke waarden blijven items in hun
                            oorspronkelijke bronvolgorde.</p>
                        <p>Je kunt positieve, nul of negatieve getallen gebruiken voor order. Een item met order: -1
                            komt vóór alle items met de default 0. Een item met order: 5 komt na items met lagere orde,
                            enzovoort.</p>
                        <p>Het verandert niet de daadwerkelijke DOM-structuur, enkel de visuele ordening in de
                            flex-container.</p>
                        <pre><code>.item-a { order: 1; }
.item-b { order: 2; }
.item-c { order: -1; }
</code></pre>
                        <p>In dit voorbeeld zal het item met klasse .item-c als eerste getoond worden (door order: -1),
                            gevolgd door .item-a (order: 1), en dan .item-b (order: 2), ongeacht hun volgorde in de
                            HTML.</p>
                        <p>Volgens de specificatie is de default waarde 0
                            w3schools.com
                            . Elk geheel getal is toegestaan. Let op dat het gebruik van order alleen invloed heeft op
                            de weergave binnen de flex-container; voor bijvoorbeeld toegang via toetsenbord
                            (tabvolgorde) of schermlezers blijft de DOM-volgorde leidend, dus gebruik deze eigenschap
                            met beleid als toegankelijkheid van belang is.</p>
                        <h6>flex-grow</h6>
                        <p>flex-grow bepaalt hoeveel een flex-item groeit relatief ten opzichte van de andere items, als
                            er vrije ruimte beschikbaar is in de container
                            w3schools.com
                            w3schools.com
                            . Het is een getal zonder eenheid (factor). Standaard is flex-grow: 0, wat betekent dat een
                            item niet extra groeit om de vrije ruimte op te vullen (het blijft zijn intrinsieke of
                            basisgrootte houden, tenzij alle andere ook 0 zijn, dan verdeelt niemand de ruimte).</p>
                        <p>Wanneer meerdere items een flex-grow &gt; 0 hebben, zal de vrije ruimte in de container
                            verdeeld worden in verhouding tot deze waarden. Bijvoorbeeld, als item A flex-grow: 2 heeft
                            en item B flex-grow: 1, krijgt A dubbel zoveel van de beschikbare extra ruimte als B
                            dev.to
                            .</p>
                        <p>Waarde 0: het item groeit niet om extra ruimte op te vullen (default)
                            w3schools.com
                            w3schools.com
                            .</p>
                        <p>Waarde 1 of hoger: het item groeit wel. Meerdere items verdelen ruimte volgens de verhouding
                            van hun grow-waarden (denk aan flex-grow als “flexibel gewicht”).</p>
                        <pre><code>.item1 { flex-grow: 1; } /* zal ruimte innemen als beschikbaar */
.item2 { flex-grow: 2; } /* krijgt dubbel zoveel extra ruimte als item1 */
.item3 { flex-grow: 0; } /* groeit niet mee met extra ruimte */
</code></pre>
                        <p>Als de container bijvoorbeeld 300px vrije ruimte over heeft nadat alle basisgroottes zijn
                            ingenomen, zou item2 daarvan 200px krijgen en item1 100px, terwijl item3 niets extra krijgt,
                            uitgaande van bovenstaande waarden.</p>
                        <p>Tip: Vaak geven ontwikkelaars alle flex-items flex-grow: 1 om ze gelijkmatig de ruimte te
                            laten verdelen. Bijvoorbeeld drie items met allemaal grow 1 binnen een container verdelen de
                            ruimte in gelijke delen
                            w3schools.com
                            .</p>
                        <h6>flex-shrink</h6>
                        <p>Terwijl flex-grow bepaalt hoe items uitbreiden, bepaalt flex-shrink hoe items krimpen als de
                            ruimte te krap is. Het is eveneens een verhoudingsgetal (standaard 1) dat aangeeft hoeveel
                            een item mag krimpen relatief tot de andere items als de container kleiner is dan de totale
                            benodigde ruimte
                            w3schools.com
                            w3schools.com
                            .</p>
                        <p>Standaard flex-shrink: 1: items mogen krimpen indien nodig. Alle items met shrink 1 zullen
                            proportioneel kleiner worden als de container te klein is.</p>
                        <p>flex-shrink: 0: dit item krimpt niet als de ruimte tekortschiet – het behoudt minstens zijn
                            basisgrootte, waardoor andere flex-items meer moeten krimpen (of de container overflowt als
                            onvoldoende krimp van anderen mogelijk is)
                            w3schools.com
                            .</p>
                        <p>Andere positieve waarden: vergelijkbaar met grow verdeelt de shrink-waarde de hoeveelheid
                            “moet krimpen”-ruimte tussen items. Een item met een hogere shrink-factor zal meer inkrimpen
                            dan eentje met een lagere factor, relatief gezien.</p>
                        <p>In de praktijk wordt flex-shrink minder vaak aangepast dan flex-grow. Vaak laten we de
                            default 1 staan, behalve in specifieke gevallen waar een bepaald item minimaal een bepaalde
                            grootte moet behouden (dan zet je voor dat item flex-shrink: 0 zodat het niet kleiner wordt
                            dan zijn basiswaarde)
                            w3schools.com
                            .</p>
                        <pre><code>.item-img  { flex-shrink: 0; } /* bijv. een afbeelding die niet verkleind mag worden */
.item-text { flex-shrink: 2; } /* dit item mag twee keer sterker krimpen dan standaard */
</code></pre>
                        <p>Bedenk dat flex-shrink ook alleen in effect treedt als de flex-container kleiner is dan de
                            som van de flex-basis groottes van de items; het bepaalt dan hoe de pijn van het kleiner
                            maken wordt verdeeld.</p>
                        <h6>flex-basis</h6>
                        <p>flex-basis specificeert de initiële hoofdas-grootte van een flex-item voordat extra ruimte
                            wordt verdeeld door grow of er gekrompen wordt door shrink
                            w3schools.com
                            . Simpel gezegd: het is de “voorkeursbreedte” (bij een rij) of -hoogte (bij een kolom) van
                            het item. Standaard staat flex-basis op auto, wat meestal betekent dat de grootte uit de
                            content of expliciete breedte/hoogte van het element komt. Je kunt flex-basis ook in
                            CSS-eenheden instellen (px, %, etc.).</p>
                        <p>Enkele voorbeelden en effecten:</p>
                        <p>Als je flex-basis: 100px zet op een item (in een rij-flexcontainer), dan zal het item starten
                            met een breedte van 100px. Daarna pas wordt gekeken of er nog ruimte over is (of tekort) en
                            zullen flex-grow/shrink dit aanpassen.</p>
                        <p>flex-basis: auto (default) betekent dat de basisgrootte de grootte van de content of de
                            opgegeven width/height is. Bijvoorbeeld een breedte via CSS of een intrinsieke
                            afbeeldingbreedte wordt dan als uitgangspunt genomen.</p>
                        <p>flex-basis: 0 betekent dat elk item geen initiële ruimte claimt op basis van content – alle
                            items beginnen op 0 en alleen via flex-grow delen ze de ruimte. Dit wordt soms gebruikt om
                            een gelijkmatige verdeling te forceren ongeacht content.</p>
                        <pre><code>.item1 { flex-basis: 200px; } /* item wil 200px innemen in de hoofdas */
.item2 { flex-basis: 50%; }   /* item wil 50% van container (voor grow/shrink) */
.item3 { flex-basis: auto; } /* item neemt eigen inhoudsgrootte als basis (default) */
</code></pre>
                        <p>In een scenario waarin je drie kolommen gelijk wilt verdelen kun je bijvoorbeeld flex-basis:
                            0; flex-grow: 1; op alle drie items zetten, zodat elk item vanaf 0 start en vervolgens
                            evenveel groeit – zo verdeel je de ruimte in exact gelijke delen, ongeacht content.</p>
                        <h6>flex (shorthand)</h6>
                        <p>De flex shorthand eigenschap combineert de drie bovenstaande eigenschappen – flex-grow,
                            flex-shrink en flex-basis – in één korte notatie
                            w3schools.com
                            . Dit is de eigenschap die je meestal direct toepast op flex-items voor gemak. De syntaxis
                            is bijvoorbeeld: flex: &lt;grow&gt; &lt;shrink&gt; &lt;basis&gt;;. Enkele veelvoorkomende
                            patronen:</p>
                        <p>flex: 0 1 auto (dit is gelijk aan de default waarde flex: initial): niet groeien, wel krimpen
                            indien nodig, basis = auto (inhoudsgrootte)
                            w3schools.com
                            .</p>
                        <p>flex: 1 1 auto: zowel groeien als krimpen toegestaan, en basis = auto. In praktijk betekent
                            dit dat alle items met flex: 1 gelijkmatig de ruimte delen en ook gelijkmatig krimpen bij
                            overflow. Vaak voldoende om een rij items gelijk te verdelen.</p>
                        <p>flex: 1 0 auto: groeien toegestaan, niet krimpen.</p>
                        <p>flex: 0 0 &lt;lengte&gt;: niet groeien of krimpen; item houdt altijd exact &lt;lengte&gt;
                            (bijv. flex: 0 0 200px betekent vast 200px breed ongeacht container). Dit wordt ook wel
                            flex: none genoemd (equivalent aan flex: 0 0 auto als &lt;lengte&gt; auto is, of met
                            specifieke basis als gegeven).</p>
                        <p>flex: auto: staat gelijk aan flex: 1 1 auto – item groeit en krimpt indien nodig en basis is
                            auto.</p>
                        <p>flex: none: staat gelijk aan flex: 0 0 auto – item gedraagt zich inflexibel (vaste
                            basisgrootte, geen groei, geen krimp).</p>
                        <p>Een gebruikelijk gebruik is bijvoorbeeld:</p>
                        <pre><code>.item {
  flex: 1; /* shorthand voor flex: 1 1 0% in modern browsers (groeit, krimpt, basis 0) */
}
</code></pre>
                        <p>Door flex: 1 op alle siblings toe te passen, verdeel je de ruimte evenredig
                            w3schools.com
                            . Merk op dat volgens de specificatie flex: &lt;een getal&gt; technisch gezien betekent
                            flex: &lt;getal&gt; 1 0 (die 0 als procent). Vaak is dit voldoende voor gelijkmatige
                            verdeling van items in een rij.</p>
                        <h6>align-self</h6>
                        <p>Met align-self kan je de uitlijning van een specifiek flex-item op de kruis-as aanpassen,
                            onafhankelijk van de uitlijning die de container via align-items heeft ingesteld
                            w3schools.com
                            w3schools.com
                            . Deze eigenschap overrulet de algemene align-items van de container voor dat ene item
                            w3schools.com
                            . De mogelijke waarden zijn dezelfde als bij align-items (auto, flex-start, flex-end,
                            center, baseline, stretch). Standaard is align-self: auto, wat betekent dat het item de
                            align-items waarde van de container volgt
                            w3schools.com
                            .</p>
                        <p>Gebruik align-self bijvoorbeeld als je één item opvallend anders wil positioneren:</p>
                        <p>Als de container align-items: stretch heeft (alle items vullen hoogte), maar één item moet
                            niet uitgerekt worden en in het midden blijven hangen, kun je op dat item align-self: center
                            zetten.</p>
                        <p>Als de container align-items: center (alle in het midden), maar één item moet naar boven:
                            align-self: flex-start.</p>
                        <pre><code>.container { 
  display: flex;
  align-items: center; /* standaard alle items centreren */
}
.item.special {
  align-self: flex-end; /* dit specifieke item zakt naar de onderkant van container */
}
</code></pre>
                        <p>In bovenstaand voorbeeld liggen alle items centraal, behalve .special die onderaan wordt
                            uitgelijnd door zijn eigen instelling.</p>
                        <p>Let op: align-self werkt alleen over de kruis-as. Er bestaat geen justify-self voor
                            flex-items – de positionering langs de hoofdas kan niet per item verschillend zijn in een
                            flex-container (dat wordt altijd door de container als geheel bepaald via justify-content).
                            Dit is een fundamenteel verschil met CSS Grid, waar individuele items wél een justify-self
                            hebben.</p>
                        <p>Nu we Flexbox uitgebreid hebben besproken, richten we ons op CSS Grid, dat ons in staat stelt
                            twee dimensies tegelijk te beheren.</p>
                        <h6>CSS Grid Layout</h6>
                        <p>CSS Grid is een layout-systeem dat een rooster van rijen en kolommen creëert. Waar Flexbox
                            vooral geschikt is voor een rij of een kolom tegelijk, biedt Grid de mogelijkheid om
                            elementen over zowel rijen als kolommen te positioneren in een tweedimensionaal raster
                            freecodecamp.org
                            freecodecamp.org
                            . Dit maakt het ideaal voor complexe pagina-indelingen en dashboard-achtige layouts.</p>
                        <p>In CSS Grid spreken we van een grid-container (het element met display: grid of display:
                            inline-grid) en grid-items (de directe kinderen van die container)
                            freecodecamp.org
                            freecodecamp.org
                            . De container definieert het raster (de tracks of lijnen, cellen en eventueel gebieden), en
                            de items kunnen daarbinnen geplaatst worden middels coördinaten (rij/kolom posities), vaak
                            zonder expliciete HTML structuur voor lege cellen nodig te hebben.</p>
                        <p>Hieronder bespreken we eerst de eigenschappen voor de grid-container (het raster zelf
                            definiëren en uitlijning instellen), gevolgd door de eigenschappen voor de grid-items
                            (positie en uitlijning van individuele items).</p>
                        <h6>Eigenschappen van de grid-container</h6>
                        <p>Om een element een grid-container te maken, stel je display: grid in. Alle directe kinderen
                            worden dan grid-items, gepositioneerd in het gedefinieerde raster
                            developer.mozilla.org
                            developer.mozilla.org
                            . Een grid-container heeft vele eigenschappen om het raster (de “grid”) te definiëren:
                            hoeveel kolommen en rijen, hoe breed/hoog die zijn, eventuele naamgeving van gebieden, hoe
                            extra content automatisch geplaatst wordt, etc. We lopen ze systematisch door.</p>
                        <h6>display: grid / display: inline-grid</h6>
                        <p>Net als bij flex wordt de grid layout geactiveerd via de display property:</p>
                        <p>display: grid maakt een block-level grid-container
                            freecodecamp.org
                            . De container gedraagt zich als een blok-element op de pagina (neemt volledige breedte
                            indien mogelijk) maar binnenin is het gedrag volgens het gridmodel.</p>
                        <p>display: inline-grid maakt een inline-level grid-container
                            freecodecamp.org
                            . De container gedraagt zich als een inline-element (past zich aan rond de inhoud) in de
                            flow, maar binnenin is er een gridmodel.</p>
                        <p>Beide varianten maken dat de directe kinderen grid-items worden. Het verschil is vooral hoe
                            de container zelf zich naar zijn buitenomgeving gedraagt (block vs inline).</p>
                        <p>Voorbeeld:</p>
                        <pre><code>.container {
  display: grid;
}
.inline-grid-container {
  display: inline-grid;
}
</code></pre>
                        <p>Een &lt;div class="container"&gt; zal als blok een volledige breedte pakken en een nieuwe
                            regel starten, terwijl &lt;span class="inline-grid-container"&gt; bijvoorbeeld in een tekst
                            zou kunnen staan zonder de flow te onderbreken, maar desondanks een grid binnenin hanteert.
                        </p>
                        <h6>grid-template-columns en grid-template-rows</h6>
                        <p>Met grid-template-columns definieer je de kolommen van het grid, en met grid-template-rows de
                            rijen. Deze eigenschappen nemen een lijst van waarden, gescheiden door spaties, die de
                            afmetingen van respectievelijk elke kolom en elke rij aangeven
                            freecodecamp.org
                            freecodecamp.org
                            .</p>
                        <p>Voorbeelden van waardeformaten:</p>
                        <p>Absolute lengtes (px, em, etc.): bijv. grid-template-columns: 100px 100px 100px; voor drie
                            kolommen van elk 100px.</p>
                        <p>Percentages: bijv. grid-template-columns: 50% 50%; voor twee kolommen die elk de helft van de
                            containerbreedte nemen.</p>
                        <p>Flexibele eenheid fr (fractional unit): bijv. grid-template-columns: 1fr 2fr; voor twee
                            kolommen, waarbij de tweede kolom dubbel zo breed is als de eerste binnen de resterende
                            ruimte
                            freecodecamp.org
                            freecodecamp.org
                            . fr verdeelt de ruimte na aftrek van evt. vaste maten.</p>
                        <p>auto: automatische grootte op basis van content (of andere constraints).</p>
                        <p>Combinaties van bovengenoemde: bijv. grid-template-columns: 200px 2fr auto; etc.</p>
                        <pre><code>.container {
  display: grid;
  grid-template-columns: 100px 100px 100px; /* 3 kolommen van elk 100px */
  grid-template-rows: 80px 200px;          /* 2 rijen: eerste 80px, tweede 200px hoog */
}
</code></pre>
                        <p>In dit voorbeeld ontstaat een grid van 3 kolommen bij 2 rijen. De resterende rijen (als er
                            meer items zijn dan 2 rijen) krijgen automatisch de grootte auto (tenzij anders bepaald), en
                            resterende kolommen (als er meer dan 3 items in een rij zouden komen zonder expliciete
                            plaatsing) krijgen ook auto breedte – maar standaard creëert de browser geen extra kolommen
                            buiten de gedefinieerde (die extra items komen dan in de gedefinieerde kolommen van volgende
                            rijen als er rijen beschikbaar zijn).</p>
                        <p>Je kunt expliciet meer kolommen of rijen opgeven. Bijvoorbeeld:</p>
                        <pre><code>.container {
  display: grid;
  grid-template-columns: 1fr 2fr 1fr;  /* drie kolommen, middelste neemt 2x ruimte van elk van de buitenste */
  grid-template-rows: 50px 50px 50px;  /* drie rijen van 50px hoog */
}
</code></pre>
                        <p>Flexibele tracks met fr: De fr eenheid is zeer krachtig: 1fr betekent “één deel van de vrije
                            ruimte”. Dus 1fr 1fr in een container zal beide kolommen gelijk verdelen, terwijl 1fr 2fr de
                            tweede kolom dubbel zo breed maakt als de eerste
                            freecodecamp.org
                            . Het voordeel t.o.v. percentages is dat fr alleen de vrije ruimte verdeelt (na aftrek van
                            vaste pixels bijvoorbeeld) en automatisch adaptief is bij resizing.</p>
                        <p>Implicit vs explicit grid: De kolommen/rijen die je met deze eigenschappen definieert vormen
                            de expliciete grid. Items kunnen echter ook buiten deze expliete definities vallen; de
                            browser voegt dan impliciet extra rijen/kolommen toe indien nodig voor de content. Standaard
                            hebben impliciete tracks een grootte van auto, maar je kunt dit beïnvloeden met de
                            eigenschappen grid-auto-rows en grid-auto-columns (zie verder)
                            freecodecamp.org
                            freecodecamp.org
                            .</p>
                        <p>repeat() en andere functies: CSS Grid biedt handige functies als repeat(), minmax() etc. om
                            template-waarden efficienter te definiëren:</p>
                        <p>repeat(n, value): herhaalt een bepaalde track-definitie n keer. Bijvoorbeeld
                            grid-template-columns: repeat(3, 1fr); is hetzelfde als 1fr 1fr 1fr (3 gelijke kolommen)
                            freecodecamp.org
                            .</p>
                        <p>minmax(min, max): stelt een minimale en maximale grootte voor een track vast die responsief
                            tussen die waarden kan variëren.</p>
                        <p>Deze functies verhogen de flexibiliteit maar voor een beginner volstaat het basisprincipe:
                            een lijst van groottes voor kolommen en rijen.</p>
                        <h6>grid-template-areas</h6>
                        <p>Met grid-template-areas kun je naamgegeven gebieden binnen het grid definëren, wat het
                            plaatsen van items visueel inzichtelijker en gemakkelijker maakt. Je definieert een
                            ASCII-artistiek patroon van namen die overeenkomen met de cel-indeling. Bijvoorbeeld:</p>
                        <pre><code>.container {
  display: grid;
  grid-template-columns: 1fr 3fr;
  grid-template-rows: auto auto;
  grid-template-areas: 
    "sidebar  main"
    "sidebar  main";
}
</code></pre>
                        <p>In dit voorbeeld hebben we twee kolommen (een smallere sidebar van 1fr en een main gebied van
                            3fr) en twee rijen. De string in grid-template-areas bestaat uit twee regels (tussen
                            quotes), elke regel vertegenwoordigt een rij in het grid. We hebben "sidebar main" op de
                            eerste en "sidebar main" op de tweede rij, wat betekent dat de eerste kolom over twee rijen
                            de area “sidebar” vormt, en de tweede kolom over twee rijen de area “main”
                            freecodecamp.org
                            . Visueel:</p>
                        <p>| sidebar | main |<br>| sidebar | main |</p>
                        <p>Nu kunnen we grid-items aan deze gebieden toewijzen via de grid-area property op de items
                            (zie grid-item eigenschappen). Als een item grid-area: sidebar krijgt, beslaat het
                            automatisch de cellen aangeduid als "sidebar" (in dit geval beide rijen van de eerste
                            kolom). Een item met grid-area: main beslaat beide rijen van de tweede kolom.</p>
                        <p>Belangrijke punten bij grid-template-areas:</p>
                        <p>De namen in de string kunnen willekeurige identificeerbare woorden zijn (letters/cijfers/_).
                            Per cel in de grid moet er een naam of een . (punt) als lege cel-aanduiding staan. De aantal
                            namen per rij in de string moet overeenkomen met het aantal kolommen dat je hebt
                            gedefinieerd.</p>
                        <p>Een continue rechthoek van dezelfde naam vormt één gebied. In het voorbeeld hierboven vormt
                            "sidebar" een rechthoek van 2 rijen bij 1 kolom.</p>
                        <p>Je kunt met een punt (.) aangeven dat een cel tot geen genoemd gebied behoort, bijvoorbeeld
                            voor lege spaties of als een item niet een rechthoek beslaat. Items kunnen nog steeds via
                            lijn-nummers geplaatst worden op plekken zonder naam.</p>
                        <p>grid-template-areas is optioneel maar erg handig voor lay-out denken in secties. Als je het
                            gebruikt, is het slim ook alle te plaatsen items een naam te geven (of . voor onbenutte
                            cellen) zodat je later geen conflict hebt. Je kunt ongebruikte gebieden aanduiden met
                            "empty" of gewoon niet benoemen (maar dan wel een . placeholder in de grid-template-areas
                            string zetten zodat de matrix klopt).</p>
                        <h6>grid-template (shorthand)</h6>
                        <p>grid-template is een shorthand die zowel grid-template-rows, grid-template-columns en
                            eventueel grid-template-areas in één eigenschap combineert. De syntaxis kan twee vormen
                            hebben:</p>
                        <p>Met areas: Je schrijft de area strings als waarde, gescheiden door quotes en newline in CSS.
                            Binnen die strings kun je de expliciete kolommen afleiden uit het aantal tokens per rij.
                            Bijvoorbeeld:</p>
                        <pre><code>grid-template:
  "header header" 50px
  "sidebar main"  200px
  / 100px auto;
</code></pre>
                        <p>Hier worden twee rijen (“header header” en “sidebar main”). Achter elke string zie je de
                            hoogte van die rij (50px voor de eerste, 200px voor de tweede). Na de slash / volgen de
                            kolombreedtes: 100px voor de eerste kolom en auto voor de tweede. Dit is een compacte manier
                            om alles te definiëren.</p>
                        <p>Zonder areas: Je kunt ook direct twee waarden geven vóór de slash: één voor
                            grid-template-rows en één voor grid-template-columns. Bijvoorbeeld: grid-template: 150px
                            150px / 1fr 2fr 1fr; betekent twee rijen van 150px en drie kolommen met fracties
                            w3schools.com
                            . Dit is gelijkwaardig aan apart schrijven grid-template-rows: 150px 150px;
                            grid-template-columns: 1fr 2fr 1fr;.</p>
                        <p>Voor beginners is het niet per se nodig de shorthand te gebruiken – het is vaak duidelijker
                            om grid-template-columns en grid-template-rows apart te schrijven, tenzij je ook areas
                            gebruikt, want dan is de shorthand wel heel handig om alles consistent te houden.</p>
                        <h6>gap, row-gap &amp; column-gap (Grid)</h6>
                        <p>Net als bij Flexbox kunnen we met gap de gutter-ruimte tussen grid-items regelen. Voor Grid
                            werkt gap op vergelijkbare wijze, maar nu gaat het om de ruimte tussen grid-cellen
                            (horizontaal tussen kolommen en verticaal tussen rijen).</p>
                        <p>gap (of specifiek grid-gap, een oudere benaming) met één waarde zet zowel de rij- als
                            kolomafstand. Met twee waarden geef je row-gap en column-gap afzonderlijk op (eerste waarde
                            rij, tweede kolom).</p>
                        <p>row-gap: afstand tussen rijen onderling.</p>
                        <p>column-gap: afstand tussen kolommen.</p>
                        <pre><code>.container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: repeat(2, 100px);
  gap: 10px 20px; /* 10px tussen rijen, 20px tussen kolommen */
}
</code></pre>
                        <p>In bovenstaand grid van 3x2 (3 kolommen, 2 rijen) zal er verticaal 10px ruimte zijn tussen de
                            twee rijen, en horizontaal 20px tussen de drie kolommen. Aan de buitenranden van de
                            grid-container komt geen extra marge door gap; het beïnvloedt uitsluitend de tussenruimte
                            binnen het grid.</p>
                        <p>Historisch gezien gebruikte men grid-row-gap en grid-column-gap, en grid-gap als shorthand.
                            Inmiddels is dit genormaliseerd naar gewoon row-gap, column-gap en gap voor zowel grid als
                            flex, maar je kunt de oude namen nog tegenkomen (deze worden automatisch als aliassen gezien
                            door moderne browsers).</p>
                        <h6>justify-items en align-items</h6>
                        <p>Deze twee eigenschappen bepalen de uitlijning van de inhoud binnen elke grid-cel,
                            respectievelijk horizontaal (justify-items langs de rij-as) en verticaal (align-items langs
                            de kolom-as) binnen de cellen
                            freecodecamp.org
                            .</p>
                        <p>Je kunt ze zien als de grid-equivalent van align-items/justify-content, maar met dit
                            verschil:</p>
                        <p>justify-items en align-items worden ingesteld op de grid-container en gelden als default voor
                            alle grid-items
                            freecodecamp.org
                            .</p>
                        <p>Elk grid-item zal binnen zijn eigen cel volgens deze waarden gepositioneerd worden, tenzij
                            het item zelf iets anders opgeeft via justify-self of align-self (zie later).</p>
                        <p>Typische waarden:</p>
                        <p>stretch: (default voor beide) Items rekken zich uit om de volledige cel te vullen in die as
                            freecodecamp.org
                            . Bijvoorbeeld, justify-items: stretch laat items de hele celbreedte innemen. align-items:
                            stretch de hele celhoogte.</p>
                        <p>start: Items worden uitgelijnd aan de startkant van hun cel (links voor justify, bovenaan
                            voor align in een normaal schrijftype)
                            freecodecamp.org
                            freecodecamp.org
                            .</p>
                        <p>end: Items aan de eindkant van de cel (rechts voor justify, onderkant voor align)
                            freecodecamp.org
                            .</p>
                        <p>center: Items in het centrum van hun cel geplaatst
                            freecodecamp.org
                            .</p>
                        <p>baseline: (voor align-items) Items uitlijnen op hun tekst-baseline ten opzichte van elkaar.
                            Grid biedt ook baseline alignment, maar dit is wat geavanceerder en minder vaak gebruikt
                            tenzij je typografisch wilt uitlijnen over cellen heen.</p>
                        <p>Voorbeeld:</p>
                        <pre><code>.container {
  display: grid;
  grid-template-columns: 100px 100px;
  grid-template-rows: 100px 100px;
  justify-items: center; /* alle items horizontaal gecentreerd in hun cel */
  align-items: start;    /* alle items verticaal aan de bovenkant van hun cel */
}
</code></pre>
                        <p>Hier zullen alle grid-items, ongeacht hun grootte, in het midden van de cellen staan qua
                            breedte, en aan de bovenrand qua hoogte.</p>
                        <p>Als je bijvoorbeeld wilt dat alle grid-items standaard de hele cel opvullen, laat je de
                            default stretch staan (of stel je expliciet justify-items: stretch; align-items: stretch;
                            in). Wil je dat alle items standaard linksboven in hun cell staan: justify-items: start;
                            align-items: start;.</p>
                        <p>place-items: Dit is een shorthand vergelijkbaar met place-content, maar dan voor items.
                            place-items: &lt;align-items&gt; &lt;justify-items&gt; combineert de twee. Eén waarde
                            betekent beide hetzelfde. Bijvoorbeeld place-items: center; is gelijk aan zowel horizontaal
                            als verticaal centreren van item inhoud (soort alles in cellen midden) – effectief
                            align-items: center; justify-items: center;. Dit is een handige verkorting als je vaak
                            dezelfde waarde wilt gebruiken voor beide assen.</p>
                        <h6>justify-content en align-content</h6>
                        <p>Nu we gezien hebben hoe items binnen cellen uitgelijnd zijn, komen justify-content en
                            align-content in Grid in beeld om de plaatsing van het hele grid binnen de container te
                            regelen. Deze eigenschappen functioneren op een grid-container bijna zoals in Flexbox, maar
                            met grid-specifieke nuances:</p>
                        <p>justify-content (Grid): bepaalt hoe het gehele grid (alle kolommen als geheel) gepositioneerd
                            wordt binnen de container horizontaal (langs de rij-as)
                            freecodecamp.org
                            . Dit speelt vooral als de grid-breedte kleiner is dan de containerbreedte (vrije ruimte
                            over langs de x-as). Waarden zijn o.a. start, end, center, stretch, space-between,
                            space-around, space-evenly
                            w3schools.com
                            w3schools.com
                            .</p>
                        <p>start: het grid begint aan de linkerzijde van de container
                            freecodecamp.org
                            .</p>
                        <p>end: het grid eindigt aan de rechterzijde van de container.</p>
                        <p>center: het grid staat gecentreerd in de container (met gelijke marge links en rechts)
                            w3schools.com
                            .</p>
                        <p>stretch: het grid wordt uitgerekt om de containerbreedte te vullen (dit kan betekenen dat
                            kolommen uitgerekt worden als er ruimte over is; dit is de default als justify-content niet
                            expliciet is ingesteld en er ruimte over is)
                            freecodecamp.org
                            .</p>
                        <p>De space-* varianten verdelen de lege ruimte tussen de kolommen (vergelijkbaar met flex
                            justify-content maar nu tussen grid tracks):</p>
                        <p>space-between: eerste kolom aan linkerkant, laatste kolom aan rechterkant, tussenliggende
                            kolommen met gelijkmatige ruimte ertussen
                            w3schools.com
                            .</p>
                        <p>space-around: gelijke ruimte rondom elke kolom, dus half aan de randen vergeleken met tussen
                            kolommen
                            w3schools.com
                            .</p>
                        <p>space-evenly: volledig gelijke ruimte tussen en aan buitenzijden van de grid
                            w3schools.com
                            .</p>
                        <p>align-content (Grid): bepaalt hoe het gehele grid (alle rijen als geheel) gepositioneerd
                            wordt binnen de container verticaal (langs de kolom-as)
                            w3schools.com
                            w3schools.com
                            . Dit is relevant als de grid-hoogte kleiner is dan de containerhoogte (dus vrije ruimte
                            onder/boven). Waarden zijn analoog aan justify-content: start (grid aan bovenzijde), end
                            (aan onderzijde), center (midden), stretch (tracks uitrekken in hoogte, default als ruimte
                            over is), space-between (eerste rij boven, laatste onder, rest verdeeld)
                            w3schools.com
                            , space-around, space-evenly net zoals boven maar dan verticaal.</p>
                        <p>Deze eigenschappen hebben geen effect als het grid precies de container opvult of overloopt.
                            Ze zijn bedoeld voor wanneer de expliciete grid minder ruimte inneemt dan beschikbaar. Vaak
                            zie je justify-content en align-content in actie bij kleinere grid’s binnen een grotere
                            container of wanneer men het gehele grid in het midden van de pagina wil plaatsen.</p>
                        <p>Voorbeelden:</p>
                        <pre><code>.container {
  display: grid;
  width: 800px;
  grid-template-columns: 200px 200px; /* grid is 400px breed totaal */
  justify-content: center;  /* grid van 400px gecentreerd binnen 800px container */
}
.container2 {
  display: grid;
  height: 500px;
  grid-template-rows: 100px 100px; /* grid is 200px hoog totaal */
  align-content: end;      /* grid van 200px naar onderkant van 500px container */
}
</code></pre>
                        <p>In container zal de 400px brede grid (2 kolommen van 200px) centraal geplaatst worden in de
                            800px container, dus 200px marge links en rechts. In container2 zal het grid van 2 rijen
                            (200px hoog totaal) onderaan de 500px hoge container staan, met 300px lege ruimte erboven.
                        </p>
                        <p>place-content: Net als eerder is place-content de shorthand voor align-content +
                            justify-content. Eén waarde = allebei, twee waarden = respectievelijk align- en
                            justify-content. Bijvoorbeeld place-content: center; centreert het hele grid zowel
                            horizontaal als verticaal in de container (mits er ruimte is)
                            w3schools.com
                            . place-content: space-between start; zou de rijen verdelen over de hoogte (space-between)
                            en de kolommen aan de linkerzijde houden.</p>
                        <h6>grid-auto-rows en grid-auto-columns</h6>
                        <p>Dit zijn eigenschappen die de grootte specificeren van impliciete grid tracks (rijen of
                            kolommen) die automatisch aangemaakt worden door de browser als content buiten de expliciete
                            grid valt
                            freecodecamp.org
                            freecodecamp.org
                            .</p>
                        <p>grid-auto-rows bepaalt de hoogte van automatisch toegevoegde rijen. Bijvoorbeeld, als je
                            slechts 2 expliciete rijen definieert, maar je plaatst een item op rij 4, dan zal de browser
                            rij 3 en 4 moeten aanmaken. Die nieuwe rijen krijgen de hoogte volgens grid-auto-rows
                            (standaard is dit auto). Je kunt dit instellen op een vaste waarde of een flexibele waarde.
                            Bijv. grid-auto-rows: 100px; betekent alle impliciete rijen worden 100px hoog (tenzij
                            bestaande content groter is, dan rekt een auto mogelijk alsnog, tenzij je minmax toepast).
                        </p>
                        <p>grid-auto-columns doet hetzelfde voor kolommen die impliciet ontstaan. Dit komt minder voor,
                            meestal definieer je kolommen expliciet. Maar bijvoorbeeld bij grid-auto-flow: column (zie
                            verder) kunnen impliciet kolommen ontstaan. Standaard is dit ook auto.</p>
                        <p>Voorbeeld:</p>
                        <pre><code>.container {
  display: grid;
  grid-template-columns: 200px 200px;
  grid-template-rows: 200px;
  grid-auto-rows: 100px;
}
</code></pre>
                        <p>We definiëren expliciet 1 rij van 200px. Als er een item op de tweede rij wordt geplaatst (of
                            als er genoeg items zijn dat automatisch een tweede rij nodig is), zal die tweede rij
                            impliciet zijn en 100px hoog (volgens grid-auto-rows). Zonder die eigenschap zou de tweede
                            rij auto hoog zijn (d.w.z. hoogte afhankelijk van de content).</p>
                        <p>Je kunt ook minmax() gebruiken, bv. grid-auto-rows: minmax(50px, auto); om te zeggen dat
                            impliciete rijen minstens 50px zijn, maar groter mogen worden om content te bevatten.</p>
                        <h6>grid-auto-flow</h6>
                        <p>grid-auto-flow bepaalt hoe de browser items automatisch plaatst die geen expliciete
                            positionering (via grid-lijnen of areas) hebben, en in welke richting er nieuwe impliciete
                            tracks moeten ontstaan als er meer items zijn dan ruimte in de bestaande grid. Waarden:</p>
                        <p>row (standaard): Plaatst items rij voor rij. Als een rij vol is (alle kolommen bezet), begint
                            het op de volgende rij (maakt eventueel impliciet nieuwe rijen aan)
                            freecodecamp.org
                            .</p>
                        <p>column: Plaatst items kolomsgewijs. Dit betekent dat het grid eerst een kolom opvult (door
                            meerdere rijen te gebruiken) en als die kolom vol is, een nieuwe kolom begint (maakt
                            impliciet nieuwe kolommen aan als nodig). Gebruik je dit, zorg dan ook dat grid-auto-columns
                            gedefinieerd is indien gewenst, omdat nu horizontaal potentieel nieuwe kolommen verschijnen.
                        </p>
                        <p>dense (kan gecombineerd worden met een van bovenstaanden als row dense of column dense): Dit
                            is een optie om “gaten” op te vullen. Als items met expliciete posities ervoor zorgen dat er
                            lege cellen ontstaan, zal de browser met dense proberen latere items in die gaten te
                            plaatsen (doorloopt de grid dichter op elkaar). Met andere woorden, dense zorgt voor
                            compacter vullen zonder volgat, maar let op: dit kan de visuele volgorde van items
                            veranderen ten opzichte van de DOM-volgorde, wat soms verwarrend kan zijn.</p>
                        <p>Standaard is grid-auto-flow: row (zonder dense), wat het meest natuurlijke gedrag is: items
                            gaan links naar rechts, boven naar beneden de grid opvullen.</p>
                        <pre><code>.container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  /* geen grid-template-rows gedefinieerd => zal impliciet rijen maken */
  grid-auto-rows: 150px;
  grid-auto-flow: row;
}
</code></pre>
                        <p>In deze container met 3 kolommen en grid-auto-flow: row zullen items in de eerste rij in
                            kolom 1,2,3 geplaatst worden, dan voor item 4 wordt een nieuwe rij gemaakt etc. Elke
                            impliciete rij is 150px hoog.</p>
                        <p>Als we grid-auto-flow: column zouden doen, dan wordt eerst kolom 1 gevuld (zoveel rijen als
                            nodig), dan kolom 2, etc. Dit is bijvoorbeeld bruikbaar als je een fotogalerij wil opvullen
                            kolom per kolom.</p>
                        <h6>grid (shorthand)</h6>
                        <p>De grid shorthand eigenschap is complex maar kortweg: je kunt hiermee in één regel zowel een
                            expliciete grid als het automatische gedrag definiëren. Deze shorthand kan verschillende
                            vormen aannemen:</p>
                        <p>grid: &lt;grid-template-rows&gt; / &lt;grid-template-columns&gt;; is de eenvoudige vorm
                            (alleen expliciete definities, geen auto-flow).</p>
                        <p>Je kunt ook grid: &lt;auto-flow&gt; &lt;grid-auto-rows&gt; / &lt;grid-template-columns&gt;;
                            of variaties daarop doen.</p>
                        <p>Bijvoorbeeld:</p>
                        <pre><code>.container {
  display: grid;
  grid: 100px / auto auto auto;
}
</code></pre>
                        <p>Dit creëert een grid met één rij van 100px hoogte en drie kolommen met automatische breedte
                            w3schools.com
                            . Je ziet de syntaxis: &lt;rijen&gt; / &lt;kolommen&gt;.</p>
                        <p>Een ander voorbeeld:</p>
                        <pre><code>.container {
  display: grid;
  grid: auto-flow 50px / 1fr 1fr;
}
</code></pre>
                        <p>Dit betekent: twee expliciete kolommen (1fr,1fr), rijen niet expliciet gegeven maar elk
                            impliciet toegevoegde rij 50px hoog en vul ze auto-flow in rij-richting. In feite combineert
                            dit:</p>
                        <p>grid-template-columns: 1fr 1fr;</p>
                        <p>grid-auto-rows: 50px;</p>
                        <p>grid-auto-flow: row;</p>
                        <p>Hoewel handig voor beknoptheid, kan de grid shorthand verwarrend zijn. Gebruik het pas als je
                            de onderliggende eigenschappen goed begrijpt.</p>
                        <h6>Eigenschappen van grid-items</h6>
                        <p>Grid-items (de kinderen van de grid-container) kunnen op specifieke plaatsen in het raster
                            worden neergezet en eventueel zichzelf uitlijnen binnen hun cel. We bekijken nu de
                            eigenschappen die je op individuele grid-items kunt toepassen.</p>
                        <h6>grid-column-start, grid-column-end, grid-row-start, grid-row-end</h6>
                        <p>Deze vier eigenschappen bepalen aan welke grid-lijn een item begint en net voor welke lijn
                            het eindigt (dus tot waar het doorloopt) in respectievelijk de kolom- en rijrichting. In de
                            praktijk worden ze vaak paarsgewijs gebruikt om een item te positioneren of te laten
                            uitstrekken over meerdere cellen:</p>
                        <p>grid-column-start: het nummer (of naam) van de grid-lijn waar de item’s linkerkant begint.
                        </p>
                        <p>grid-column-end: het nummer (of naam) van de grid-lijn waar de item’s rechterkant eindigt.
                            Het item beslaat dus kolommen van start tot end minus één. Je kunt hier ook span N gebruiken
                            om aan te geven dat het item N kolombreedtes moet beslaan, bijvoorbeeld grid-column-end:
                            span 2 betekent dat het item twee kolommen breed is vanaf de startpositie
                            w3schools.com
                            w3schools.com
                            .</p>
                        <p>grid-row-start en grid-row-end: analoog maar dan voor de rijlijnen (bovenkant en onderkant
                            van het item)
                            w3schools.com
                            .</p>
                        <p>Je kunt de lijnen tellen vanaf 1 aan de linkerkant (voor kolommen) en 1 aan de bovenzijde
                            (voor rijen). Ook kun je tellen vanaf het einde met negatieve indices (bijv. -1 verwijst
                            naar de laatste lijn aan de rechter-/onderkant).</p>
                        <p>Voorbeeld (zonder shorthand):</p>
                        <p>Stel een grid van 4 kolommen en 4 rijen. We willen een item laten lopen van kolom 2 t/m 4
                            (drie kolommen breed), en van rij 1 t/m 2 (twee rijen hoog). We kunnen dan op dat item
                            zetten:</p>
                        <pre><code>.item {
  grid-column-start: 2;
  grid-column-end: 5;   /* eindigen bij lijn 5, dat is de lijn na kolom 4 */
  grid-row-start: 1;
  grid-row-end: span 2; /* of gewoon 3 als absolute lijn, aangezien start 1 + span 2 => eindlijn 3 */
}
</code></pre>
                        <p>Hier is grid-column-end: 5 omdat bij 4 kolommen de lijnnummers kolommen afbakenen: lijn 1 is
                            voor kolom1 links, lijn 2 tussen kol1/kol2, etc. Lijn 5 is de meest rechter rand. Door tot
                            lijn 5 te gaan, beslaat het item kolommen 2,3,4. We hadden ook kunnen schrijven
                            grid-column-end: span 3 (vanaf startlijn 2 drie kolommen verder) wat hetzelfde effect heeft.
                        </p>
                        <p>In veel gevallen worden shorthand-eigenschappen gebruikt voor gemak:</p>
                        <h6>grid-column (shorthand) en grid-row (shorthand)</h6>
                        <p>grid-column is de shorthand voor het tegelijkertijd specificeren van start en eind voor
                            kolommen
                            w3schools.com
                            . De notatie is grid-column: &lt;start&gt; / &lt;end&gt;;. Je kunt dus de vorige
                            voorbeeldinstelling vereenvoudigd zo schrijven: grid-column: 2 / 5; om kolom start 2, eind 5
                            te doen (of grid-column: 2 / span 3;). Als een waarde ontbreekt voor start of end in de
                            shorthand, kun je bijv. grid-column: 2 / span 2; om te zeggen “start bij 2, span 2
                            kolommen”.</p>
                        <p>Evenzo is grid-row: &lt;start&gt; / &lt;end&gt;; de shorthand voor rij-start/eind
                            w3schools.com
                            . Bijvoorbeeld grid-row: 1 / span 2; voor twee rijen hoog vanaf rij 1.</p>
                        <h6>grid-area (op items)</h6>
                        <p>grid-area heeft twee totaal verschillende toepassingen afhankelijk van wat je invult:</p>
                        <p>Shorthand voor vier lijnen (top, left, bottom, right): Als je vier door schuine strepen
                            gescheiden waarden geeft (rij-start / kolom-start / rij-eind / kolom-eind), positioneert dat
                            het item in één declaratie. Bijvoorbeeld grid-area: 1 / 2 / 3 / 5; betekent:</p>
                        <p>grid-row-start: 1;</p>
                        <p>grid-column-start: 2;</p>
                        <p>grid-row-end: 3;</p>
                        <p>grid-column-end: 5;</p>
                        <p>Dit item begint dus op eerste rij, tweede kolom, en eindigt op derde rij, vijfde kolom-lijn
                            (beslaat rijen 1-2 en kolommen 2-4 in inhoud). Dit is handig om een item in één regel een
                            vaste plek en spanning te geven.</p>
                        <p>Referentie naar een benoemd gebied: Als de waarde van grid-area overeenkomt met een naam die
                            je in grid-template-areas hebt gedefinieerd op de container, dan plaatst de browser het item
                            automatisch in dat gehele gebied
                            w3schools.com
                            . Bijvoorbeeld, in het eerder gegeven template met "sidebar" en "main", kan een item een CSS
                            grid-area: sidebar; krijgen om precies in de zijbalk-positie te belanden (die 2 rijen bij 1
                            kolom groot was).</p>
                        <p>Je kunt grid-area dus zowel als shorthand voor cijfertjes als voor een naam gebruiken, maar
                            niet tegelijk. Als je een string gebruikt die niet overeenkomt met een gedefinieerd gebied,
                            zal het waarschijnlijk genegeerd worden of niets doen.</p>
                        <p>Voorbeeld van shorthand gebruik:</p>
                        <pre><code>.item {
  /* Plaats het item van rij 2 t/m 4, en kolom 1 t/m 2: 
     (met rijnummers 2->4 beslaat het rijen 2 en 3;
      kolomnummers 1->2 beslaat alleen kolom 1) */
  grid-area: 2 / 1 / 5 / 3;
}
</code></pre>
                        <p>Voorbeeld van named area gebruik (gebaseerd op eerder grid-template-areas voorbeeld):</p>
                        <pre><code>.itemHeader { grid-area: header; }
.itemSidebar { grid-area: sidebar; }
.itemMain { grid-area: main; }
</code></pre>
                        <p>Dit veronderstelt dat je grid-template-areas in de container iets had als:</p>
                        <pre><code>grid-template-areas:
  "header header"
  "sidebar main"
  "sidebar main";
</code></pre>
                        <p>Hier zou .itemHeader de bovenste rij over beide kolommen innemen, .itemSidebar links in de
                            twee rijen, .itemMain rechts in de twee rijen.</p>
                        <h6>justify-self en align-self</h6>
                        <p>We zagen dat justify-items en align-items op container-niveau de standaard uitlijning binnen
                            cellen voor alle items bepalen. Met justify-self (horizontale uitlijning binnen de cel) en
                            align-self (verticale uitlijning binnen de cel) kun je per individueel grid-item hiervan
                            afwijken
                            w3schools.com
                            w3schools.com
                            . De waarden zijn dezelfde als eerder genoemd: start, end, center, stretch (en baseline voor
                            align-self in bepaalde gevallen).</p>
                        <p>Een paar scenario’s:</p>
                        <p>Je hebt justify-items: stretch algemeen, maar één bepaald item moet niet uitgerekt worden en
                            bijvoorbeeld links uitgelijnd zitten binnen zijn cel: dan zet je op dat item justify-self:
                            start.</p>
                        <p>Of algemeen alle items zijn gecentreerd, behalve eentje die je expliciet rechts wil
                            uitlijnen: justify-self: end op dat item.</p>
                        <pre><code>.item1 { justify-self: right; }  /* hetzelfde als 'end' – rechts uitlijnen in cel */
.item2 { justify-self: center; } /* horizontaal centreren in cel */
.item3 { align-self: start; }    /* verticaal aan de bovenkant van de cel */
.item4 { align-self: stretch; }  /* vul volledige celhoogte (als niet default) */
</code></pre>
                        <p>(Opmerking: In CSS spreken sommige documentaties over justify-self: left/right en align-self:
                            top/bottom als mogelijke keywords – dit zijn meestal aliasen/synoniemen in bepaalde
                            situaties, maar formeel zijn start/end de directionele termen die writing-mode onafhankelijk
                            zijn, en left/right zouden specifiek linken aan fysieke kanten. In de praktijk kun je
                            justify-self: left gebruiken en het werkt als start in een LTR-context. We houden het hier
                            op de formele alignmentkeywords.)</p>
                        <p>place-self: Dit is wederom de shorthand voor tegelijk align-self en justify-self instellen
                            w3schools.com
                            . Bijvoorbeeld place-self: center end; betekent align-self: center; justify-self: end; –
                            oftewel item gecentreerd verticaal in de cel, en uitgelijnd aan de rechterkant horizontaal.
                            place-self: stretch; zou beide assen laten stretchen. Eén opgegeven waarde geldt voor beide.
                        </p>
                        <p>Tot zover de positionering en alignment van grid-items.</p>
                        <h6>Overige overwegingen voor Grid</h6>
                        <p>Overlapping en stapelen: In een grid kunnen meerdere items dezelfde cel(len) overlappen,
                            bijvoorbeeld als je ze bewust op dezelfde start lijnen plaatst of er is simpelweg meer
                            content dan unieke cellen. In zo’n geval bepaalt de DOM-volgorde welke elementen bovenop
                            liggen: later in de HTML betekent hoger gestapeld (voorgrond) tenzij anders bepaald. Je kunt
                            dit beïnvloeden met de CSS z-index property op grid-items – hogere z-index komt boven lagere
                            developer.mozilla.org
                            . Dit lijkt op positionering, maar binnen een grid blijven items normaliter op hun eigen
                            plek. Overlap is dus iets dat je soms bewust doet voor effecten (zoals items laten
                            overlappen of een item laten uitspringen over andere). Gebruik z-index dan om te bepalen wat
                            voor of achter ligt.</p>
                        <p>Subgrids (geavanceerd): CSS Grid Level 2 introduceert het concept van subgrid. Hiermee kan
                            een grid-item dat zélf ook een grid-container is, de rij- en/of kolomdefinities van de ouder
                            overnemen (door grid-template-rows: subgrid; en/of grid-template-columns: subgrid; te
                            gebruiken in het child grid-container). Dit laat je bijvoorbeeld toe om nested grids te
                            maken waar kolommen mooi uitlijnen met het bovenliggende grid. Ondersteuning hiervoor is
                            anno 2025 aanwezig in moderne browsers (bijv. Firefox en recente Chrome/Edge). Voorbeeld van
                            gebruik:</p>
                        <pre><code>.parent {
  display: grid;
  grid-template-columns: 1fr 2fr;
  grid-template-rows: auto auto;
  gap: 10px;
}
.child-container {
  display: grid;
  grid-template-columns: subgrid; /* neemt 1fr 2fr over */
  grid-auto-rows: subgrid;       /* neem rijen van parent (2 rijen in dit geval) over als nodig */
}
</code></pre>
                        <p>In dit geval zou .child-container precies dezelfde kolombreedtes hanteren als de ouder, wat
                            handig kan zijn voor uitlijning van content.</p>
                        <p>Responsiviteit: Zowel Flexbox als Grid lenen zich erg goed voor responsive design. Met flex
                            kun je gemakkelijk items herschikken of laten wrappen; met grid kun je middels media queries
                            de grid-template definities aanpassen (bijvoorbeeld van 4 kolommen op desktop naar 2
                            kolommen op mobiel). Er zijn ook handige functies als minmax() en auto-fit/auto-fill in Grid
                            die responsieve grids mogelijk maken zonder veel media queries – bijvoorbeeld een regel als
                            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); creëert zoveel mogelijk
                            kolommen van minimaal 200px en maximaal gelijk verdeelde ruimte, waardoor het grid
                            automatisch minder kolommen maakt op kleinere schermen. Dit is echter gevorderd materiaal,
                            maar goed om te weten dat de mogelijkheden er zijn.</p>
                        <h6>Conclusie</h6>
                        <p>We hebben nu alle eigenschappen van CSS Flexbox en CSS Grid besproken die met layout te maken
                            hebben, inclusief hun gebruik en voorbeelden. Als beginnende ontwikkelaar heb je hiermee een
                            naslagwerk voorhanden:</p>
                        <p>Flexbox is ideaal voor een dimensionele uitlijning: gebruik flex-containereigenschappen
                            (zoals flex-direction, justify-content, align-items) om de globale lay-out te bepalen, en
                            flex-itemeigenschappen (order, flex, align-self) om individuele uitzonderingen of
                            verhoudingen in te stellen.</p>
                        <p>Grid is krachtig voor tweedimensionale layouts: je definieert rijen en kolommen
                            (grid-template-*, grid-auto-* eigenschappen) en kunt items precies positioneren
                            (grid-column, grid-row, eventueel grid-area namen) en uitlijnen (justify-self/align-self per
                            item of container-wide via justify-items/align-items).</p>
                        <p>Beide systemen kunnen ook gecombineerd worden – bijvoorbeeld grid voor de grote
                            pagina-indeling en flexbox binnen individuele grid-items voor uitlijning van onderdelen. Ze
                            lossen veel van de oude hacks (zoals tabellen misbruiken voor lay-out, of ingewikkeld
                            float-gedrag) op door declaratieve en leesbare CSS.</p>
                    </article>
                </details>
            </section>

            <section id="css-typography">
                <h3>Typografie & Tekst</h3>
                <ul>
                    <li><code>font-family</code>: Specificeert het lettertype.</li>
                    <li><code>font-size</code>: De grootte van de tekst (gebruik `rem` voor schaalbaarheid).</li>
                    <li><code>font-weight</code>: De dikte van de letters (bv. `400` voor normaal, `700` voor vet).</li>
                    <li><code>line-height</code>: De regelhoogte, voor betere leesbaarheid.</li>
                    <li><code>color</code>: De tekstkleur.</li>
                    <li><code>text-align</code>: Horizontale uitlijning (`left`, `center`, `right`).</li>
                    <li><code>text-decoration</code>: Onderlijning, doorhaling, etc.</li>
                </ul>
            </section>

            <section id="css-backgrounds">
                <h3>Achtergronden & Effecten</h3>
                <ul>
                    <li><code>background-color</code>: Een effen achtergrondkleur.</li>
                    <li><code>background-image</code>: Een afbeelding of gradient als achtergrond.</li>
                    <li><code>background-size</code>: Hoe de achtergrondafbeelding wordt geschaald (bv. `cover`,
                        `contain`).</li>
                    <li><code>background-position</code>: Positie van de achtergrondafbeelding.</li>
                    <li><code>border-radius</code>: Ronde hoeken.</li>
                    <li><code>box-shadow</code>: Een schaduw rondom een element.</li>
                    <li><code>filter</code>: Visuele effecten zoals `blur()` of `grayscale()`.</li>
                    <li><code>opacity</code>: De transparantie van een element.</li>
                </ul>
            </section>

            <section id="css-motion">
                <h3>Transities & Animaties</h3>
                <h4>Transities</h4>
                <p>Maakt een geleidelijke overgang van de ene staat naar de andere (bv. bij `:hover`).</p>
                <pre><code>.button {
    transition: background-color 0.3s ease;
}
.button:hover {
    background-color: blue;
}</code></pre>

                <h4>Animaties</h4>
                <p>Voor complexere, op keyframes gebaseerde animaties.</p>
                <pre><code>@keyframes fadeIn {
    from { opacity: 0; }
    to   { opacity: 1; }
}
.element {
    animation: fadeIn 1s ease-in-out;
}</code></pre>
            </section>

            <section id="css-responsive">
                <h3>Responsive Design</h3>
                <h4>Inleiding: Wat is Responsief Webdesign?</h4>
                <p>Responsief webdesign (responsive web design) is een aanpak waarbij je een website zo ontwikkelt dat
                    deze zich automatisch aanpast aan verschillende schermgroottes en apparaten (<a
                        href="https://developer.mozilla.org/" target="_blank"
                        rel="noopener noreferrer">developer.mozilla.org</a>, <a href="https://kinsta.com/"
                        target="_blank" rel="noopener noreferrer">kinsta.com</a>).</p>
                <p>In plaats van aparte “desktop-” en “mobiele” versies te bouwen, wordt dezelfde HTML-pagina door CSS
                    code zó gestyled dat de lay-out flexibel meebeweegt met de beschikbare schermruimte (<a
                        href="https://kinsta.com/" target="_blank" rel="noopener noreferrer">kinsta.com</a>).</p>
                <p>Het doel is dat de site er altijd goed uitziet en bruikbaar blijft – of iemand nu op een breed
                    computerscherm, tablet, laptop, of kleine smartphone kijkt (<a href="https://kinsta.com/"
                        target="_blank" rel="noopener noreferrer">kinsta.com</a>).</p>
                <p>Dit betekent bijvoorbeeld dat meerdere kolommen tekst op een breed desktop-scherm naast elkaar kunnen
                    staan, terwijl op een smal mobiel scherm diezelfde kolommen onder elkaar worden gestapeld voor
                    betere leesbaarheid (<a href="https://kinsta.com/" target="_blank"
                        rel="noopener noreferrer">kinsta.com</a>).</p>
                <p>Belangrijke pijlers van responsief ontwerp zijn onder andere: flexibele grids en lay-outs,
                    afbeeldingen en media die meeschalen, en CSS media queries om stijlregels conditioneel toe te passen
                    (<a href="https://medium.com/" target="_blank" rel="noopener noreferrer">medium.com</a>, <a
                        href="https://kinsta.com/" target="_blank" rel="noopener noreferrer">kinsta.com</a>).</p>
                <p>Deze gids behandelt alle relevante CSS-eigenschappen en technieken die je als beginnende ontwikkelaar
                    moet kennen om een website responsief te maken. We leggen elke eigenschap uit – met beschrijving,
                    gebruikstoepassing en korte codevoorbeelden – zodat je begrijpt wat ze doen en hoe je ze kunt
                    inzetten in de praktijk.</p>

                <h4>Mobiel-eerst ontwerpen en breakpoints</h4>
                <p>Een belangrijke strategie in responsief design is het “mobiel-eerst” ontwerpen. Dit houdt in dat je
                    je CSS begint met een ontwerp dat geoptimaliseerd is voor kleine schermen (mobiel), en vervolgens
                    stapsgewijs uitbreidt voor grotere schermen met behulp van media queries (<a
                        href="https://medium.com/" target="_blank" rel="noopener noreferrer">medium.com</a>).</p>
                <p>Door mobiel als uitgangspunt te nemen, zorg je ervoor dat de basisfunctionaliteit en content al goed
                    werkt op smartphones, die vaak het grootste deel van het verkeer uitmaken (meer dan 50% van alle
                    websitebezoeken is via mobiel). Daarna voeg je extra lay-out voor tablets en desktops toe. Dit
                    voorkomt dat mobiele gebruikers overladen worden met een te complexe desktop-layout, en zorgt dat de
                    site progressief verbetert op grotere schermen (<a href="https://medium.com/" target="_blank"
                        rel="noopener noreferrer">medium.com</a>, <a href="https://kinsta.com/" target="_blank"
                        rel="noopener noreferrer">kinsta.com</a>).</p>
                <p><strong>Breakpoints</strong> zijn de schermbreedtes waarop je layout verandert. Je bepaalt bij welke
                    breedtes je een andere weergave nodig hebt – bijvoorbeeld twee kolommen in plaats van één – en
                    schrijft op die “breekpunten” CSS-regels binnen media queries (<a href="https://kinsta.com/"
                        target="_blank" rel="noopener noreferrer">kinsta.com</a>). Veel frameworks (zoals Bootstrap)
                    hanteren standaard breakpoints (bv. 576px, 768px, 992px, 1200px voor respectievelijk telefoons,
                    tablets, laptops en desktops) (<a href="https://kinsta.com/" target="_blank"
                        rel="noopener noreferrer">kinsta.com</a>). Je kunt deze overnemen of eigen breekpunten kiezen
                    die passen bij jouw ontwerp. Advies: baseer breakpoints op de inhoud (wanneer de lay-out breekt),
                    niet enkel op specifieke toestelmodellen. In een eenvoudige mobiele-eerst aanpak volstaan vaak twee
                    hoofd-breakpoints – één voor tablet en één voor desktop – bovenop de mobiele basisstijl (<a
                        href="https://kinsta.com/" target="_blank" rel="noopener noreferrer">kinsta.com</a>).</p>

                <h5>Voorbeeld – mobiel-eerst CSS met breakpoints</h5>
                <p>Stel je hebt een layout met een sidebar. Je basis (mobiel) toont alles gestapeld in één kolom.
                    Vervolgens gebruik je media queries om vanaf bredere schermen (bijvoorbeeld min-width 768px) de
                    sidebar naast de content te zetten:</p>
                <pre><code>/* Basis: mobiele stijl, 100% breedte kolommen */
#content { width: 100%; }
#sidebar { width: 100%; }

/* Bij tablets en groter (min breedte 768px): twee kolommen */
@media (min-width: 768px) {
  #content { width: 70%; float: left; }
  #sidebar { width: 30%; float: right; }
}

/* Bij desktops en groter (min breedte 992px): layout evt. weer aanpassen */
@media (min-width: 992px) {
  /* ... */
}</code></pre>
                <p>In bovenstaand voorbeeld staat de sidebar onderaan op mobiel (100% breedte), en pas boven 768px
                    schermbreedte verschijnt hij rechts naast de content (met CSS float voor een traditionele layout).
                    Moderne aanpakken gebruiken meestal Flexbox of Grid in plaats van floats; die behandelen we hierna.
                </p>

                <h5>Live voorbeeld – mobiel-eerst (Flexbox)</h5>
                <style>
                    .mobile-first-demo {
                        border: 1px solid var(--border-color, #ddd);
                        border-radius: 8px;
                        padding: 12px;
                        background: var(--card-bg, #0f172a0d);
                        margin-bottom: 12px;
                    }

                    .mobile-first-demo .demo-wrap {
                        display: block;
                        /* mobiel-eerst: gestapeld */
                    }

                    .mobile-first-demo .demo-content,
                    .mobile-first-demo .demo-sidebar {
                        box-sizing: border-box;
                        width: 100%;
                        padding: 12px;
                        margin: 4px 0;
                        border-radius: 6px;
                    }

                    .mobile-first-demo .demo-content {
                        background: #e0f2fe;
                        /* licht blauw */
                    }

                    .mobile-first-demo .demo-sidebar {
                        background: #fee2e2;
                        /* licht rood */
                    }

                    /* Tablet en groter: twee kolommen (70% / 30%) */
                    @media (min-width: 768px) {
                        .mobile-first-demo .demo-wrap {
                            display: flex;
                            gap: 12px;
                        }

                        .mobile-first-demo .demo-content {
                            flex: 0 0 70%;
                        }

                        .mobile-first-demo .demo-sidebar {
                            flex: 0 0 30%;
                        }
                    }

                    /* Desktop en groter: optioneel kleine tweaks */
                    @media (min-width: 992px) {
                        .mobile-first-demo {
                            padding: 16px;
                        }
                    }
                </style>
                <div class="mobile-first-demo">
                    <div class="demo-wrap">
                        <div class="demo-content">
                            <strong>Content</strong>
                            <p>Dit is de hoofdinhoud. Op mobiel staat dit blok bovenaan en neemt 100% breedte in.
                                Vergroot het venster om te zien hoe de layout twee kolommen wordt.</p>
                        </div>
                        <div class="demo-sidebar">
                            <strong>Sidebar</strong>
                            <p>Dit is de sidebar. Op mobiel staat deze onder de content. Vanaf 768px staat hij rechts
                                naast de content.</p>
                        </div>
                    </div>
                </div>

                <h4>CSS-eenheden en dimensies voor responsiviteit</h4>
                <p>Om elementen soepel te laten schalen, is het kiezen van de juiste CSS-eenheden cruciaal. In CSS kun
                    je absolute eenheden (zoals px, cm, in) of relatieve eenheden (zoals %, em, rem, vw/vh) gebruiken.
                    Absolute eenheden zijn vaste maten – bijv. een element van 300px blijft altijd 300 pixels breed
                    ongeacht schermgrootte. Dit is niet ideaal voor responsieve ontwerpen, want op een klein scherm zou
                    300px misschien het hele scherm overschrijden. Daarom worden absolute eenheden als cm/inch niet
                    aanbevolen voor schermgebruik (<a href="https://www.w3schools.com/" target="_blank"
                        rel="noopener noreferrer">w3schools.com</a>).</p>
                <p>Relatieve eenheden passen zich aan op basis van een andere referentie, waardoor ze beter schalen
                    tussen apparaten (<a href="https://www.w3schools.com/" target="_blank"
                        rel="noopener noreferrer">w3schools.com</a>). De belangrijkste voor responsive design zijn:</p>
                <ul>
                    <li><strong>Procenten (%)</strong> – Relatief ten opzichte van het parent-element. Bijvoorbeeld
                        <code>width: 50%</code> geeft een element dat de helft van de beschikbare breedte inneemt.
                        Procenten zijn handig om flexibele kolombreedtes te maken die mee stretchen met hun container.
                    </li>
                    <li><strong>Viewport-eenheden (vw, vh, vmin, vmax)</strong> – Relatief aan de afmetingen van het
                        browservenster (viewport). <code>1vw</code> is 1% van de viewport-breedte, <code>1vh</code> is
                        1% van de hoogte (<a href="https://www.w3schools.com/" target="_blank"
                            rel="noopener noreferrer">w3schools.com</a>). Bijvoorbeeld, <code>width: 80vw</code> geeft
                        een element dat 80% van de schermbreedte opvult (<a href="https://medium.com/" target="_blank"
                            rel="noopener noreferrer">medium.com</a>). <code>vmin</code> is 1% van de kleinste zijde,
                        <code>vmax</code> van de grootste zijde.
                    </li>
                    <li><strong>Lettergrootte-relatieve eenheden (em, rem)</strong> – <code>em</code> is relatief ten
                        opzichte van de lettergrootte van het element zelf (of van de parent als <code>font-size</code>
                        niet expliciet is gezet), <code>rem</code> is relatief ten opzichte van de root (HTML)
                        <code>font-size</code> (<a href="https://www.w3schools.com/" target="_blank"
                            rel="noopener noreferrer">w3schools.com</a>). Bijvoorbeeld, <code>font-size: 1.2em</code>
                        betekent 1.2× de huidige font-size (<a href="https://medium.com/" target="_blank"
                            rel="noopener noreferrer">medium.com</a>). Deze eenheden worden veel gebruikt voor
                        responsieve typografie zodat tekstgroottes mee schalen.
                    </li>
                </ul>
                <p>(Ter info: <code>em</code> werkt ook voor andere afmetingen dan tekst – bijvoorbeeld
                    <code>margin: 2em</code> betekent marge ter grootte van 2× de huidige font-size. Dit kan nuttig zijn
                    om verticale ritmes te behouden bij schaalbare tekst.)
                </p>

                <p>Een goed praktijkvoorbeeld is het gebruik van <code>rem</code>/<code>em</code>-eenheden voor fonts en
                    margins, en <code>%</code> of <code>vw/vh</code> voor blokken. Bijvoorbeeld:</p>
                <pre><code>.container {
  width: 90%;       /* Neem 90% van de beschikbare breedte */
  padding: 1em;     /* Padding schaalbaar met tekstgrootte */
  font-size: 1.1rem;/* Iets grotere tekst relatief tot root font */
}</code></pre>
                <p>Hier zal <code>.container</code> op elk scherm 90% van de breedte pakken, ongeacht px-afmeting, en de
                    padding zal meegroeien als de tekstgrootte groeit. Pro tip: combineer geen absolute pixelwaarden met
                    responsive containers als het niet nodig is. Gebruik <code>min-width</code>/<code>max-width</code>
                    in plaats van vaste <code>width</code>s om grenzen te stellen.</p>

                <h5>Minimale en maximale afmetingen</h5>
                <p>Met <code>min-width</code> en <code>max-width</code> kun je onder- en bovengrenzen instellen voor de
                    grootte van elementen. De eigenschap <code>min-width</code> zorgt ervoor dat een element niet
                    smaller wordt dan de opgegeven waarde – het voorkomt dat de breedte onder dat minimum zakt (<a
                        href="https://developer.mozilla.org/" target="_blank"
                        rel="noopener noreferrer">developer.mozilla.org</a>). Omgekeerd limiteert <code>max-width</code>
                    de maximale breedte. In een responsive context is <code>max-width: 100%</code> erg bruikbaar:
                    daarmee zeg je dat een element (bv. een afbeelding of container) maximaal de volledige breedte van
                    zijn container mag innemen, en niet groter wordt dan dat (het voorkomt uitrekken buiten de viewport)
                    (<a href="https://www.w3schools.com/" target="_blank" rel="noopener noreferrer">w3schools.com</a>).
                </p>

                <h5>Voorbeeld – % vs px</h5>
                <p>Stel je maakt twee divs, één met een vaste breedte in pixels en één met percentage:</p>
                <pre><code>&lt;div class="fixed"&gt;Vaste breedte&lt;/div&gt;
&lt;div class="fluid"&gt;Vloeiende breedte&lt;/div&gt;

&lt;style&gt;
.fixed { width: 300px; background: lightblue; }
.fluid { width: 50%; background: lightgreen; }
&lt;/style&gt;</code></pre>
                <p>Op een breed scherm zie je wellicht beide blokken naast elkaar. Maar op een smal mobiel scherm zal
                    <code>.fixed</code> nog steeds 300px breed zijn (mogelijk horizontaal scrollen veroorzaken), terwijl
                    <code>.fluid</code> netjes halve breedte van het scherm blijft. Dit illustreert waarom fluid units
                    de voorkeur hebben voor responsiviteit.
                </p>

                <p><strong>Absolute units vermijden:</strong> Met uitzondering van CSS die specifiek fysiek formaat
                    nastreeft (zoals printmedia), gebruik je in responsive webdesign bij voorkeur geen absolute
                    cm/inch/mm. Pixels (<code>px</code>) zijn op schermen relatief (door verschillende
                    pixel-dichtheden), maar gedragen zich vaak als vaste waarden. Voor echt flexibel design zijn
                    <code>%</code>, viewport en font-relatieve units dus onmisbaar.
                </p>

                <h5>Live voorbeeld – % vs px</h5>
                <style>
                    .units-demo {
                        border: 1px solid var(--border-color, #ddd);
                        border-radius: 8px;
                        padding: 12px;
                        background: var(--card-bg, #0f172a0d);
                        margin-bottom: 12px;
                    }

                    .units-demo .demo-row {
                        display: flex;
                        flex-wrap: wrap;
                        gap: 12px;
                    }

                    .units-demo .fixed,
                    .units-demo .fluid {
                        padding: 12px;
                        border-radius: 6px;
                        box-sizing: border-box;
                        color: #0b1220;
                        font-weight: 600;
                        text-align: center;
                    }

                    .units-demo .fixed {
                        width: 300px;
                        background: #bfdbfe;
                    }

                    .units-demo .fluid {
                        width: 50%;
                        background: #bbf7d0;
                    }

                    @media (max-width: 360px) {
                        .units-demo .fixed {
                            background: #fecaca;
                        }
                    }
                </style>
                <div class="units-demo">
                    <div class="demo-row">
                        <div class="fixed">Vaste 300px</div>
                        <div class="fluid">Vloeiende 50%</div>
                    </div>
                    <p style="margin-top:8px">Versmal het venster: de vaste 300px kan horizontaal scrollen veroorzaken
                        op kleine schermen, terwijl 50% zich aanpast.</p>
                </div>

                <h4>Flexibele lay-outs met CSS Flexbox</h4>
                <p><strong>CSS Flexbox</strong> (Flexible Box Layout) is een modern layoutmodel dat ideaal is voor
                    responsief design. Flexbox maakt het gemakkelijk om elementen in een rij of kolom te plaatsen die
                    mee schalen, centreren en uitlijnen op verschillende schermgroottes (<a
                        href="https://developer.mozilla.org/docs/Web/CSS/CSS_flexible_box_layout/Basic_concepts_of_flexbox"
                        target="_blank" rel="noopener noreferrer">developer.mozilla.org</a>).</p>
                <p>Het model is <em>één-dimensionaal</em>: je rangschikt items in één richting (horizontaal of
                    verticaal), maar daarmee los je veel voorkomende responsive layouts op, zoals navigatiebalken,
                    kaartroosters die herschikken, en content die netjes centreert. Een element wordt een
                    <em>flex-container</em> door <code>display: flex</code> te geven (<a
                        href="https://www.w3schools.com/css/css3_flexbox.asp" target="_blank"
                        rel="noopener noreferrer">w3schools.com</a>). De directe kinderen daarvan worden
                    <em>flex-items</em>.
                </p>

                <h5>Belangrijkste flex-container eigenschappen</h5>
                <ul>
                    <li><strong>flex-direction</strong> – Richting van de hoofd-as: <code>row</code> (horizontaal,
                        default), <code>column</code> (verticaal). Voor mobiel is <code>column</code> handig om items te
                        stapelen. Ook <code>row-reverse</code>/<code>column-reverse</code> bestaan (<a
                            href="https://www.w3schools.com/cssref/css3_pr_flex-direction.php" target="_blank"
                            rel="noopener noreferrer">w3schools.com</a>).</li>
                    <li><strong>flex-wrap</strong> – Of items mogen doorlopen naar de volgende regel. Vaak
                        <code>wrap</code> zetten voor responsiviteit, zodat de layout niet breekt als er te weinig
                        ruimte is (<a href="https://www.w3schools.com/cssref/css3_pr_flex-wrap.php" target="_blank"
                            rel="noopener noreferrer">w3schools.com</a>).
                    </li>
                    <li><strong>justify-content</strong> – Uitlijning langs de hoofd-as: <code>flex-start</code>,
                        <code>center</code>, <code>flex-end</code>, <code>space-between</code>,
                        <code>space-around</code>, <code>space-evenly</code> (<a
                            href="https://www.w3schools.com/cssref/css3_pr_justify-content.php" target="_blank"
                            rel="noopener noreferrer">w3schools.com</a>).
                    </li>
                    <li><strong>align-items</strong> – Uitlijning op de kruis-as: <code>stretch</code> (default),
                        <code>center</code>, <code>flex-start</code>, <code>flex-end</code> (verticale uitlijning bij
                        een rij).
                    </li>
                    <li><strong>gap</strong> – Ruimte tussen flex-items zonder marges. Werkt ook als items wrappen.</li>
                </ul>

                <h5>Voorbeeld – flex-container in actie (wrap &amp; centreren)</h5>
                <p>Een rij van kaartjes die op desktop naast elkaar mogen, maar op mobiel netjes afbreken:</p>
                <pre><code>&lt;div class="cards"&gt;
  &lt;div class="card"&gt;Card 1&lt;/div&gt;
  &lt;div class="card"&gt;Card 2&lt;/div&gt;
  &lt;div class="card"&gt;Card 3&lt;/div&gt;
  &lt;div class="card"&gt;Card 4&lt;/div&gt;
&lt;/div&gt;

&lt;style&gt;
.cards {
  display: flex;
  flex-wrap: wrap;            /* laat kaarten naar volgende regel gaan indien nodig */
  justify-content: space-between; /* verdeel ruimte op een rij */
  align-items: center;        /* centreer verticaal indien hoogteverschil */
  gap: 1rem;                  /* ruimte tussen kaarten */
}
.card {
  flex: 1 1 200px;            /* mag groeien/krimpen, basis 200px */
  background: #eee;
  padding: 20px;
}
&lt;/style&gt;</code></pre>
                <p>Dankzij <code>flex-wrap: wrap</code> komen kaarten automatisch op een nieuwe regel als er te weinig
                    ruimte is. <code>justify-content: space-between</code> spreidt de items per rij.</p>

                <h5>Live voorbeeld – Flexbox kaarten</h5>
                <style>
                    .flex-cards-demo {
                        border: 1px solid var(--border-color, #ddd);
                        border-radius: 8px;
                        padding: 12px;
                        background: var(--card-bg, #0f172a0d);
                        margin-bottom: 12px;
                    }

                    .flex-cards-demo .cards {
                        display: flex;
                        flex-wrap: wrap;
                        justify-content: space-between;
                        align-items: center;
                        gap: 12px;
                    }

                    .flex-cards-demo .card {
                        flex: 1 1 200px;
                        padding: 16px;
                        border-radius: 6px;
                        background: #e5e7eb;
                        text-align: center;
                        font-weight: 600;
                        color: #0b1220;
                    }
                </style>
                <div class="flex-cards-demo">
                    <div class="cards">
                        <div class="card">Card 1</div>
                        <div class="card">Card 2</div>
                        <div class="card">Card 3</div>
                        <div class="card">Card 4</div>
                    </div>
                </div>

                <h5>Belangrijkste flex-item eigenschappen</h5>
                <ul>
                    <li><strong>flex</strong> (shorthand) – <code>flex-grow</code>, <code>flex-shrink</code>,
                        <code>flex-basis</code>. Bijvoorbeeld <code>flex: 1 1 200px</code> laat items gelijk
                        groeien/krimpen rond ~200px basis (<a href="https://developer.mozilla.org/docs/Web/CSS/flex"
                            target="_blank" rel="noopener noreferrer">developer.mozilla.org</a>).
                    </li>
                    <li><strong>flex-basis</strong> – Uitgangsmaat (px, %, enz.). <strong>flex-grow</strong> –
                        groeifactor. <strong>flex-shrink</strong> – krimpfactor (hoe items kleiner worden bij te weinig
                        ruimte).</li>
                    <li><strong>align-self</strong> – Overschrijft de uitlijning voor één item t.o.v.
                        <code>align-items</code>.
                    </li>
                    <li><strong>order</strong> – Wijzigt de visuele volgorde van items zonder HTML te veranderen (let op
                        toegankelijkheid).</li>
                </ul>

                <h5>Voorbeeld – menu met flexbox (rij → kolom via media query)</h5>
                <pre><code>.navbar {
  display: flex;
  justify-content: center;
  background: #333;
}
.navbar a {
  color: white;
  padding: 10px 20px;
  text-decoration: none;
}

/* Desktop: menu items in één rij */
.navbar { flex-direction: row; }

/* Mobiel: menu items onder elkaar */
@media (max-width: 600px) {
  .navbar { flex-direction: column; align-items: stretch; }
}</code></pre>

                <p>Op brede schermen staan de links in één rij (gecentreerd). Onder 600px schakelt de navigatie naar een
                    kolom, ideaal voor touch en leesbaarheid.</p>

                <h4>Flexibele lay-outs met CSS Grid</h4>
                <p>Waar flexbox één-dimensionaal is, biedt <strong>CSS Grid Layout</strong> een twee-dimensionaal
                    rastermodel (<a href="https://developer.mozilla.org/docs/Web/CSS/CSS_grid_layout" target="_blank"
                        rel="noopener noreferrer">developer.mozilla.org</a>). Met grid kun je kolommen én rijen tegelijk
                    beheren, wat het geschikt maakt voor complexere pagina-layouts. Grid is zeer waardevol voor
                    responsief design: met functies als <code>auto-fit</code>/<code>auto-fill</code> en
                    <code>minmax()</code> kun je zonder veel media queries automatisch meer kolommen tonen op grote
                    schermen en minder op kleine.
                </p>

                <h5>Belangrijkste grid-container eigenschappen voor responsiviteit</h5>
                <ul>
                    <li><strong>display: grid</strong> – maakt een grid-container; directe kinderen worden grid-items.
                    </li>
                    <li><strong>grid-template-columns</strong> – bepaalt aantal en breedte van kolommen. Een krachtige
                        responsieve techniek is <code>repeat(auto-fill, minmax(200px, 1fr))</code>: maak zoveel mogelijk
                        kolommen met minimaal 200px, en verdeel de resterende ruimte gelijk (<a
                            href="https://gridbyexample.com/" target="_blank"
                            rel="noopener noreferrer">gridbyexample.com</a>).</li>
                    <li><strong>gap</strong> – ruimte tussen grid-cellen (horizontaal en verticaal).</li>
                </ul>

                <h5>Voorbeeld – automatisch kolommen aanpassen met minmax()</h5>
                <p>Galerij waarbij items minimaal 150px breed zijn en verder de rij opvullen:</p>
                <pre><code>.gallery {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
  gap: 10px;
}</code></pre>
                <p>Met deze regel plaatst <code>.gallery</code> zoveel mogelijk kolommen naast elkaar, elk minimaal
                    150px breed. Op brede schermen passen meer kolommen; op smallere schermen minder – meestal zonder
                    extra breakpoints (<a href="https://gridbyexample.com/" target="_blank"
                        rel="noopener noreferrer">gridbyexample.com</a>).</p>
                <p>Deze enkele regel zorgt ervoor dat <code>.gallery</code> op elk scherm zoveel mogelijk kolommen zet
                    met
                    een minimale breedte van 150px en verder de kolombreedtes laat groeien tot ze de volledige
                    rijbreedte opvullen (dankzij <code>1fr</code> als maximum) (<a href="https://gridbyexample.com/"
                        target="_blank" rel="noopener noreferrer">gridbyexample.com</a>). Op een breed scherm zie je
                    misschien 6 kolommen naast elkaar, op een smaller 3, op mobiel misschien 1 of 2 – zonder dat je
                    expliciete breakpoints hoefde te schrijven. De eigenschap <code>minmax()</code> zorgt dat kolommen
                    nooit kleiner worden dan 150px (anders zouden items te klein worden om inhoud nog netjes te tonen)
                    (<a href="https://gridbyexample.com/" target="_blank"
                        rel="noopener noreferrer">gridbyexample.com</a>).
                </p>
                <p><strong>grid-template-rows</strong> – Vergelijkbaar met <em>columns</em> kun je rijen definiëren.
                    Vaak kun je rijen automatisch laten meegroeien door hun hoogte te laten afhangen van de inhoud
                    (bijvoorbeeld niet expliciet zetten, dan komen rijen automatisch zo hoog als nodig). In responsief
                    design is het minder gebruikelijk om vaste rijen te definiëren; hoogtes zijn meestal flexibeler,
                    behalve soms voor hero-secties o.i.d.</p>
                <p><strong>grid-template-areas</strong> – Hiermee kun je een layout beschrijven met naamgebieden en met
                    <code>grid-area</code> op items specifieke posities toewijzen. Dit is handig om bijvoorbeeld op
                    desktop een header naast sidebar boven content te plaatsen, en op mobiel met een media query die
                    gebieden te herordenen (met een <code>grid-template-areas</code>-definitie die alles onder elkaar
                    plaatst). Hiermee kun je blokken schuiven zonder de HTML-volgorde te wijzigen, puur via CSS layout.
                </p>
                <p><strong>Uitlijning in grid</strong>: je hebt ook <code>justify-items</code>, <code>align-items</code>
                    voor interne uitlijning binnen cellen, en <code>justify-content</code>, <code>align-content</code>
                    voor uitlijning van het grid als geheel binnen de container (als bijvoorbeeld de totale grid smaller
                    is dan de container). In responsive context zul je soms willen centreren of spreiden; bijvoorbeeld
                    een centraal blok precies in het midden zetten met <code>display: grid; place-items: center;</code>
                    (handige shorthand om zowel horizontaal als verticaal te centreren voor één item).</p>

                <h5>Live voorbeeld – Grid galerij</h5>
                <style>
                    .grid-gallery-demo {
                        border: 1px solid var(--border-color, #ddd);
                        border-radius: 8px;
                        padding: 12px;
                        background: var(--card-bg, #0f172a0d);
                        margin-bottom: 12px;
                    }

                    .grid-gallery-demo .gallery {
                        display: grid;
                        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                        gap: 10px;
                    }

                    .grid-gallery-demo .item {
                        aspect-ratio: 1 / 1;
                        border-radius: 6px;
                        background: linear-gradient(135deg, #93c5fd, #c7d2fe);
                        display: grid;
                        place-items: center;
                        color: #0b1220;
                        font-weight: 700;
                    }
                </style>
                <div class="grid-gallery-demo">
                    <div class="gallery">
                        <div class="item">1</div>
                        <div class="item">2</div>
                        <div class="item">3</div>
                        <div class="item">4</div>
                        <div class="item">5</div>
                        <div class="item">6</div>
                        <div class="item">7</div>
                        <div class="item">8</div>
                    </div>
                </div>

                <h5>Responsieve grid met media queries</h5>
                <p>Je kunt grid-definities per schermgrootte wijzigen. Bijvoorbeeld: 1 kolom op mobiel, 2 op tablet, 4
                    op desktop.</p>
                <pre><code>.grid-responsive {
  display: grid;
  grid-template-columns: 1fr; /* mobiel */
  gap: 16px;
}
@media (min-width: 600px) {
  .grid-responsive { grid-template-columns: 1fr 1fr; }
}
@media (min-width: 1024px) {
  .grid-responsive { grid-template-columns: repeat(4, 1fr); }
}</code></pre>

                <p>Stel een typische pagina met <em>header</em>, <em>nav</em>, <em>main</em> content en <em>footer</em>.
                    Op breed scherm wil je <em>nav</em> links als sidebar (2-koloms layout), op mobiel staat
                    <em>nav</em>
                    boven of onder de content (1-kolom). Met CSS Grid los je dit elegant op met media queries.
                </p>

                <h6>Live voorbeeld – pagina layout (grid-template-areas + media query)</h6>
                <style>
                    .grid-areas-demo {
                        display: grid;
                        grid-template-areas:
                            "header header"
                            "nav    main"
                            "footer footer";
                        grid-template-columns: 200px 1fr;
                        grid-template-rows: auto 1fr auto;
                        gap: 10px;
                        border: 1px solid var(--border-color, #ddd);
                        border-radius: 8px;
                        padding: 12px;
                        background: var(--card-bg, #0f172a0d);
                        margin-bottom: 12px;
                    }

                    .grid-areas-demo header,
                    .grid-areas-demo nav,
                    .grid-areas-demo main,
                    .grid-areas-demo footer {
                        border-radius: 6px;
                        padding: 10px;
                        color: #0b1220;
                        font-weight: 700;
                        text-align: center;
                    }

                    .grid-areas-demo header {
                        grid-area: header;
                        background: #bae6fd;
                    }

                    .grid-areas-demo nav {
                        grid-area: nav;
                        background: #ddd6fe;
                    }

                    .grid-areas-demo main {
                        grid-area: main;
                        background: #bbf7d0;
                        min-height: 80px;
                    }

                    .grid-areas-demo footer {
                        grid-area: footer;
                        background: #fecaca;
                    }

                    @media (max-width: 600px) {
                        .grid-areas-demo {
                            grid-template-areas:
                                "header"
                                "nav"
                                "main"
                                "footer";
                            grid-template-columns: 1fr;
                        }
                    }
                </style>
                <div class="grid-areas-demo">
                    <header>Header</header>
                    <nav>Nav (sidebar)</nav>
                    <main>Main</main>
                    <footer>Footer</footer>
                </div>

                <p>In dit voorbeeld geven we met <code>grid-template-areas</code> namen aan posities en plaatsen we op
                    desktop <em>nav</em> naast <em>main</em>. Op mobiel herschrijven we de areas onder elkaar en
                    schakelen
                    we naar één kolom. De HTML hoeft niet te veranderen; CSS bepaalt de layout per schermgrootte.</p>

                <p><em>Grid vs Flexbox voor responsiviteit:</em> veel layouts zijn met beide te maken. Gebruik grid voor
                    grotere, twee-dimensionale pagina-structuren (bijv. een galerij of pagina-layout) en flexbox voor
                    componenten en lijn-gebaseerde aanpassingen (bijv. navbalk of knoppenrij). In de praktijk combineer
                    je
                    ze vaak in één pagina (<a href="https://kinsta.com/" target="_blank"
                        rel="noopener noreferrer">kinsta.com</a>).</p>

                <h5>Grid-template-areas (herordenen zonder HTML te wijzigen)</h5>
                <p>Met <code>grid-template-areas</code> kun je gebieden benoemen en per breakpoint herschikken.</p>
                <pre><code>.container {
  display: grid;
  grid-template-areas:
    "header header"
    "nav    main"
    "footer footer";
  grid-template-columns: 200px 1fr;
  grid-template-rows: auto 1fr auto;
}
header { grid-area: header; }
nav    { grid-area: nav; }
main   { grid-area: main; }
footer { grid-area: footer; }

/* Op mobiel (max 600px) 1 kolom layout */
@media (max-width: 600px) {
  .container {
    grid-template-areas:
      "header"
      "nav"
      "main"
      "footer";
    grid-template-columns: 1fr;
  }
}</code></pre>

                <h5>Uitlijning in grid</h5>
                <p>Gebruik <code>justify-items</code>/<code>align-items</code> voor uitlijning binnen cellen, en
                    <code>justify-content</code>/<code>align-content</code> voor het grid als geheel. Een handige
                    shorthand om één element te centreren is <code>display: grid; place-items: center;</code>.
                </p>

                <p><em>Grid vs Flexbox voor responsiviteit:</em> Gebruik grid voor grotere pagina-structuren en complexe
                    roosters (tweede dimensie), en flexbox voor component-level lijnafstemming. Vaak combineer je beide
                    in dezelfde pagina (<a href="https://kinsta.com/" target="_blank"
                        rel="noopener noreferrer">kinsta.com</a>).</p>

                <h4>Responsieve afbeeldingen en media</h4>
                <p>Afbeeldingen en media (zoals video’s) vormen een belangrijk aspect van responsief design. Grote,
                    vaste
                    afbeeldingen kunnen op mobiele schermen voor problemen zorgen (uitzoomen of scrollen nodig, of ze
                    laden onnodig veel data). CSS biedt technieken om afbeeldingen flexibel te laten schalen en hun
                    weergave aan te passen, net zoals we dat met layout-elementen doen.</p>

                <h5>Voorbeeld – fluïde afbeeldingen met max-width</h5>
                <p>De meest gebruikte CSS-regel voor responsieve afbeeldingen:</p>
                <pre><code>img {
  max-width: 100%;
  height: auto;
}</code></pre>
                <p>Met <code>max-width: 100%</code> zorg je dat een afbeelding nooit breder wordt dan de container
                    waarin
                    hij zit (<a href="https://www.w3schools.com/" target="_blank"
                        rel="noopener noreferrer">w3schools.com</a>).
                    Daardoor zal op een klein scherm de afbeelding vanzelf kleiner renderen (schalen), in plaats van dat
                    hij uit de container loopt (overflow) of dat je horizontaal moet scrollen. <code>height: auto</code>
                    zorgt ervoor dat de hoogte proportioneel meeverandert zodat de afbeelding zijn aspect ratio behoudt
                    en niet uitgerekt raakt (<a href="https://medium.com/" target="_blank"
                        rel="noopener noreferrer">medium.com</a>). Dit stukje CSS is praktisch standaard in elke
                    responsive site om afbeeldingen vloeiend te maken.</p>
                <p><strong>Verschil <code>width:100%</code> vs <code>max-width:100%</code>:</strong> Als je
                    <code>width: 100%</code> op een afbeelding zet, zal hij altijd gerekt of verkleind worden tot de
                    breedte van de container, zelfs als de container groter is dan de eigen resolutie van de afbeelding.
                    Met <code>max-width:100%</code> laten we de afbeelding kleiner worden indien nodig, maar nooit
                    groter
                    opschalen dan zijn eigen pixels (de afbeelding wordt niet wazig opgeblazen) (<a
                        href="https://www.w3schools.com/" target="_blank" rel="noopener noreferrer">w3schools.com</a>).
                    In de praktijk is <code>max-width</code> meestal beter, tenzij je een afbeelding bewust wilt laten
                    uitrekken.
                </p>

                <h6>Extra: achtergrondafbeeldingen responsief schalen</h6>
                <p>Als je afbeeldingen via CSS als achtergrond hebt, gebruik <code>background-size</code> om te schalen:
                </p>
                <ul>
                    <li><strong>background-size: cover</strong> – vult de container en behoudt verhouding; delen kunnen
                        worden afgesneden (<a href="https://www.w3schools.com/" target="_blank"
                            rel="noopener noreferrer">w3schools.com</a>, <a href="https://www.w3schools.com/"
                            target="_blank" rel="noopener noreferrer">w3schools.com</a>). Dit is handig voor
                        beeldvullende hero-banners.</li>
                    <li><strong>background-size: contain</strong> – past volledig binnen de container met behoud van
                        verhouding; randen kunnen blijven (<a href="https://www.w3schools.com/" target="_blank"
                            rel="noopener noreferrer">w3schools.com</a>, <a href="https://www.w3schools.com/"
                            target="_blank" rel="noopener noreferrer">w3schools.com</a>).</li>
                    <li><strong>background-size: 100% 100%</strong> – rekt exact naar container (kan vervormen; meestal
                        onwenselijk) (<a href="https://www.w3schools.com/" target="_blank"
                            rel="noopener noreferrer">w3schools.com</a>, <a href="https://www.w3schools.com/"
                            target="_blank" rel="noopener noreferrer">w3schools.com</a>).</li>
                </ul>

                <h6>Extra: object-fit voor media-elementen</h6>
                <p><code>object-fit</code> voor <code>&lt;img&gt;</code>/<code>&lt;video&gt;</code> geeft een
                    vergelijkbaar
                    effect als <em>cover/contain</em> en bepaalt hoe de inhoud binnen de omhullende afmetingen past (<a
                        href="https://www.w3schools.com/" target="_blank" rel="noopener noreferrer">w3schools.com</a>).
                    Veelvoorkomende waarden: <code>cover</code>, <code>contain</code>, <code>fill</code> (default),
                    <code>none</code>, <code>scale-down</code>. Hiermee kun je bijvoorbeeld een <code>&lt;img&gt;</code>
                    in een vierkante thumbnail-container centreren en bijsnijden zonder aparte background-divs.
                </p>
                <style>
                    .media-fluid-demo {
                        border: 1px solid var(--border-color, #ddd);
                        border-radius: 8px;
                        padding: 12px;
                        background: var(--card-bg, #0f172a0d);
                        margin-bottom: 12px;
                        max-width: 520px;
                    }

                    .media-fluid-demo img {
                        max-width: 100%;
                        height: auto;
                        display: block;
                        border-radius: 6px;
                    }
                </style>
                <div class="media-fluid-demo">
                    <img src="../Images/PixelToCode.png" alt="Voorbeeldafbeelding (fluïde)">
                    <p style="margin-top:8px">Versmal het venster: de afbeelding schaalt proportioneel mee en loopt niet
                        uit de container.</p>
                </div>

                <h5>Voorbeeld – background-size: cover vs contain</h5>
                <p>Voor achtergrondafbeeldingen kun je <code>background-size</code> gebruiken:</p>
                <ul>
                    <li><code>cover</code>: vult de container volledig, behoudt verhouding; kan afsnijden (<a
                            href="https://www.w3schools.com/" target="_blank"
                            rel="noopener noreferrer">w3schools.com</a>).</li>
                    <li><code>contain</code>: past volledig in de container, behoudt verhouding; kan randen overlaten
                        (<a href="https://www.w3schools.com/" target="_blank"
                            rel="noopener noreferrer">w3schools.com</a>).</li>
                </ul>
                <pre><code>.hero-cover   { background-size: cover; }
.hero-contain { background-size: contain; background-repeat: no-repeat; background-position: center; }</code></pre>
                <style>
                    .bg-size-demo {
                        display: grid;
                        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
                        gap: 12px;
                        margin-bottom: 12px;
                    }

                    .bg-size-demo .hero {
                        height: 140px;
                        border-radius: 8px;
                        background-image: url('../Images/PixelToCode.png');
                        background-position: center;
                        border: 1px solid var(--border-color, #ddd);
                    }

                    .bg-size-demo .hero.cover {
                        background-size: cover;
                    }

                    .bg-size-demo .hero.contain {
                        background-size: contain;
                        background-repeat: no-repeat;
                    }
                </style>
                <div class="bg-size-demo">
                    <div class="hero cover" title="cover"></div>
                    <div class="hero contain" title="contain"></div>
                </div>

                <h5>Voorbeeld – object-fit voor <code>&lt;img&gt;</code>/<code>&lt;video&gt;</code></h5>
                <p><code>object-fit</code> geeft vergelijkbaar gedrag als <em>cover/contain</em> voor media-elementen
                    (<a href="https://www.w3schools.com/" target="_blank" rel="noopener noreferrer">w3schools.com</a>).
                </p>
                <pre><code>.thumbnail { width: 150px; height: 150px; overflow: hidden; }
.thumbnail img { width: 100%; height: 100%; object-fit: cover; }</code></pre>
                <style>
                    .object-fit-demo {
                        display: grid;
                        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                        gap: 12px;
                        margin-bottom: 12px;
                    }

                    .object-fit-demo .thumb {
                        width: 150px;
                        height: 150px;
                        border-radius: 8px;
                        overflow: hidden;
                        border: 1px solid var(--border-color, #ddd);
                    }

                    .object-fit-demo .thumb img {
                        width: 100%;
                        height: 100%;
                        display: block;
                        object-fit: cover;
                    }

                    .object-fit-demo .thumb.contain img {
                        object-fit: contain;
                        background: #0f172a0d;
                    }
                </style>
                <div class="object-fit-demo">
                    <div class="thumb cover"><img src="../Images/PixelToCode.png" alt="cover"></div>
                    <div class="thumb contain"><img src="../Images/PixelToCode.png" alt="contain"></div>
                </div>

                <h5>Voorbeeld – aspect-ratio (bijv. 16:9 video)</h5>
                <p>Met <code>aspect-ratio</code> behoudt een container een verhouding, zoals <code>16 / 9</code> (<a
                        href="https://www.w3schools.com/" target="_blank" rel="noopener noreferrer">w3schools.com</a>).
                </p>
                <pre><code>.video-container {
  width: 100%;
  aspect-ratio: 16 / 9;
  background: #000;
}</code></pre>
                <style>
                    .aspect-ratio-demo {
                        width: 100%;
                        max-width: 560px;
                        aspect-ratio: 16 / 9;
                        background: #000;
                        border-radius: 8px;
                        display: grid;
                        place-items: center;
                        color: #fff;
                        margin-bottom: 12px;
                    }
                </style>
                <div class="aspect-ratio-demo">16:9 box (responsive hoogte)</div>

                <h5>Voorbeeld – responsive images met <code>srcset</code>/<code>&lt;picture&gt;</code></h5>
                <p>Met HTML-attributen zoals <code>srcset</code> en het <code>&lt;picture&gt;</code>-element kun je
                    verschillende afbeeldingsbestanden serveren voor diverse schermgroottes of resoluties (<a
                        href="https://www.w3schools.com/" target="_blank" rel="noopener noreferrer">w3schools.com</a>).
                </p>
                <pre><code>&lt;picture&gt;
  &lt;source media="(min-width: 992px)" srcset="hero-large.png"&gt;
  &lt;source media="(min-width: 576px)" srcset="hero-medium.png"&gt;
  &lt;img src="hero-small.png" alt="Responsieve afbeelding"&gt;
&lt;/picture&gt;</code></pre>
                <div class="srcset-demo" style="max-width:520px;margin-bottom:12px">
                    <picture>
                        <source media="(min-width: 992px)" srcset="../Images/PixelToCode.png">
                        <source media="(min-width: 576px)" srcset="../Images/PixelToCode.png">
                        <img src="../Images/PixelToCode.png" alt="Responsieve afbeelding"
                            style="width:100%;height:auto;border-radius:8px;border:1px solid var(--border-color,#ddd)">
                    </picture>
                </div>

                <h5>Voorbeeld – andere achtergrond op mobiel via media query</h5>
                <p>Hoewel <code>srcset</code> vaak beter is voor <code>&lt;img&gt;</code>, kun je in CSS een andere
                    achtergrondafbeelding kiezen voor kleine schermen:</p>
                <pre><code>.box {
  background-image: url("grote_afbeelding.jpg");
  background-size: cover;
}
@media (max-width: 400px) {
  .box { background-image: url("kleine_afbeelding.jpg"); }
}</code></pre>
                <style>
                    .bg-swap-demo {
                        height: 140px;
                        border-radius: 8px;
                        border: 1px solid var(--border-color, #ddd);
                        background-size: cover;
                        background-position: center;
                        background-image: url('../Images/PixelToCode.png');
                        margin-bottom: 12px;
                    }

                    @media (max-width: 400px) {
                        .bg-swap-demo {
                            background-image: url('../Images/PixelToCode.png');
                        }
                    }
                </style>
                <div class="bg-swap-demo" title="Achtergrond wisselt via media query"></div>

                <p>Kortom: maak afbeeldingen fluïde met <code>max-width</code>, gebruik <code>object-fit</code> of
                    <code>background-size</code> <em>cover/contain</em> om ze netjes te positioneren, en beperk onnodig
                    grote downloads door waar nodig verschillende bronnen (bijv. via <code>srcset</code>) aan te bieden.
                    Vergeet ook niet andere media: <code>&lt;video&gt;</code> kan flexibel met breedtes en
                    <code>object-fit</code>, en voor iframes kun je wrappers met <code>aspect-ratio</code> gebruiken.
                </p>

                <h4>CSS media queries: stijl aanpassen op schermkenmerken</h4>
                <p><strong>Media queries</strong> zijn een kernonderdeel van responsieve CSS. Hiermee pas je CSS toe
                    zodra aan bepaalde conditie(s) is voldaan, zoals een minimale schermbreedte, oriëntatie of
                    resolutie. Meest voorkomend is andere styling bij bepaalde schermbreedtes (breakpoints) (<a
                        href="https://kinsta.com/" target="_blank" rel="noopener noreferrer">kinsta.com</a>).</p>
                <p>De syntaxis van een media query:</p>
                <pre><code>@media (conditie) {
  /* CSS regels hier gelden alleen als conditie true is */
}</code></pre>
                <p>Voorbeelden van condities:</p>
                <ul>
                    <li><code>(max-width: 600px)</code> – alleen wanneer scherm maximaal 600px breed is (telefoons).
                    </li>
                    <li><code>(min-width: 768px)</code> – vanaf 768px (typisch tablets en groter).</li>
                    <li><code>screen and (min-width: 768px) and (max-width: 991px)</code> – alleen tussen 768 en 991px
                        breed.</li>
                    <li><code>(orientation: portrait)</code> – alleen in portretstand.</li>
                    <li><code>(prefers-reduced-motion)</code> – voorkeursinstelling voor minder animatie.</li>
                </ul>
                <p>Media queries kunnen ook controleren op resolutie en kleurenschema, zoals <code>resolution:
                        2dppx</code> (retina) of <code>(prefers-color-scheme: dark)</code> (dark mode) (<a
                        href="https://developer.mozilla.org/" target="_blank"
                        rel="noopener noreferrer">developer.mozilla.org</a>).</p>

                <h5>Mobile-first reeks (veelgebruikt)</h5>
                <pre><code>/* Mobiel-eerst: basis-styles hierboven... */
@media (min-width: 576px) { /* smalle tablets */
  /* andere stijl */
}
@media (min-width: 768px) { /* tablets staand/liggend */
  /* andere stijl */
}
@media (min-width: 992px) { /* desktop */
  /* andere stijl */
}</code></pre>
                <p>Dit is mobile-first (regels gelden <em>boven</em> de genoemde breedte). Desktop-first gebruikt vaak
                    <code>max-width</code> voor kleinere schermen. Mobile-first heeft vaak de voorkeur zodat mobiele
                    gebruikers een compacte basis krijgen (<a href="https://kinsta.com/" target="_blank"
                        rel="noopener noreferrer">kinsta.com</a>).
                </p>
                <p>Dit is een voorbeeld van mobile-first aanpak waarbij je met <code>min-width</code> werkt (stijl wordt
                    toegepast boven die breedte) (<a href="https://kinsta.com/" target="_blank"
                        rel="noopener noreferrer">kinsta.com</a>). Het alternatief is desktop-first (je basistyling is
                    desktop, en je gebruikt <code>max-width</code> media queries om aan te passen voor kleiner scherm).
                    Mobiel-eerst heeft vaak de voorkeur, omdat mobiele gebruikers zo de minste overweldigende CSS
                    ontvangen en je voor grotere schermen progressief opbouwt.</p>
                <p><strong>Media types</strong>: De media query syntax kan ook het type media bevatten, bv.
                    <code>@media screen and (max-width:600px)</code> of <code>@media print</code>. Standaard is het type
                    <em>screen</em> als niets is vermeld (<a href="https://developer.mozilla.org/" target="_blank"
                        rel="noopener noreferrer">developer.mozilla.org</a>). Voor responsive webdesign richten we ons
                    op schermen; print queries kun je gebruiken voor afdruk-layouts, maar dat valt buiten deze scope.
                </p>
                <p><strong>Combineer media queries slim</strong>: Je kunt meerdere condities komma-gescheiden toepassen
                    (betekent “OF”). Voorbeeld: <code>@media (max-width: 600px), (max-height: 400px) { ... }</code>
                    geldt als het scherm óf smaller dan 600px is óf lager dan 400px. Meestal gebruikt men <em>AND</em>
                    combinaties voor specifieker gedrag (bijv.
                    <code>(min-width: 500px) and (orientation: landscape)</code>),
                    maar enkel breedte dekt vaak al veel.
                </p>

                <h5>Media types en combineren</h5>
                <p>Je kunt een media type toevoegen, bv. <code>@media screen and (max-width: 600px)</code> of
                    <code>@media print</code>. Voor responsive webdesign richten we ons op <code>screen</code> (<a
                        href="https://developer.mozilla.org/" target="_blank"
                        rel="noopener noreferrer">developer.mozilla.org</a>).
                    Combineer condities met <code>and</code> (EN) of komma (OF), bv. <code>@media (max-width: 600px),
                        (max-height: 400px)</code>.
                </p>

                <h5>Voorbeeld – layout omschakelen via media query</h5>
                <p>Standaard (desktop) twee kolommen; op mobiel stapelen. Eventueel de sidebar verbergen op mobiel.</p>
                <pre><code>/* Desktop: twee kolommen naast elkaar */
.container { display: flex; }
.sidebar { width: 30%; }
.main    { width: 70%; }

/* Mobiel: stapel onder elkaar */
@media (max-width: 600px) {
  .container { display: block; }  /* of: flex-direction: column */
  .sidebar { width: 100%; }
  .main    { width: 100%; }
}

/* Eventueel: verberg sidebar op mobiel */
@media (max-width: 600px) {
  .sidebar { display: none; }
}</code></pre>

                <h6>Live voorbeeld – media query (stapelen en verbergen)</h6>
                <style>
                    .mq-flex-demo {
                        border: 1px solid var(--border-color, #ddd);
                        border-radius: 8px;
                        padding: 12px;
                        background: var(--card-bg, #0f172a0d);
                        margin-bottom: 12px;
                    }

                    .mq-flex-demo .mq-wrap {
                        display: flex;
                        gap: 12px;
                        align-items: stretch;
                    }

                    .mq-flex-demo .mq-sidebar,
                    .mq-flex-demo .mq-main {
                        border-radius: 6px;
                        padding: 12px;
                        color: #0b1220;
                        font-weight: 700;
                        text-align: center;
                    }

                    .mq-flex-demo .mq-sidebar {
                        flex: 0 0 30%;
                        background: #ddd6fe;
                    }

                    .mq-flex-demo .mq-main {
                        flex: 1 1 70%;
                        background: #bbf7d0;
                        min-height: 70px;
                    }

                    @media (max-width: 600px) {
                        .mq-flex-demo .mq-wrap {
                            flex-direction: column;
                        }

                        .mq-flex-demo .mq-sidebar,
                        .mq-flex-demo .mq-main {
                            flex: 0 0 auto;
                            width: 100%;
                        }
                    }

                    /* Variant: sidebar verbergen op mobiel */
                    .mq-hide-demo .mq-wrap {
                        display: flex;
                        gap: 12px;
                    }

                    .mq-hide-demo .mq-sidebar {
                        flex: 0 0 30%;
                        background: #fecaca;
                        border-radius: 6px;
                        padding: 12px;
                        font-weight: 700;
                        text-align: center;
                        color: #0b1220;
                    }

                    .mq-hide-demo .mq-main {
                        flex: 1 1 70%;
                        background: #bae6fd;
                        border-radius: 6px;
                        padding: 12px;
                        font-weight: 700;
                        text-align: center;
                        color: #0b1220;
                        min-height: 70px;
                    }

                    @media (max-width: 600px) {
                        .mq-hide-demo .mq-sidebar {
                            display: none;
                        }

                        .mq-hide-demo .mq-main {
                            width: 100%;
                        }
                    }
                </style>
                <div class="mq-flex-demo">
                    <div class="mq-wrap">
                        <div class="mq-sidebar">Sidebar</div>
                        <div class="mq-main">Main</div>
                    </div>
                </div>
                <div class="mq-hide-demo">
                    <div class="mq-wrap">
                        <div class="mq-sidebar">Sidebar (verdwijnt &lt;=600px)</div>
                        <div class="mq-main">Main</div>
                    </div>
                </div>

                <p>Met deze techniek kun je zelfs bepaalde elementen helemaal uitschakelen op bepaalde groottes (zoals
                    een groot illustratiebanner die je op mobiel liever weghaalt voor performance). Let op dat je
                    <code>display: none</code> gebruikt als je iets wil verbergen – die haalt het element uit de layout
                    en weergave. Voor toegankelijkheid is het beter dit alleen voor visuele decoraties te doen of
                    alternatieven aan te bieden als content verdwijnt.
                </p>

                <p><strong>Samenvattend:</strong> Media queries geven je volledige controle om bij verschillende
                    breakpoints de CSS aan te passen. In een goed responsive ontwerp gebruik je ze voor grote
                    layout-verschuivingen (kolommen vs rijen), tonen/verbergen van componenten en het aanpassen van
                    afmetingen. Dankzij moderne technieken als flexbox en grid heb je soms minder verschillende queries
                    nodig, omdat die layouts al flexibel zijn. Maar media queries blijven onmisbaar voor bijvoorbeeld
                    navigatie-transformaties (menu → hamburger) en typografie die schaalt op grotere schermen.</p>

                <p><strong>NB:</strong> Plaats in je HTML ook de meta-tag voor mobiele viewport, anders kan responsieve
                    CSS
                    niet naar behoren renderen: <code>&lt;meta name="viewport" content="width=device-width,
                        initial-scale=1"&gt;</code> (<a href="https://developer.mozilla.org/" target="_blank"
                        rel="noopener noreferrer">developer.mozilla.org</a>).</p>
            </section>

            <section id="css-cheatsheet">
                <h3>CSS Cheatsheet</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Categorie</th>
                            <th>Eigenschappen</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Selectors</strong></td>
                            <td><code>element</code>, <code>.class</code>, <code>#id</code>, <code>[attr]</code>,
                                <code>:hover</code>, <code>::before</code>, <code>></code>, <code>+</code>,
                                <code>~</code>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Box Model</strong></td>
                            <td><code>margin</code>, <code>border</code>, <code>padding</code>, <code>width</code>,
                                <code>height</code>, <code>box-sizing</code>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Typografie</strong></td>
                            <td><code>font-family</code>, <code>font-size</code>, <code>font-weight</code>,
                                <code>line-height</code>, <code>color</code>, <code>text-align</code>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Layout</strong></td>
                            <td><code>display: flex | grid</code>, <code>position</code>, <code>float</code>,
                                <code>clear</code>, <code>z-index</code>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Flexbox</strong></td>
                            <td><code>flex-direction</code>, <code>justify-content</code>, <code>align-items</code>,
                                <code>gap</code>, <code>flex</code>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Grid</strong></td>
                            <td><code>grid-template-columns</code>, <code>grid-template-rows</code>, <code>gap</code>,
                                <code>grid-column</code>, <code>grid-row</code>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Effecten</strong></td>
                            <td><code>transition</code>, <code>transform</code>, <code>animation</code>,
                                <code>box-shadow</code>, <code>border-radius</code>, <code>filter</code>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Responsive</strong></td>
                            <td><code>@media</code>, <code>min-width</code>, <code>max-width</code>,
                                `(prefers-color-scheme)`</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- ====================================================================== -->
            <!-- =========================== JAVASCRIPT =============================== -->
            <!-- ====================================================================== -->

            <section id="javascript">
                <h2>JavaScript</h2>
                <p>JavaScript is de programmeertaal van het web. Het maakt webpagina's interactief en dynamisch.</p>
            </section>

            <section id="js-syntax">
                <h3>Syntax & Statements</h3>
                <p>JavaScript-syntax verwijst naar de regels die bepalen hoe een programma correct wordt geschreven. Een
                    <strong>statement</strong> is een enkele instructie die wordt uitgevoerd.
                </p>
                <ul>
                    <li><strong>Hoofdlettergevoelig:</strong> Variabelen zoals <code>myVar</code> en <code>myvar</code>
                        zijn verschillend.</li>
                    <li><strong>Puntkomma's:</strong> Statements worden vaak afgesloten met een puntkomma
                        (<code>;</code>). Hoewel niet altijd verplicht, wordt het sterk aanbevolen om onverwacht gedrag
                        te voorkomen.</li>
                    <li><strong>Codeblokken:</strong> Worden gedefinieerd met accolades <code>{ }</code>, bijvoorbeeld
                        in functies en conditionele statements.</li>
                </ul>
                <pre><code>// Dit is een statement om een variabele te declareren
let message = "Hello, world!";

// Dit is een statement dat een functie aanroept
console.log(message);</code></pre>
            </section>

            <section id="js-comments">
                <h3>Comments</h3>
                <p>Commentaar wordt gebruikt om code te documenteren en leesbaarder te maken. Het wordt door de browser
                    genegeerd.</p>
                <pre><code>// Dit is een enkel-regel commentaar.

/* Dit is een
  meer-regelig
  commentaar.
*/</code></pre>
            </section>

            <section id="js-variables">
                <h3>JavaScript-variabelen: Een diepgaand onderzoek</h3>
                <p>Variabelen zijn de bouwstenen van elke programmeertaal – ze zijn als containers om gegevens in op te
                    slaan zodat we die later kunnen hergebruiken en manipuleren. In JavaScript is een variabele een
                    symbolische naam die verwijst naar een waarde (of een referentie naar een waarde). Anders gezegd, je
                    kunt een variabele zien als een label dat naar bepaalde data wijst. Het bijzondere aan JavaScript is
                    dat het een dynamisch getypeerde taal is: je hoeft vooraf niet te bepalen wat voor soort data
                    (getal, tekst, object, enz.) je in de variabele gaat stoppen. Dit geeft veel flexibiliteit, maar kan
                    ook tot verrassingen leiden als je niet oppast – bijvoorbeeld '500' (tussen quotes) wordt gezien als
                    een string en niet als een getal. In dit uitgebreide onderzoek gaan we alles behandelen wat je over
                    JavaScript-variabelen moet weten. We bespreken hoe je variabelen declareert met var, let en const en
                    wat de verschillen daartussen zijn. Ook duiken we in concepten als scope (waar is een variabele
                    zichtbaar?), hoisting (hoe JavaScript omgaat met variabele-declaraties vóór uitvoering) en de
                    zogenaamde Temporal Dead Zone. We kijken naar het verschil tussen primitieve waarden en
                    referentiewaarden, en hoe variabelen deze gegevens opslaan. Verder besteden we aandacht aan closures
                    (functies die variabelen onthouden uit een omringende scope) en zelfs een kijkje onder de motorkap:
                    hoe de JavaScript-engine variabelen beheert in geheugen en uitvoering. Tot slot geven we best
                    practices voor het gebruik van variabelen en waarschuwen we voor veelvoorkomende valkuilen.
                    Opmerking: Alle codevoorbeelden en uitleg zijn in het Nederlands geschreven, maar de
                    JavaScript-syntaxis zelf blijft uiteraard Engels. Laten we beginnen bij de basiskenmerken van
                    variabelen in JavaScript.</p>

                <h4>Kenmerken van JavaScript-variabelen</h4>

                <h5>Naamgeving en datatypes</h5>
                <p>Een variabele definieer je door een naam te kiezen en die te koppelen aan een waarde. Bij het kiezen
                    van namen gelden enkele regels en conventies: zo mag een variabelenaam niet beginnen met een cijfer
                    en geen gereserveerd woord zijn (zoals var of class). Namen zijn case-sensitive, dus prijs en Prijs
                    zijn verschillende variabelen. Het is goede stijl om duidelijke, beschrijvende namen in camelCase te
                    gebruiken (bijv. initialColor of audioVolume).</p>

                <p>In JavaScript hoef je geen type te declareren voor een variabele. Dezelfde variabele kan op
                    verschillend moment een getal, een string of een object bevatten – JavaScript past het type tijdens
                    runtime automatisch aan. Dit noemen we losse of dynamische typing. Bijvoorbeeld:</p>
                <pre><code>let x = "Hello"; // x is nu een string
x = 5; // x is nu een number (JavaScript converteert het type automatisch)</code></pre>
                <p>JavaScript kent een aantal primitieve datatypes: string (tekst), number (getallen, zowel gehele als
                    kommagetallen), boolean (true of false), null, undefined, symbol en bigint. Alle andere waarden
                    (zoals objecten, arrays, functies, datums etc.) vallen onder referentietypen (ook wel objecttypes
                    genoemd). Primitieve waarden zijn immuut (je kunt hun inhoud niet veranderen, alleen de variabele
                    een nieuwe waarde geven), terwijl objecten mutabel zijn (de inhoud van een object kan wel gewijzigd
                    worden). Om even het verschil te illustreren: een primitief als een getal wordt direct in de
                    variabele opgeslagen, maar een object wordt op een andere plek in het geheugen gezet (de heap) en de
                    variabele bevat slechts een referentie (een soort pointer) naar dat object. Dit betekent dat als je
                    een object toekent aan een andere variabele, beide variabelen naar dezelfde onderliggende data
                    verwijzen. Daarover later meer in het gedeelte over primitief vs referentie.</p>

                <div class="live-example">
                    <h5>Live voorbeeld: Dynamische typing</h5>
                    <button onclick="demonstrateDynamicTyping()">Klik om te zien hoe een variabele van type
                        verandert</button>
                    <p id="dynamic-typing-result">Klik op de knop om het voorbeeld te starten</p>
                    <script>
                        function demonstrateDynamicTyping() {
                            let x = "Hello"; // x is nu een string
                            document.getElementById('dynamic-typing-result').innerHTML = `x = "${x}" (type: ${typeof x})<br>`;

                            x = 5; // x is nu een number
                            document.getElementById('dynamic-typing-result').innerHTML += `x = ${x} (type: ${typeof x})<br>`;

                            x = { name: "JavaScript" }; // x is nu een object
                            document.getElementById('dynamic-typing-result').innerHTML += `x = ${JSON.stringify(x)} (type: ${typeof x})`;
                        }
                    </script>
                </div>

                <h5>Declareren en initialiseren</h5>
                <p>In JavaScript kun je variabelen op drie manieren declareren: met var, let of const. Daarnaast kun je
                    – als je geen van deze trefwoorden gebruikt – impliciet een globale variabele creëren, maar dat is
                    af te raden en in strikte modus zelfs niet toegestaan.</p>

                <pre><code>var aantal; // declaratie met var (zonder initialisatie, waarde wordt undefined)
let prijs = 9.99; // declaratie met let, direct geïnitialiseerd met een Number
const PI = 3.14159; // declaratie met const, direct geïnitialiseerd (verplicht bij const)</code></pre>

                <div class="live-example">
                    <h5>Live voorbeeld: Declareren en initialiseren</h5>
                    <button onclick="demonstrateDeclInit()">Toon declaraties en types</button>
                    <p id="decl-init-result">Klik op de knop om het voorbeeld te zien</p>
                    <script>
                        function demonstrateDeclInit() {
                            var aantal;
                            let prijs = 9.99;
                            const PI = 3.14159;
                            let output = '';
                            output += `aantal = ${String(aantal)} (type: ${typeof aantal})\n`;
                            output += `prijs = ${prijs} (type: ${typeof prijs})\n`;
                            output += `PI = ${PI} (type: ${typeof PI})`;
                            document.getElementById('decl-init-result').innerHTML = output.replace(/\n/g, '<br>');
                        }
                    </script>
                </div>

                <h4>Variabelen declareren: var, let en const</h4>

                <h5>var: function-scoped variabelen</h5>
                <p>var is het oude vertrouwde sleutelwoord om een variabele te declareren. Enkele belangrijke kenmerken
                    van met var gedeclareerde variabelen zijn:</p>
                <ul>
                    <li><strong>Functiescope:</strong> Een var-variabele is zichtbaar binnen de gehele functie waarin
                        hij gedeclareerd is (of in de globale scope als hij buiten functies staat). Blokken zoals
                        if-statements of loops creëren geen nieuwe scope voor var.</li>
                    <li><strong>Hoisting:</strong> Variabelen gedeclareerd met var worden tijdens de
                        uitvoeringsvoorbereiding gehoist naar het begin van hun scope. Voor gebruik vóór de declaratie
                        is de waarde undefined.</li>
                    <li><strong>Hertoewijzing en herdeklaratie:</strong> Je kunt een var-variabele een nieuwe waarde
                        toekennen en in dezelfde scope opnieuw met var declareren.</li>
                    <li><strong>Geen blokscope:</strong> var negeert blokken (behalve functies) voor scoping.</li>
                </ul>

                <p><strong>Voorbeeld 1: Scope en hoisting met var</strong></p>
                <pre><code>function varVoorbeeld() {
  console.log(x); // Output: undefined (hoewel x later gedeclareerd wordt)
  var x = 10;
  console.log(x); // Output: 10

  if (true) {
    var x = 20; // dezelfde variabele x, ondanks dat dit in een blok staat!
  }

  console.log(x); // Output: 20 (var heeft geen blokscope, dus x is overschreven)
}
varVoorbeeld();</code></pre>
                <p>In het bovenstaande voorbeeld zie je een paar dingen gebeuren. Ten eerste logt de eerste
                    <code>console.log(x)</code> <code>undefined</code>, hoewel de variabele <code>x</code> pas op de
                    volgende regel met <code>var x = 10</code> gedeclareerd wordt. Dit komt door hoisting: JavaScript
                    doet alsof de declaratie <code>var x</code> omhoog verplaatst is naar het begin van de functie. De
                    initialisatie (<code>= 10</code>) gebeurt pas op de plek waar die staat. Dus op de plek vóór de
                    declaratie is <code>x</code> al wel bekend, maar nog <code>undefined</code>. Ten tweede zie je dat
                    het <code>if</code>-blok geen nieuwe scope creëert voor <code>x</code> bij gebruik van
                    <code>var</code>. De assignment <code>var x = 20</code> binnen het blok overschrijft gewoon de
                    bestaande <code>x</code> van de functie. Na het <code>if</code>-blok is <code>x</code> dus 20
                    geworden.
                </p>
                <p><strong>Wanneer (nog) var gebruiken?</strong> In moderne JavaScript wordt <code>var</code> weinig
                    gebruikt. Het is meestal beter om <code>let</code> of <code>const</code> te gebruiken vanwege hun
                    duidelijkere scoping. <code>var</code> kan van pas komen voor oudere code of om intentioneel
                    function-scope gedrag te krijgen, maar in de praktijk zijn die gevallen zeldzaam. Over het algemeen
                    geldt: gebruik <code>var</code> zo min mogelijk – het voorkomt een hoop potentiële bugs.</p>

                <div class="live-example">
                    <h5>Live voorbeeld: var scope en hoisting</h5>
                    <button onclick="demonstrateVar()">Toon var gedrag</button>
                    <p id="var-result">Klik op de knop om var voorbeeld te zien</p>
                    <script>
                        function demonstrateVar() {
                            function varVoorbeeldLive() {
                                let output = "";
                                output += String(x) + "\n"; // undefined door hoisting (console.log(x) gedrag)
                                var x = 10;
                                output += x + "\n"; // 10
                                if (true) {
                                    var x = 20;
                                    output += x + "\n"; // 20 binnen blok
                                }
                                output += x; // 20 na blok
                                return output;
                            }
                            document.getElementById('var-result').innerHTML = varVoorbeeldLive().replace(/\n/g, '<br>');
                        }
                    </script>
                </div>

                <h5>let: block-scoped variabelen</h5>
                <p>let is geïntroduceerd in ES6 om de tekortkomingen van var aan te pakken. Variabelen gedeclareerd met
                    let gedragen zich als in veel andere talen:</p>
                <ul>
                    <li><strong>Blokscope:</strong> Een let-variabele is alleen zichtbaar binnen het blok { ... } waarin
                        hij gedeclareerd is.</li>
                    <li><strong>Hoisting met temporal dead zone:</strong> Wordt gehoist maar zit tot de declaratie in de
                        TDZ (gebruik vóór die regel geeft ReferenceError).</li>
                    <li><strong>Hertoewijzing maar geen herdeklaratie:</strong> Je kunt een nieuwe waarde geven maar
                        niet opnieuw met dezelfde naam binnen dezelfde scope declareren.</li>
                </ul>

                <p><strong>Voorbeeld 2: Gedrag van let</strong></p>
                <pre><code>function letVoorbeeld() {
  console.log(y); // ReferenceError: y is not defined (TDZ)
  let y = 10;

  if (true) {
    let y = 20; // Dit is een andere y, alleen binnen dit blok geldig
    let z = "hoi";
    console.log(y); // 20 (binnen blok)
  }

  console.log(y); // 10 (buiten blok)
  console.log(z); // ReferenceError: z is not defined
}</code></pre>
                <p>Hier zien we dat <code>console.log(y)</code> vóór de declaratie resulteert in een error – de
                    variabele is wel gehoist, maar bevindt zich in de Temporal Dead Zone en is nog niet bruikbaar. Pas
                    op de regel <code>let y = 10</code> wordt <code>y</code> geïnitialiseerd. Binnen het
                    <code>if</code>-blok declareren we opnieuw een <code>y</code> met <code>let</code>. Dat mag, want
                    dit is een andere scope. Deze binnenste <code>y</code> verbergt tijdelijk de buitenste
                    <code>y</code> in dat blok (shadowing). Buiten het blok verwijst <code>y</code> weer naar de
                    oorspronkelijke variabele met waarde 10. Variabele <code>z</code> is alleen binnen het blok bekend;
                    buiten het blok is <code>z</code> niet gedefinieerd, wat de block scope van <code>let</code>
                    bevestigt. Omdat <code>let</code> block-scope is en geen hoisting-problemen geeft, is het in de
                    meeste gevallen de voorkeurskeuze voor variabelen die van waarde veranderen.
                </p>

                <div class="live-example">
                    <h5>Live voorbeeld: let block scope</h5>
                    <button onclick="demonstrateLet()">Toon let gedrag</button>
                    <p id="let-result">Klik op de knop om let voorbeeld te zien</p>
                    <script>
                        function demonstrateLet() {
                            function letVoorbeeldLive() {
                                let output = "";
                                try {
                                    output += y + "\n"; // ReferenceError (TDZ)
                                } catch (e) {
                                    output += "ReferenceError (TDZ)\n";
                                }
                                let y = 10;
                                output += y + "\n"; // 10
                                if (true) {
                                    let y = 20;
                                    let z = "hoi";
                                    output += y + "\n"; // 20
                                }
                                output += y + "\n"; // 10 buiten blok
                                try {
                                    // z is hier niet gedefinieerd
                                    // @ts-ignore
                                    output += z;
                                } catch (e) {
                                    output += "ReferenceError voor z";
                                }
                                return output;
                            }
                            document.getElementById('let-result').innerHTML = letVoorbeeldLive().replace(/\n/g, '<br>');
                        }
                    </script>
                </div>

                <h5>const: constante variabelen (immutable bindings)</h5>
                <p>const werd net als let toegevoegd in ES6. Een constante is in feite een niet-hertoewijsbare
                    variabele:</p>
                <ul>
                    <li><strong>Blokscope & TDZ:</strong> Net als let, beperkt tot de blokscope</li>
                    <li><strong>Verplichte initialisatie:</strong> Je moet meteen een waarde toekennen</li>
                    <li><strong>Geen hertoewijzing:</strong> Eenmaal een waarde gegeven, kun je geen nieuwe toekennen
                    </li>
                    <li><strong>Wel mutatie van objecten:</strong> const maakt de binding constant, niet per se de
                        waarde</li>
                </ul>

                <p><strong>Voorbeeld 3: Gebruik van const</strong></p>
                <pre><code>const PI = 3.14;
PI = 3.15; // TypeError: Assignment to constant variable

const mijnObject = { naam: "Alice" };
mijnObject.naam = "Bob"; // toegestaan (we muteren het object)
console.log(mijnObject.naam); // "Bob"

mijnObject = { naam: "Carol" }; // TypeError: Assignment to constant variable</code></pre>
                <p>In dit voorbeeld zien we dat herassigneren naar <code>PI</code> niet kan – de variabele zelf is
                    constant. Bij <code>mijnObject</code> kunnen we echter wel de property <code>naam</code> aanpassen,
                    omdat het object zelf nog steeds hetzelfde object is in memory (alleen de inhoud verandert). Een
                    poging om de hele variabele een nieuw object toe te wijzen faalt wel.</p>
                <p><strong>Wanneer const gebruiken?</strong> Een algemene richtlijn is: gebruik <code>const</code> waar
                    mogelijk, en <code>let</code> waar nodig. Dat wil zeggen, als je bij declaratie al een waarde weet
                    en je verwacht niet dat die variabele een andere waarde moet krijgen, gebruik dan
                    <code>const</code>. Dit maakt de intentie van je code duidelijker voor zowel de lezer als de
                    JavaScript-engine. In moderne JavaScript zal het merendeel van je variabelen <code>const</code>
                    zijn, en gebruik je <code>let</code> alleen voor waarden die in de loop van de tijd veranderen.
                    <code>var</code> wordt in nieuwe code eigenlijk niet meer aangeraden.
                </p>

                <div class="live-example">
                    <h5>Live voorbeeld: const gedrag</h5>
                    <button onclick="demonstrateConst()">Toon const gedrag</button>
                    <p id="const-result">Klik op de knop om const voorbeeld te zien</p>
                    <script>
                        function demonstrateConst() {
                            let output = "";

                            const PI = 3.14;
                            output += "PI = " + PI + "\n";

                            try {
                                PI = 3.15;
                            } catch (e) {
                                output += "PI = 3.15 geeft: TypeError\n";
                            }

                            const mijnObject = { naam: "Alice" };
                            mijnObject.naam = "Bob";
                            output += "Na mutatie: " + JSON.stringify(mijnObject) + "\n";

                            try {
                                mijnObject = { naam: "Carol" };
                            } catch (e) {
                                output += "Nieuw object toewijzen geeft: TypeError";
                            }

                            document.getElementById('const-result').innerHTML = output.replace(/\n/g, '<br>');
                        }
                    </script>
                </div>

                <h4>Scope van variabelen</h4>
                <p>Scope beschrijft het bereik waarbinnen een variabele toegankelijk is. JavaScript gebruikt lexicale
                    scope:</p>
                <pre><code>var globaal = "Ik ben globaal";

function demo() {
  var lokaal = "Ik ben binnen functie demo";
  console.log(globaal); // "Ik ben globaal"
  console.log(lokaal); // "Ik ben binnen functie demo"

  if (true) {
    let binnenIf = 42;
    var ookBinnenIf = "var binnen if";
  }

  // console.log(binnenIf); // ReferenceError
  console.log(ookBinnenIf); // "var binnen if"
}

demo();
console.log(typeof lokaal); // "undefined"</code></pre>
                <p>Hier zie je dat <code>globaal</code> overal beschikbaar is (zelfs binnen de functie),
                    <code>lokaal</code> alleen binnen de functie <code>demo</code> zelf, <code>binnenIf</code> alleen in
                    het <code>if</code>-blok, en <code>ookBinnenIf</code> ondanks dat het binnen het
                    <code>if</code>-blok gedeclareerd werd met <code>var</code>, nog steeds bestaat na het blok binnen
                    de functie (met waarde "var binnen if"). Buiten de functie <code>demo</code> is <code>lokaal</code>
                    natuurlijk niet bekend.
                </p>
                <p><strong>Lexicaal (statisch) scope & geneste functies:</strong> Een functie die binnen een andere
                    functie is gedefinieerd, heeft toegang tot de variabelen van zijn omringende functie(s). Dit is
                    statisch bepaald: ongeacht van waaruit je de inner function aanroept, hij onthoudt de omgeving
                    waarin hij gecreëerd is. Dit fenomeen noemen we een <em>closure</em>. Innerlijke scopes hebben
                    toegang tot variabelen van buiten, maar niet andersom.</p>

                <div class="live-example">
                    <h5>Live voorbeeld: scope demonstratie</h5>
                    <button onclick="demonstrateScope()">Toon scope voorbeeld</button>
                    <p id="scope-result">Klik op de knop om scope voorbeeld te zien</p>
                    <script>
                        function demonstrateScope() {
                            let globaal = "Ik ben globaal";

                            function demo() {
                                let output = "";
                                let lokaal = "Ik ben binnen functie demo";
                                output += globaal + "\n"; // globaal is bereikbaar
                                output += lokaal + "\n";

                                if (true) {
                                    let binnenIf = 42;
                                    var ookBinnenIf = "var binnen if";
                                }

                                output += ookBinnenIf + "\n"; // var is zichtbaar
                                // binnenIf is hier niet bereikbaar

                                return output;
                            }

                            let result = demo();
                            result += "lokaal buiten functie: " + (typeof lokaal === 'undefined' ? "undefined" : lokaal);
                            document.getElementById('scope-result').innerHTML = result.replace(/\n/g, '<br>');
                        }
                    </script>
                </div>

                <h4>Hoisting en de Temporal Dead Zone</h4>
                <p>Een van de meest verwarrende concepten voor beginners in JavaScript is hoisting. JavaScript doorloopt
                    een script in twee fasen:</p>
                <pre><code>function varVoorbeeld() {
  var x; // hoisted declaratie
  console.log(x); // undefined (x is gedeclareerd maar nog undefined)
  x = 10; // toekenning gebeurt hier
  console.log(x); // 10
  // ... overige code ...
}</code></pre>
                <pre><code>{
  console.log(bar); // undefined → bar is een var (gehoist, maar nog undefined)
  console.log(foo); // ReferenceError → foo is een let (zit in TDZ)
  var bar = 1;
  let foo = 2;
}</code></pre>
                <p>Tijdens de eerste fase worden onder andere alle variabele- en functiedeclaraties geregistreerd.
                    <code>var</code>-declaraties krijgen alvast een plek (met waarde <code>undefined</code>), zodat ze
                    al bestaan voordat de code ze eigenlijk tegenkomt. Gevolg: je kunt bij <code>var</code> al naar de
                    variabele verwijzen voordat de declaratieregel staat. Alleen de declaratie wordt gehoist, de
                    daadwerkelijke assignment blijft op zijn plek.
                </p>
                <p>Hoisting geldt ook voor functiedeclaraties (<code>function foo() { }</code>). Die worden volledig
                    naar boven gehaald, inclusief de functie-inhoud, zodat je in code vaak een functie kunt aanroepen
                    voordat hij later in de file is gedefinieerd. Dit werkt alleen met function declarations, niet met
                    function expressions die in een variabele worden opgeslagen.</p>
                <p><strong>Hoisting van let en const:</strong> Hoewel deze variabelen niet bruikbaar zijn vóór de
                    declaratie, worden ze technisch eveneens van tevoren geregistreerd door de engine. Het verschil is
                    dat ze in de tussentijd (vanaf begin scope tot declaratie-statement) in de zogenaamde Temporal Dead
                    Zone (TDZ) zitten. In de TDZ is elke toegang verboden en resulteert direct in een
                    <code>ReferenceError</code>. Pas op het moment van de declaratie krijgt de variabele een waarde en
                    verlaat hij de TDZ.
                </p>
                <p><strong>Waarom "Temporal" dead zone?</strong> De term temporal (tijdelijk) wordt gebruikt omdat het
                    hier om de tijdsvolgorde in de uitvoering gaat, niet de positie in de code. Zodra de uitvoering de
                    declaratie bereikt, eindigt de TDZ voor die variabele. Het concept voorkomt dat je per ongeluk een
                    <code>let</code> of <code>const</code> gebruikt voordat hij een waarde heeft.
                </p>

                <div class="live-example">
                    <h5>Live voorbeeld: hoisting verschillen</h5>
                    <button onclick="demonstrateHoisting()">Toon hoisting voorbeeld</button>
                    <p id="hoisting-result">Klik op de knop om hoisting voorbeeld te zien</p>
                    <script>
                        function demonstrateHoisting() {
                            let output = "";

                            output += "=== Hoisting met var ===\n";
                            output += "typeof bar: " + (typeof bar) + "\n"; // undefined

                            output += "\n=== Temporal Dead Zone met let ===\n";
                            try {
                                output += "typeof foo: " + (typeof foo) + "\n";
                            } catch (e) {
                                output += "typeof foo: ReferenceError (TDZ)\n";
                            }

                            var bar = 1;
                            let foo = 2;

                            document.getElementById('hoisting-result').innerHTML = output.replace(/\n/g, '<br>');
                        }
                    </script>
                </div>

                <h4>Strict mode en impliciete variabelen</h4>
                <p>JavaScript heeft een strikte modus ("use strict") waarin bepaalde onduidelijke gedragspatronen worden
                    verboden.</p>
                <pre><code>function foo() {
  ongedefinieerdVar = 5; // Oeps, geen var/let/const -> wordt globale variabele (in non-strict)
}
foo();
console.log(ongedefinieerdVar); // 5

function bar() {
  "use strict";
  ongedefinieerdVar2 = 5; // ReferenceError in strict mode
}
// bar();</code></pre>
                <p><strong>Impliciete globale variabelen:</strong> In niet-strikte modus gebeurt het volgende: als je
                    een waarde toekent aan een naam die niet als lokale variabele is gedeclareerd, zal JavaScript
                    automatisch een globale variabele aanmaken met die naam. Dit is gevaarlijk; in strict mode is dit
                    verboden en resulteert het in een <code>ReferenceError</code>. Gebruik strict mode om dit te
                    voorkomen.</p>
                <p>Strict mode beïnvloedt nog een paar dingen rondom variabelen: (1) Dubbele declaraties: je kunt niet
                    twee function parameters met dezelfde naam hebben. (2) <code>this</code> in functies: in strict mode
                    is <code>this</code> in een gewone functie <code>undefined</code> in plaats van het globale object.
                    (3) <code>eval</code>: in strict mode voegt <code>eval()</code> geen variabelen toe aan de
                    buiten-scope.</p>
                <p>Samengevat zorgt strict mode ervoor dat variabelen lokaler en veiliger zijn: je moet ze declareren,
                    en de taal vangt meer fouten af. In ES6 modules is strict mode standaard.</p>

                <div class="live-example">
                    <h5>Live voorbeeld: strict mode effect</h5>
                    <button onclick="demonstrateStrictMode()">Toon strict mode verschil</button>
                    <p id="strict-result">Klik op de knop om strict mode voorbeeld te zien</p>
                    <script>
                        function demonstrateStrictMode() {
                            let output = "";

                            // Simuleer non-strict mode gedrag
                            function nonStrict() {
                                try {
                                    ongedefinieerdVar = 5; // zou globale variabele creëren
                                    return "Variabele aangemaakt zonder var/let/const";
                                } catch (e) {
                                    return "Fout: " + e.message;
                                }
                            }

                            // Simuleer strict mode gedrag
                            function strictMode() {
                                "use strict";
                                try {
                                    ongedefinieerdVar2 = 5;
                                    return "Variabele aangemaakt zonder var/let/const";
                                } catch (e) {
                                    return "Fout: " + e.message;
                                }
                            }

                            output += "Non-strict: " + nonStrict() + "\n";
                            output += "Strict mode: " + strictMode();

                            document.getElementById('strict-result').innerHTML = output.replace(/\n/g, '<br>');
                        }
                    </script>
                </div>

                <h4>Primitieve vs. referentiewaarden</h4>
                <p>Primitieve waarden worden door waarde opgeslagen, referentiewaarden door referentie:</p>
                <pre><code>let a = 10;
let b = a; // b krijgt een kopie van de waarde in a (10)
b = 20;
console.log(a); // 10

let obj1 = { naam: "Alice" };
let obj2 = obj1; // obj2 krijgt een kopie van de referentie (wijst naar zelfde object)
obj2.naam = "Bob";
console.log(obj1.naam); // "Bob"</code></pre>
                <p>In het eerste deel blijft <code>a</code> gelijk aan 10, ook al veranderen we <code>b</code> naar 20 –
                    dit bevestigt dat <code>a</code> en <code>b</code> gescheiden kopieën van een primitieve waarde
                    bevatten. In het tweede deel zien we dat het aanpassen van de property <code>naam</code> via
                    <code>obj2</code> ook zichtbaar is via <code>obj1</code>: beide variabelen wijzen immers naar
                    hetzelfde object in het geheugen.
                </p>
                <p><strong>Immutable vs mutable:</strong> Alle primitieve types zijn immutabel. Objecten en arrays zijn
                    mutabel: je kunt hun inhoud wijzigen zonder een nieuw object te maken.</p>

                <div class="live-example">
                    <h5>Live voorbeeld: primitief vs referentie</h5>
                    <button onclick="demonstratePrimitiveVsReference()">Toon verschil</button>
                    <p id="primitive-result">Klik op de knop om het verschil te zien</p>
                    <script>
                        function demonstratePrimitiveVsReference() {
                            let output = "";

                            // Primitief voorbeeld
                            let a = 10;
                            let b = a;
                            b = 20;
                            output += "Primitief: a = " + a + ", b = " + b + " (b heeft geen invloed op a)\n\n";

                            // Referentie voorbeeld
                            let obj1 = { naam: "Alice" };
                            let obj2 = obj1;
                            obj2.naam = "Bob";
                            output += "Referentie: obj1.naam = " + obj1.naam + ", obj2.naam = " + obj2.naam + " (beide verwijzen naar hetzelfde object)";

                            document.getElementById('primitive-result').innerHTML = output.replace(/\n/g, '<br>');
                        }
                    </script>
                </div>

                <p>Klonen van objecten: Een shallow copy (oppervlakkige kopie) kun je maken met de spread-syntax of
                    Object.assign(). Voor deep copy kun je bijvoorbeeld structuredClone gebruiken.</p>
                <pre><code>const origineel = { naam: "Alice", adres: { stad: "Leuven" } };
const kopie = { ...origineel }; // shallow copy
kopie.naam = "Charlie";
console.log(origineel.naam); // "Alice"

// Deep copy (moderne manier)
const diep = structuredClone(origineel);
diep.adres.stad = "Antwerpen";
console.log(origineel.adres.stad); // "Leuven"</code></pre>

                <div class="live-example">
                    <h5>Live voorbeeld: shallow vs deep copy</h5>
                    <button onclick="demonstrateCopying()">Toon kopieergedrag</button>
                    <p id="copy-result">Klik op de knop om het voorbeeld te zien</p>
                    <script>
                        function demonstrateCopying() {
                            const origineel = { naam: "Alice", adres: { stad: "Leuven" } };
                            const shallow = { ...origineel };
                            shallow.naam = "Charlie";
                            const deep = (typeof structuredClone === 'function') ? structuredClone(origineel) : JSON.parse(JSON.stringify(origineel));
                            deep.adres.stad = "Antwerpen";
                            let output = '';
                            output += `origineel.naam = ${origineel.naam}\n`;
                            output += `shallow.naam = ${shallow.naam}\n`;
                            output += `origineel.adres.stad = ${origineel.adres.stad}\n`;
                            output += `deep.adres.stad = ${deep.adres.stad}`;
                            document.getElementById('copy-result').innerHTML = output.replace(/\n/g, '<br>');
                        }
                    </script>
                </div>

                <div class="live-example">
                    <h5>Live voorbeeld: pass-by-value (met objectreferentie)</h5>
                    <button onclick="demonstratePassByValue()">Toon functie-argument gedrag</button>
                    <p id="passby-result">Klik op de knop om het voorbeeld te zien</p>
                    <script>
                        function mutateNumber(n) { n = n + 1; return n; }
                        function mutateObject(o) { o.naam = 'Gewijzigd'; }
                        function demonstratePassByValue() {
                            let num = 5;
                            let obj = { naam: 'Alice' };
                            let after = mutateNumber(num);
                            mutateObject(obj);
                            let output = '';
                            output += `num voor/na functie: ${num} / ${after} (origineel ongewijzigd)\n`;
                            output += `obj.naam na functie: ${obj.naam} (objectinhoud gewijzigd)`;
                            document.getElementById('passby-result').innerHTML = output.replace(/\n/g, '<br>');
                        }
                    </script>
                </div>
                <p><strong>Pass-by-value vs pass-by-reference:</strong> In JavaScript worden alle argumenten aan
                    functies by value doorgegeven. Als die waarde een referentie is (naar een object), wordt die
                    referentie gekopieerd. Hierdoor lijkt het alsof objecten “by reference” worden doorgegeven, want
                    wijzigingen aan het object binnen de functie zijn zichtbaar buiten de functie. Maar strikt genomen
                    is het de referentie die by value is gepassed.</p>

                <h4>Closures en variabelen</h4>
                <p>Een closure ontstaat wanneer een functie toegang blijft houden tot variabelen uit een omliggende
                    scope.</p>
                <pre><code>function maakCounter() {
  let teller = 0;
  return function() {
    teller++;
    return teller;
  }
}

const counter1 = maakCounter();
console.log(counter1()); // 1
console.log(counter1()); // 2

const counter2 = maakCounter();
console.log(counter2()); // 1</code></pre>
                <p>Hier is <code>maakCounter</code> een factory die een functie retourneert. Die geretourneerde anonieme
                    functie vormt een closure over de variabele <code>teller</code> van de buitenste scope. Ook nadat
                    <code>maakCounter()</code> is geëindigd, blijft de variabele <code>teller</code> bestaan in de
                    gesloten omgeving van de retourfunctie. Iedere keer dat we <code>counter1()</code> aanroepen,
                    verhoogt hij zijn eigen teller. <code>counter2()</code> begint met een eigen teller op 0.
                </p>
                <p><strong>Closure en var/let:</strong> Closures werken zowel met <code>var</code> als met
                    <code>let/const</code>. Het verschil in scopegedrag kan echter onverwachte effecten hebben, vooral
                    met <code>var</code> in loops. Een berucht voorbeeld is het gebruik van <code>setTimeout</code>
                    binnen een <code>for</code>-loop met <code>var</code> (zie voorbeelden hieronder). De oplossing is
                    <code>let</code> gebruiken of een IIFE.
                </p>

                <div class="live-example">
                    <h5>Live voorbeeld: closure met teller</h5>
                    <button onclick="createCounter()">Maak teller</button>
                    <button onclick="incrementCounter()" id="incrementBtn" disabled>Verhoog teller</button>
                    <p id="counter-result">Counter: 0</p>
                    <script>
                        let counter;

                        function createCounter() {
                            counter = (function () {
                                let teller = 0;
                                return function () {
                                    teller++;
                                    return teller;
                                }
                            })();

                            document.getElementById('incrementBtn').disabled = false;
                            document.getElementById('counter-result').innerHTML = "Counter: 0 (teller aangemaakt)";
                        }

                        function incrementCounter() {
                            const current = counter();
                            document.getElementById('counter-result').innerHTML = "Counter: " + current;
                        }
                    </script>
                </div>

                <div class="live-example">
                    <h5>Live voorbeeld: closure loop probleem met var vs let</h5>
                    <button onclick="demonstrateLoopClosure()">Toon loop closure verschil</button>
                    <p id="loop-result">Klik op de knop om het verschil te zien</p>
                    <script>
                        function demonstrateLoopClosure() {
                            let output = "";

                            // Probleem met var
                            output += "=== Met var (probleem) ===\n";
                            for (var i = 0; i < 3; i++) {
                                setTimeout(() => {
                                    output += "var i: " + i + "\n";
                                    if (output.split('\n').length >= 6) {
                                        document.getElementById('loop-result').innerHTML = output.replace(/\n/g, '<br>');
                                    }
                                }, 100);
                            }

                            // Oplossing met let
                            setTimeout(() => {
                                output += "\n=== Met let (oplossing) ===\n";
                                for (let j = 0; j < 3; j++) {
                                    setTimeout(() => {
                                        output += "let j: " + j + "\n";
                                        document.getElementById('loop-result').innerHTML = output.replace(/\n/g, '<br>');
                                    }, 200);
                                }
                            }, 500);
                        }
                    </script>
                </div>

                <div class="live-example">
                    <h5>Live voorbeeld: IIFE-oplossing met var</h5>
                    <button onclick="demonstrateIIFE()">Toon IIFE oplossing</button>
                    <p id="iife-result">Klik op de knop om het verschil te zien</p>
                    <script>
                        function demonstrateIIFE() {
                            let output = '';
                            for (var i = 0; i < 3; i++) {
                                (function (capturedI) {
                                    setTimeout(() => {
                                        output += `var i via IIFE: ${capturedI}\n`;
                                        document.getElementById('iife-result').innerHTML = output.replace(/\n/g, '<br>');
                                    }, 100 * (capturedI + 1));
                                })(i);
                            }
                        }
                    </script>
                </div>

                <p>Een berucht voorbeeld met <code>var</code> in een loop:</p>
                <pre><code>for (var i = 0; i &lt; 4; i++) {
  setTimeout(() => {
    console.log("var i:", i);
  }, i * 1000);
}
// Resultaat: telkens 4</code></pre>
                <p>Oplossing met <code>let</code>:</p>
                <pre><code>for (let j = 0; j &lt; 4; j++) {
  setTimeout(() => console.log("let j:", j), j * 1000);
}</code></pre>
                <p>Alternatief met een IIFE in ES5-stijl:</p>
                <pre><code>for (var i = 0; i &lt; 4; i++) {
  (function(capturedI) {
    setTimeout(() => console.log("var i via IIFE:", capturedI), capturedI * 1000);
  })(i);
}</code></pre>
                <p><strong>Closures en geheugenlekken:</strong> Let op dat closures variabelen langer in leven kunnen
                    houden dan je verwacht. Als je onnodig lang referenties bewaart naar functies die closures zijn,
                    houd je daarmee ook hun hele outer scope in geheugen. In extreme gevallen kan dat tot verhoogd
                    geheugenverbruik leiden. De garbage collector zal de gesloten-over variabelen pas vrijgeven wanneer
                    de closure zelf nergens meer referenties heeft.</p>

                <h4>Interne werking: uitvoeringscontext en geheugenbeheer</h4>
                <p>Wanneer JavaScript code uitvoert, gebeurt dat binnen een execution context (bijvoorbeeld de globale
                    context of een functiecontext). Zo'n context heeft een Lexical Environment met een Environment
                    Record waarin variabelenamen worden gemapt op waarden. Bij het betreden van een functie of blok
                    maakt de engine een nieuw environment aan voor die scope, met links naar outer environments (scope
                    chain).</p>
                <p>Tijdens de creation phase van een context worden var-declaraties alvast als undefined geregistreerd
                    en function declarations volledig beschikbaar. let en const worden ook geregistreerd, maar blijven
                    on-geïnitialiseerd binnen de Temporal Dead Zone tot de declaratie wordt uitgevoerd.</p>
                <p>JavaScript runtimes onderscheiden grofweg de call stack (voor o.a. frames en vaak primitieve
                    waarden/referenties) en de heap (voor objecten en arrays). Objecten leven op de heap en variabelen
                    bevatten referenties naar die objecten.</p>
                <p>Garbage collection ruimt heap-geheugen op voor objecten waar geen enkele referentie meer naartoe
                    bestaat. Variabelen in afgesloten scopes (closures) kunnen data langer in leven houden totdat alle
                    referenties verdwijnen.</p>
                <p>Wanneer een function context afloopt (bijvoorbeeld de functie retourneert), wordt in principe de
                    bijbehorende lexical environment gemarkeerd voor garbage collection. Echter, als er een closure is
                    die dat environment nog gebruikt, blijft het bestaan. Dit verklaart waarom closures state kunnen
                    vasthouden.</p>

                <h4>Best practices voor variabelengebruik</h4>
                <ul>
                    <li><strong>Gebruik const waar mogelijk, let wanneer nodig</strong></li>
                    <li><strong>Vermijd globale variabelen</strong></li>
                    <li><strong>Altijd declareren (voorkom impliciete globals)</strong></li>
                    <li><strong>Houd scope zo klein mogelijk</strong></li>
                    <li><strong>Initialiseer variabelen bij declaratie</strong></li>
                    <li><strong>Kies duidelijke namen</strong></li>
                    <li><strong>Gebruik strict mode of modules</strong></li>
                </ul>
                <p>Door de jaren heen zijn er een aantal best practices ontstaan voor het werken met
                    JavaScript-variabelen. Gebruik <code>const</code> waar mogelijk, <code>let</code> wanneer nodig;
                    vermijd globale variabelen; declareer altijd; houd scope zo klein mogelijk; initialiseer variabelen
                    bij declaratie; kies duidelijke namen; vermijd schaduwvariabelen tenzij nodig; wees voorzichtig met
                    mutatie van objecten; gebruik strict mode of modules; en wees bewust van wat closures meenemen.</p>

                <h4>Veelvoorkomende valkuilen</h4>
                <ul>
                    <li>Verwarring rondom function vs block scope (var vs let)</li>
                    <li>Hoisting surprises</li>
                    <li>Implicit globals / vergeten declaratie</li>
                    <li>Re-declaratie en name collisions</li>
                    <li>const misverstanden (binding vs waarde)</li>
                    <li>Typecoercion en onverwachte undefined/NaN</li>
                    <li>Niet initialiseren (gebruik van undefined)</li>
                    <li>Closures en loop-vallen</li>
                </ul>
                <p><strong>Verwarring rondom function vs block scope (var vs let):</strong> Een klassieke valkuil is
                    aannemen dat een in een blok gedeclareerde variabele ook echt in dat blok blijft. <code>var</code>
                    blijft in function scope bestaan, wat tot onbedoelde effecten kan leiden. Gebruik
                    <code>let/const</code> voor blokscope.
                </p>
                <p><strong>Hoisting surprises:</strong> Omdat <code>var</code>-declaraties hoisting doen, kun je
                    situaties krijgen waar een variabele al bestaat maar nog <code>undefined</code> is. Met
                    <code>let/const</code> krijg je een directe error in de TDZ.
                </p>
                <p><strong>Implicit globals / vergeten declaratie:</strong> In non-strict mode kan een typo een globale
                    variabele creëren. In strict mode leidt dit tot een error – gebruik dit om bugs te voorkomen.</p>
                <p><strong>Re-declaratie en name collisions:</strong> Met <code>var</code> kun je per ongeluk een
                    variabele herdeclareren of een bestaande waarde overschrijven zonder het te weten.
                    <code>let/const</code> helpen omdat een dubbele declaratie niet mag.
                </p>
                <p><strong>const misverstanden:</strong> <code>const</code> slaat op de binding, niet op de inhoud. Een
                    <code>const</code> object kan wel gemuteerd worden. Gebruik <code>const</code> niet voor waarden die
                    moeten veranderen.
                </p>
                <p><strong>Typecoercion en onverwachte undefined/NaN:</strong> Losse typing kan leiden tot onbedoelde
                    stringconcatenatie of <code>NaN</code>. Controleer types met <code>typeof</code> en parse waardes
                    waar nodig.</p>
                <p><strong>Niet initialiseren (undefined):</strong> Een variabele vergeten te initialiseren en daarna
                    gebruiken leidt vaak tot fouten of vreemde resultaten. Initialiseer bij declaratie.</p>
                <p><strong>Closures en loop-vallen:</strong> De closure-loop kwestie met <code>var</code> is berucht.
                    Gebruik <code>let</code> voor loop-indexen of een IIFE in oudere stijl.</p>
            </section>

            <section id="js-operators">
                <h3>Operatoren</h3>
                <p>Operatoren worden gebruikt om waarden toe te wijzen, te vergelijken en rekenkundige bewerkingen uit
                    te voeren.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Voorbeelden</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Aritmetisch</strong></td>
                            <td><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> (modulo),
                                <code>**</code> (macht)
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Toewijzing</strong></td>
                            <td><code>=</code>, <code>+=</code>, <code>-=</code></td>
                        </tr>
                        <tr>
                            <td><strong>Vergelijking</strong></td>
                            <td><code>==</code> (gelijk), <code>===</code> (strikt gelijk), <code>!=</code>,
                                <code>!==</code>, <code>></code>, <code>&lt;</code>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Logisch</strong></td>
                            <td><code>&&</code> (en), <code>||</code> (of), <code>!</code> (niet), <code>??</code>
                                (nullish coalescing)</td>
                        </tr>
                    </tbody>
                </table>
                <pre><code>let x = 10;
 let y = 5;
 console.log(x + y); // 15
 console.log(x > y); // true
 console.log((x > 0) && (y < 0)); // false</code></pre>

                <!-- START: Uitgebreide JavaScript-operatoren toevoeging -->
                <h4>JavaScript-operatoren</h4>
                <h5>Inleiding</h5>
                <p>JavaScript kent een groot aantal operatoren die fungeren als bouwstenen van expressies. Een operator
                    voert een bewerking uit op één of meerdere operanden (waardes of variabelen) en geeft een resultaat
                    terug
                    developer.mozilla.org
                    developer.mozilla.org
                    . Operatoren kunnen side-effects hebben (zoals toewijzing) of puur evalueren tot een waarde. In dit
                    document geven we een uitgebreid overzicht van alle gangbare operatoren in JavaScript,
                    gestructureerd per categorie. We bespreken de syntaxis en het gebruik van elke operator, geven
                    voorbeelden, en belichten bekende edge cases, compatibiliteitsproblemen en valkuilen. Het overzicht
                    is up-to-date met de nieuwste ECMAScript-standaarden (inclusief ES2020+ features zoals optional
                    chaining en nullish coalescing). Waar nodig gebruiken we tabellen voor de duidelijkheid.
                    Hoofdindeling van dit document:</p>
                <ul>
                    <li>Toewijzingsoperatoren (= en samengestelde toewijzingen zoals +=, &&=, ??=, etc.)</li>
                    <li>Vergelijkingsoperatoren (gelijkheidsoperatoren ==/=== enz. en relatiemiddelen &lt;, &gt;, etc.)
                    </li>
                    <li>Aritmetische operatoren (+, -, *, /, %, **, increment ++, decrement --, etc.)</li>
                    <li>Bitwise operatoren (bitbewerkingen: &, |, ^, ~, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;)</li>
                    <li>Logische operatoren (&amp;&amp;, ||, ! – inclusief de nullish coalescing ?? operator)</li>
                    <li>BigInt-operatoren (gebruik van operatoren op BigInt waarden)</li>
                    <li>String-operatoren (stringconcatenatie met +, etc.)</li>
                    <li>Conditionele (ternaire) operator (?:)</li>
                    <li>Komma-operator (, in expressies)</li>
                    <li>Relationale operatoren (in en instanceof)</li>
                    <li>Unaire speciale operatoren (typeof, delete, void, enz.)</li>
                    <li>Optional chaining-operator (?.)</li>
                </ul>
                <p>We zullen per categorie de operatoren toelichten met syntax, voorbeelden en eventuele bijzonderheden.
                </p>
                <p><strong>Opmerking:</strong> JavaScript ondersteunt zowel unair (één operand) als binair (twee
                    operanden) en zelfs één ternaire operator (drie operanden)
                    developer.mozilla.org
                    developer.mozilla.org
                    . De prioriteit (precedence) van operatoren bepaalt de volgorde waarin onderdelen van een expressie
                    worden geëvalueerd. Zo wordt vermenigvuldiging vóór optelling uitgevoerd, tenzij haakjes anders
                    aangeven
                    developer.mozilla.org
                    . Voor een volledig overzicht van operatorprecedentie zie de MDN operator-precedentie tabel. In de
                    voorbeelden hieronder gebruiken we waar nodig haakjes om de evaluatievolgorde te verduidelijken.</p>
                <h5>Toewijzingsoperatoren</h5>
                <p>Toewijzingsoperatoren zetten een waarde in een variabele of objecteigenschap. De eenvoudige
                    toewijzing is de enkelvoudige = operator, die de waarde van de rechter operand toewijst aan de
                    linker operand (bijv. x = 5 kent aan x de waarde 5 toe)
                    developer.mozilla.org
                    . Daarnaast zijn er samengestelde toewijzingsoperatoren als handige afkortingen voor het eerst de
                    waarde berekenen en vervolgens toewijzen. In onderstaande tabel staan de belangrijkste
                    toewijzingsoperatoren met hun betekenis:</p>
                <pre><code>Operator (syntax)	Betekenis (equivalent)
x = y (toewijzing)	Ken de waarde van y toe aan x.
x += y (optellingstoewijzing)	x = x + y
developer.mozilla.org
.
x -= y (aftrekttoewijzing)	x = x - y
developer.mozilla.org
.
x *= y (vermenigvuldiging)	x = x * y
developer.mozilla.org
.
x /= y (delingstoewijzing)	x = x / y
developer.mozilla.org
.
x %= y (resttoewijzing)	x = x % y
developer.mozilla.org
.
x **= y (machtsverheffing)	x = x ** y
developer.mozilla.org
.
x <<= y (links shift)	x = x << y (bitwise left shift)
developer.mozilla.org
.
x >>= y (rechts shift)	x = x >> y (sign-propagating right shift)
developer.mozilla.org
.
x >>>= y (nulvullende shift)	x = x >>> y (zero-fill right shift)
developer.mozilla.org
.
x &= y (bitwise AND)	x = x & y
developer.mozilla.org
.
x ^= y (bitwise XOR)	x = x ^ y
developer.mozilla.org
.
`x	= y` (bitwise OR)
x &&= y (logische AND-toew.)	Equivalent aan x && (x = y)
developer.mozilla.org
. Zie toelichting hieronder.
`x	
x ??= y (nullish coalescing)	Equivalent aan x ?? (x = y)
developer.mozilla.org
.</code></pre>
                <p>Bovenstaande laatste drie logische toewijzingsoperatoren (&&=, ||=, ??=) zijn relatief nieuw
                    (ES2021). Ze combineren een logische operatie met een toewijzing
                    developer.mozilla.org
                    . Bijvoorbeeld a &&= b zal alleen a vervangen door b als a aanvankelijk truthy was (anders blijft a
                    onveranderd)
                    developer.mozilla.org
                    . Likewise, x ??= y wijzigt x alleen als x momenteel null of undefined is (de "nullish" waarde)
                    developer.mozilla.org
                    . Dit is handig om alleen in specifieke gevallen een standaardwaarde toe te wijzen. Gebruik op
                    objecteigenschappen: De linker kant van een toewijzingsoperator kan ook een eigenschap van een
                    object of een element van een array aanduiden. Bijvoorbeeld obj.key = waarde of arr[index] = waarde
                    kent een waarde toe aan een objectveld respectievelijk arraypositie
                    developer.mozilla.org
                    developer.mozilla.org
                    . Als de linker expressie geen object oplevert (bijv. een primitieve waarde), heeft een toewijzing
                    aan een eigenschap geen effect – in strict mode veroorzaakt val.x = 3 zelfs een fout als val geen
                    object is
                    developer.mozilla.org
                    developer.mozilla.org
                    . Destructuring assignments: JavaScript ondersteunt destructuring om in één keer waarden uit arrays
                    of objecten toe te wijzen aan meerdere variabelen. Bijvoorbeeld: const [a, b] = [1, 2] kent a=1 en
                    b=2 toe in één expressie
                    developer.mozilla.org
                    developer.mozilla.org
                    . Destructuring is syntactisch geen aparte operator maar een handige uitbreiding op toewijzing.
                    Evaluatievolgorde en chaining: Een toewijzingsexpressie evalueert naar de toegewezen waarde. Zo
                    levert (x = f()) zelf de returnwaarde van f() op, wat doorgekoppeld kan worden
                    developer.mozilla.org
                    developer.mozilla.org
                    . Hierdoor is het mogelijk toewijzingen te chainen, bv. a = b = 5; resulteert in zowel a als b
                    gelijk aan 5. Hoewel dit werkt, kan chaining of in andere expressies nesten van toewijzingen code
                    onduidelijk maken, en veel stijlgidsen raden het af
                    developer.mozilla.org
                    developer.mozilla.org
                    . Wees ook voorzichtig dat je in conditie-statements onderscheid maakt tussen == (vergelijking) en =
                    (toewijzing) – een veelvoorkomende fout is per ongeluk if(x = 0){...} te schrijven, wat x de waarde
                    0 toekent en vervolgens altijd false is, in plaats van if(x == 0) voor een vergelijking.</p>
                <!-- EINDE: Uitgebreide JavaScript-operatoren toevoeging (deel 1) -->

                <h5>Vergelijkingsoperatoren</h5>
                <p>Vergelijkingsoperatoren vergelijken twee waarden en retourneren een Boolean (true of false) op basis
                    van de uitkomst
                    developer.mozilla.org
                    . Ze worden gebruikt voor gelijkheid/ongelijkheid en voor groter/kleiner vergelijkingen:</p>
                <ul>
                    <li>Losse gelijkheid (==) – Geeft true als de operanden gelijk zijn na eventuele typeconversie
                        developer.mozilla.org
                        . Bijvoorbeeld 5 == "5" resulteert in true omdat de string "5" geconverteerd wordt naar nummer 5
                        developer.mozilla.org
                        . Ook null == undefined is true (deze twee zijn gelijk in losse vergelijking)
                        lia.disi.unibo.it
                        . Pas op: door automatische typeconversie kunnen onverwachte waarheden ontstaan (zie Valkuilen
                        hieronder).</li>
                    <li>Losse ongelijkheid (!=) – Geeft true als operanden verschillend zijn na typecoercion.
                        Bijvoorbeeld 5 != "7" is true, maar ook 5 != "5" is false (want "5" wordt 5)
                        developer.mozilla.org
                        .</li>
                    <li>Strikte gelijkheid (===) – Geeft true als beide operanden zonder typeconversie gelijk én van
                        zelfde type zijn
                        developer.mozilla.org
                        . Dit is meestal de aanbevolen vergelijking, omdat het eenduidiger is. Bijvoorbeeld 5 === "5" is
                        false (nummer vs string) terwijl 5 === 5 true is
                        developer.mozilla.org
                        . Ook belangrijk: NaN === NaN is false (NaN is nooit gelijk aan zichzelf)
                        lia.disi.unibo.it
                        . Voor een veilige NaN-check kunt u Number.isNaN() of Object.is(NaN, NaN) gebruiken (de laatste
                        beschouwt NaN gelijk aan NaN en onderscheidt +0 van -0)
                        lia.disi.unibo.it
                        .</li>
                    <li>Strikte ongelijkheid (!==) – Geeft true als operanden niet gelijk zijn of van verschillend type
                        zijn
                        developer.mozilla.org
                        .</li>
                    <li>Groter dan (>) – a > b is waar als a groter is dan b
                        developer.mozilla.org
                        .</li>
                    <li>Groter dan of gelijk (>=) – a >= b is waar als a groter of gelijk is aan b
                        developer.mozilla.org
                        .</li>
                    <li>Kleiner dan (<) – a < b is waar als a kleiner is dan b developer.mozilla.org .</li>
                    <li>Kleiner dan of gelijk (<=) – a <=b is waar als a kleiner of gelijk is aan b
                            developer.mozilla.org .</li>
                </ul>
                <p>Enkele aandachtspunten bij vergelijkingen:
                    Wanneer de operanden niet van dezelfde type zijn, zal de losse vergelijking (==) proberen ze naar
                    een gemeenschappelijk type te converteren
                    developer.mozilla.org
                    . Dit gebeurt volgens vaste regels (booleans worden naar nummer 0/1, strings naar nummers indien
                    mogelijk, objecten naar primitieve via waardeOf/toString, etc.). Deze typecoercion kan tot
                    verrassingen leiden (zie voorbeelden hieronder).
                    Strikte vergelijking (===/!==) daarentegen doet geen typeconversie. Verschillende type =
                    ongetwijfeld ongelijk
                    lia.disi.unibo.it
                    . Dit maakt === vaak veiliger in gebruik omdat "0" niet per ongeluk gelijk is aan 0, etc.
                    Strings worden lexico‐grafisch vergeleken op Unicode volgorde wanneer > of < wordt gebruikt
                        developer.mozilla.org . Bijvoorbeeld "2" < "12" is false omdat "2" als string niet kleiner is
                        dan "12" (vergelijking karakter voor karakter). Bij getallen is delen door nul gedefinieerd:
                        elke positieve deling door 0 resulteert in Infinity en negatieve in -Infinity. Infinity gedraagt
                        zich als een zeer grote resp. kleine waarde in vergelijkingen (bijv. Infinity> 1000000 is true).
                        Let op dat NaN met geen enkel getal (ook zichzelf niet) gelijk is en in ordinale vergelijkingen
                        altijd false oplevert (zelfs NaN < 100 is false). </p>
                            <p>Enkele valkuilen (losse gelijkheid): Door typecoercion kunnen schijnbaar ongerelateerde
                                waarden als gelijk worden gezien met ==. Enkele voorbeelden:</p>
                            <pre><code>js
Copy
Edit
0 == false    // true, want false wordt 0 bij conversie:contentReference[oaicite:51]{index=51}:contentReference[oaicite:52]{index=52}
"" == false   // true, lege string wordt 0, false wordt 0
" \t\n" == 0  // true, string met alleen whitespace wordt 0
[] == ""      // true, [] -> "" (toString) en "" == "" 
[] == 0       // true, [] -> "" -> 0
[0] == 0      // true, [0] -> "0" -> 0
null == undefined  // true, speciale regel dat deze gelijk zijn:contentReference[oaicite:53]{index=53}</code></pre>

                            <h5>Aritmetische operatoren</h5>
                            <p>Aritmetische operatoren voeren wiskundige berekeningen uit op numerieke operanden en
                                geven een numeriek resultaat terug
                                developer.mozilla.org
                                . De basisbewerkingen zijn:
                                Optelling (+) – telt twee waarden op. Bijvoorbeeld 2 + 3 resulteert in 5. (Zie ook
                                sectie String-operatoren voor het gebruik van + met strings.)
                                Aftrekking (-) – trekt de rechter operand af van de linker. Bijvoorbeeld 7 - 5 is 2.
                                Vermenigvuldiging (*) – vermenigvuldigt twee getallen. 6 * 7 is 42.
                                Deling (/) – deelt de linker operand door de rechter. 5 / 2 is 2.5. Let op: deling door
                                0 geeft Infinity of -Infinity afhankelijk van het teken
                                developer.mozilla.org
                                . 0/0 resulteert in NaN.</p>
                            <p>Daarnaast biedt JavaScript nog enkele extra rekenkundige operatoren:</p>
                            <table>
                                <thead>
                                    <tr>
                                        <th>Operator</th>
                                        <th>Beschrijving &amp; voorbeeld</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Modulo (%)</td>
                                        <td>Geeft de rest van een gehele deling terug
                                            developer.mozilla.org
                                            . Bijvoorbeeld 17 % 5 is 2. Werkt ook met negatieve dividend: -5 % 2 geeft
                                            -1 in JavaScript.</td>
                                    </tr>
                                    <tr>
                                        <td>Exponentiatie (**)</td>
                                        <td>Verheft het linkernummer tot de macht van de rechter (machtsverheffing)
                                            developer.mozilla.org
                                            . Bijvoorbeeld 2 ** 3 is 8 (2 tot de macht 3), en 10 ** -1 is 0.1
                                            developer.mozilla.org
                                            . Introduceerd in ES2016 als infix-operator.</td>
                                    </tr>
                                    <tr>
                                        <td>Increment (++)</td>
                                        <td>Unaire operator die 1 optelt bij zijn operand
                                            developer.mozilla.org
                                            . Prefix en postfix varianten.</td>
                                    </tr>
                                    <tr>
                                        <td>Decrement (--)</td>
                                        <td>Unaire operator die 1 aftrekt, analoog aan ++
                                            developer.mozilla.org
                                            .</td>
                                    </tr>
                                    <tr>
                                        <td>Unair plus (+)</td>
                                        <td>Zet operand om naar een nummer (indien mogelijk)
                                            developer.mozilla.org
                                            .</td>
                                    </tr>
                                    <tr>
                                        <td>Unair min (-)</td>
                                        <td>Negatie van de operand (na nummerconversie)
                                            developer.mozilla.org
                                            .</td>
                                    </tr>
                                </tbody>
                            </table>
                            <p>Voorbeeld (increment &amp; decrement):</p>
                            <pre><code>js
Copy
Edit
let a = 5;
console.log(a++); // output: 5  (postfix, geeft oude waarde terug, a wordt 6)
console.log(a);   // output: 6  (a is nu verhoogd)
console.log(++a); // output: 7  (prefix, a eerst verhogen van 6 naar 7, dan resultaat 7)
console.log(a);   // output: 7</code></pre>
                            <p>Valkuilen bij aritmetica:
                                JavaScript gebruikt double-precision floating point (IEEE 754)... 0.1 + 0.2 is niet
                                exact 0.3 maar 0.30000000000000004.
                                De + operator heeft een dubbele rol ... "5" + 1 wordt "51" ... terwijl "5" - 1 4 wordt
                                developer.mozilla.org
                                developer.mozilla.org
                                .
                                NaN gedraagt zich “besmettelijk” ...
                                Speciale waarden: Infinity ... Negatief nul (-0) ... Object.is(0, -0)
                                lia.disi.unibo.it
                                .</p>

                            <h5>Bitwise operatoren</h5>
                            <p>Bitwise (bit-gewijze) operatoren behandelen hun operanden als 32-bit geheel getallen (in
                                twee-complement voor negatieve getallen) en voeren bitniveau bewerkingen uit
                                developer.mozilla.org
                                . Hoewel de invoer en uitvoer reguliere Number waarden zijn, wordt intern elke Number
                                eerst naar een 32-bit integer geconverteerd
                                developer.mozilla.org
                                . Bitwise operaties zijn handig voor lage-level manipulaties...</p>
                            <p>Bitwise voorbeeld:</p>
                            <pre><code>js
Copy
Edit
const x = 6;        // binaire representatie:  000...0110 
const y = 10;       // binaire representatie:  000...1010
console.log(x &amp; y); // 2  -> binair 0010 (alleen bit 2 aan in beide):contentReference[oaicite:80]{index=80}
console.log(x | y); // 14 -> binair 1110 (bits gecombineerd):contentReference[oaicite:81]{index=81}
console.log(x ^ y); // 12 -> binair 1100 (verschillen):contentReference[oaicite:82]{index=82}
console.log(~x);    // -7 -> ~0110 = ...1001, tweecomplement = -7:contentReference[oaicite:83]{index=83}
console.log(y &lt;&lt; 1);// 20 -> 1010 &lt;&lt; 1 = 10100 (binair 20)
console.log(y &gt;&gt; 1);// 5  -> 1010 &gt;&gt; 1 = 0101 (binair 5, was positief dus gelijk aan floor(y/2))</code></pre>
                            <p>Eigenschappen en valkuilen:
                                32-bit beperking
                                developer.mozilla.org
                                ; Negatieve getallen; Gebruik voor snelheden; Bitwise NOT voor indexOf check; >>> op
                                BigInt bestaat niet
                                developer.mozilla.org
                                developer.mozilla.org
                                .</p>

                            <h5>Logische operatoren</h5>
                            <p>Logische operatoren werken doorgaans op booleaanse waarden en retourneren ook een
                                Boolean. JavaScript's <code>&&</code> (AND), <code>||</code> (OR) en <code>!</code>
                                (NOT) gedragen zich in die gevallen zoals verwacht (true && false is false, etc.).
                                Echter, deze operatoren kunnen met niet-Boolean operanden werken en retourneren dan één
                                van de operanden in plaats van expliciet true/false. Ze functioneren dan als "value
                                selection operators" – zie hieronder.</p>
                            <ul>
                                <li><strong>Logische EN (&&)</strong> – Evalueert <code>expr1 && expr2</code>. Als
                                    <code>expr1</code> falsy is (d.w.z. bij conversie naar bool false, zoals
                                    <code>0</code>, <code>""</code>, <code>null</code>, <code>undefined</code>,
                                    <code>NaN</code>), dan geeft de hele expressie <code>expr1</code> terug
                                    (short-circuit). Is <code>expr1</code> truthy, dan wordt <code>expr2</code>
                                    geëvalueerd en geretourneerd. Met booleans: alleen <code>true && true</code> is
                                    true. Algemeen: <code>a && b</code> geeft <em>b</em> terug als <em>a</em> truthy
                                    was, anders <em>a</em>.
                                </li>
                                <li><strong>Logische OF (||)</strong> – Evalueert <code>expr1 || expr2</code>. Als
                                    <code>expr1</code> truthy is, wordt die direct teruggegeven (short-circuit) en kijkt
                                    men niet naar <code>expr2</code>. Als <code>expr1</code> falsy is, wordt de waarde
                                    van <code>expr2</code> geretourneerd. Met booleans: <code>false || true</code> geeft
                                    true. Algemeen: <code>"Cat" || "Dog"</code> geeft <code>"Cat"</code>.
                                </li>
                                <li><strong>Logische NIET (!)</strong> – Una ire operator, geeft de negatie van een
                                    waarheidswaarde: <code>!expr</code> is false als <code>expr</code> truthy was, en
                                    true als <code>expr</code> falsy was. Deze operator converteert zijn operand
                                    impliciet naar boolean. Twee keer toepassen <code>!!expr</code> wordt vaak gebruikt
                                    om expliciet naar een true/false te converteren.</li>
                            </ul>
                            <p><strong>Truthy/falsy</strong>: In JavaScript zijn niet alleen booleans waar of onwaar.
                                Waarden als <code>0</code>, <code>0n</code> (BigInt nul), lege string <code>""</code>,
                                <code>null</code>, <code>undefined</code>, en <code>NaN</code> worden als falsy
                                beschouwd; vrijwel alle andere waarden (inclusief objecten, non-zero nummers, niet-lege
                                strings, arrays, enz.) zijn truthy. Dit betekent dat bij gebruik van
                                <code>&&</code>/<code>||</code> de "waarheid" van een operand bepaalt of er
                                doorgesprongen wordt.
                            </p>
                            <p><strong>Short-circuit evaluatie</strong>: <code>&&</code> en <code>||</code> gebruiken
                                kortsluiting: de rechter operand wordt niet geëvalueerd als de uitkomst al bekend is na
                                de linker operand. Bijvoorbeeld, in <code>expr1 && expr2</code> zal <code>expr2</code>
                                alleen uitgevoerd worden als <code>expr1</code> truthy was. In
                                <code>expr1 || expr2</code> wordt <code>expr2</code> alleen uitgevoerd als
                                <code>expr1</code> falsy was. Dit wordt vaak benut:
                                <code>obj && obj.doSomething()</code> roept de methode alleen aan als <code>obj</code>
                                niet null/undefined is. Bij <code>||</code> wordt vaak iets als default gebruikt:
                                <code>let val = input || "default"</code> (maar zie hierna over <code>??</code>).
                            </p>
                            <pre><code>"Cat" && "Dog"; // "Dog" (eerste is truthy, dus tweede waarde is resultaat)
0 && "hey";       // 0 (falsy links, dus meteen die 0 terug)
"Cat" || "Dog"; // "Cat" (eerste operand was truthy)
"" || "Hallo";   // "Hallo" (lege string is falsy)
!0;                // true (0 is falsy)
!!42;              // true (forceer bool)</code></pre>
                            <h6>Nullish coalescing (??)</h6>
                            <p>Deze operator is een variant van <code>||</code> met een belangrijk verschil:
                                <code>expr1 ?? expr2</code> retourneert <code>expr1</code> als die niet nullish is (dus
                                niet <code>null</code> of <code>undefined</code>), anders retourneert het
                                <code>expr2</code>. Anders dan <code>||</code> negeert <code>??</code> falsy waarden
                                zoals <code>0</code> of <code>""</code> niet. Dit is nuttig voor defaults alleen wanneer
                                iets echt afwezig is (null/undefined) en niet wanneer het bijvoorbeeld 0 is.
                            </p>
                            <pre><code>let count = 0;
console.log(count || 42); // 42, want 0 is falsy en || pakt rechter operand
console.log(count ?? 42); // 0, want count is niet null/undefined, dus ?? pakt linker</code></pre>
                            <p><strong>Belangrijk</strong>: Je kunt <code>??</code> niet zonder meer mengen met
                                <code>&&</code> of <code>||</code> zonder haakjes te gebruiken. Uitdrukking
                                <code>a || b ?? c</code> is syntactisch ongeldig (SyntaxError). Je moet expliciet
                                groeperen, bijvoorbeeld <code>(a || b) ?? c</code> of <code>a || (b ?? c)</code>
                                afhankelijk van de bedoeling.
                            </p>
                            <h6>Logische toewijzingen</h6>
                            <p>Zoals bij toewijzingsoperatoren bestaan er combinaties <code>&&=</code>, <code>||=</code>
                                en <code>??=</code> om conditioneel te assignen. Bijvoorbeeld
                                <code>user.isAdmin ||= checkAdmin();</code> zal <code>user.isAdmin</code> alleen
                                overschrijven als het momenteel falsy is. Deze operatoren voeren vergelijkbare
                                short-circuit logica uit en kunnen side-effects in de rechter operand vermijden als niet
                                nodig.
                            </p>
                            <pre><code>let a = 0;
a ||= 5;   // a wordt 5 omdat 0 falsy is
let b = 1;
b &&= 3;   // b wordt 3 omdat 1 truthy is
let c;
c ??= 10;  // c wordt 10 omdat c nullish (undefined) was</code></pre>
                            <p><strong>Valkuilen</strong>:
                                Onthoud dat <code>&&</code> en <code>||</code> geen booleans hoeven te retourneren; ze
                                geven een van de operandwaarden terug. Pas op met gebruik van <code>||</code> als
                                default wanneer <code>0</code> of <code>""</code> geldige waarden kunnen zijn (gebruik
                                dan <code>??</code>). De operator <code>&&</code> heeft een hogere prioriteit dan
                                <code>||</code> en <code>??</code> ligt daar net tussenin (lager dan <code>&&</code>,
                                net onder <code>||</code>). In complexe expressies met gemengde logische operators is
                                het vaak duidelijker haakjes te zetten.
                            </p>
                            <pre><code>js
Copy
Edit
let count = 0;
console.log(count || 42); // 42, want 0 is falsy en || pakt rechter operand
console.log(count ?? 42); // 0, want count is niet null/undefined, dus ?? pakt linker</code></pre>
                            <pre><code>js
Copy
Edit
console.log(null ?? "leeg");      // "leeg"
console.log(undefined ?? 5);      // 5
console.log(false ?? "ja");       // false
console.log("" || "default");     // "default"
console.log("" ?? "default");     // ""</code></pre>

                            <h5>BigInt-operatoren</h5>
                            <p>BigInt ondersteunt rekenkundige operatoren op gehele getallen van willekeurige grootte.
                                Meng geen BigInt en Number in één expressie (TypeError).
                                developer.mozilla.org
                                developer.mozilla.org
                                developer.mozilla.org
                                developer.mozilla.org
                                developer.mozilla.org
                                developer.mozilla.org
                                developer.mozilla.org
                            </p>
                            <pre><code>js
Copy
Edit
const a = 9007199254740993n;        // dit is 2^53 + 1
const b = 2n;
console.log(a + b);                // 9007199254740995n
console.log(Number(a) + 2);        // 9007199254740994
console.log(5n / 2n);              // 2n
console.log(5n / 2);               // TypeError</code></pre>

                            <h5>String-operatoren</h5>
                            <p>JavaScript heeft geen speciale operatoren voor strings behalve concatenatie met +.
                                Shorthand <code>+=</code> werkt ook.</p>
                            <pre><code>js
Copy
Edit
console.log("Mijn " + "string"); // "Mijn string"</code></pre>
                            <pre><code>js
Copy
Edit
let bericht = "Hallo";
bericht += " wereld";
console.log(bericht); // "Hallo wereld"</code></pre>

                            <h5>De conditionele (ternaire) operator</h5>
                            <pre><code>js
Copy
Edit
const leeftijd = 17;
const status = (leeftijd >= 18) ? "volwassen" : "minderjarig";
console.log(status); // "minderjarig"</code></pre>

                            <h5>De komma-operator</h5>
                            <pre><code>js
Copy
Edit
let x = 0;
const result = (x += 5, x * 2);
console.log(result); // 10</code></pre>
                            <pre><code>js
Copy
Edit
for (let i = 0, j = 9; i < j; i++, j--) {
   console.log(`a[${i}][${j}]`);
}</code></pre>

                            <h5>Relationale operatoren (in en instanceof)</h5>
                            <pre><code>js
Copy
Edit
const obj = { a: 1 };
console.log("a" in obj);      // true
console.log("toString" in obj); // true (geërfd)
console.log(0 in ["x", "y"]); // true
console.log("length" in ["x","y"]); // true</code></pre>
                            <pre><code>js
Copy
Edit
const arr = [1,2,3];
console.log(arr instanceof Array);    // true
console.log(arr instanceof Object);   // true
console.log(arr instanceof Date);     // false 
console.log([] instanceof Array);     // true
console.log(() => {} instanceof Function); // true</code></pre>

                            <h5>Unaire operatoren en overige speciale operatoren</h5>
                            <h6>typeof operator</h6>
                            <pre><code>js
Copy
Edit
typeof 42
typeof "tekst"
typeof true
typeof undefined
typeof Symbol()
typeof 10n
typeof function(){}
typeof {a:1}
typeof [1,2,3]
typeof null</code></pre>
                            <h6>delete operator</h6>
                            <pre><code>js
Copy
Edit
const obj = { x: 42 };
console.log("x" in obj); // true
delete obj.x;            
console.log("x" in obj); // false</code></pre>
                            <pre><code>js
Copy
Edit
const obj2 = { val: 1 };
console.log(obj2.toString);       // geërfd
obj2.toString = () => "YOLO";
console.log(obj2.toString());     // "YOLO"
delete obj2.toString;
console.log(obj2.toString());     // "[object Object]"</code></pre>
                            <h6>void operator</h6>
                            <pre><code>js
Copy
Edit
void 0; // undefined</code></pre>

                            <h5>De optional chaining-operator (?.)</h5>
                            <pre><code>js
Copy
Edit
const user = { name: "Alice", pet: { name: "Fluffy" } };
console.log(user.pet?.name);        // "Fluffy"
console.log(user.pet?.breed);       // undefined
console.log(user.car?.model);       // undefined</code></pre>
                            <pre><code>js
Copy
Edit
database.getUser(id)?.getAddress()?.country;
someOptionalCallback?.("Hi there");
nestedArray?.[10]?.[2];</code></pre>

                            <h5>Samenvattende tips en valkuilen</h5>
                            <ul>
                                <li>Gebruik strikt gelijk (===) in plaats van los (==)
                                    developer.mozilla.org
                                    lia.disi.unibo.it
                                    .</li>
                                <li>Let op bij + met strings vs nummers.</li>
                                <li>Wees voorzichtig met ++/-- in complexe expressies.</li>
                                <li>Bitwise operaties beperken tot 32-bit.</li>
                                <li>Gebruik ?. en ?? voor optionele waarden en defaults
                                    developer.mozilla.org
                                    developer.mozilla.org
                                    .</li>
                                <li>Verwijder objectprops met beleid; geen delete op array-elementen.</li>
                                <li>Comma operator vermijden tenzij nodig.</li>
                                <li>Ken operatorprecedentie of gebruik haakjes.</li>
                                <li>Gebruik moderne idioms (template literals, includes, Object.hasOwn, logisch
                                    toewijzing &&=, ||=, ??=).</li>
                            </ul>

                            <script>
                                (function () {
                                    var section = document.getElementById('js-operators');
                                    if (!section) return;
                                    var codeBlocks = section.querySelectorAll('pre > code');
                                    codeBlocks.forEach(function (codeEl, idx) {
                                        // Skip if a live runner already added just after this code block
                                        if (codeEl.parentElement && codeEl.parentElement.nextElementSibling && codeEl.parentElement.nextElementSibling.classList && codeEl.parentElement.nextElementSibling.classList.contains('live-example')) return;
                                        var wrapper = document.createElement('div');
                                        wrapper.className = 'live-example';
                                        var btn = document.createElement('button');
                                        btn.textContent = 'Run';
                                        var out = document.createElement('pre');
                                        out.id = 'jsop-out-' + idx;
                                        btn.addEventListener('click', function () {
                                            var raw = codeEl.innerText || codeEl.textContent || '';
                                            var sanitized = raw
                                                .split('\n')
                                                .filter(function (line) {
                                                    var t = line.trim();
                                                    if (t === 'js' || t === 'Copy' || t === 'Edit') return false;
                                                    if (t.startsWith('Copy') || t.startsWith('Edit')) return false;
                                                    return true;
                                                })
                                                .map(function (line) {
                                                    return line.replace(/:contentReference\[[^\]]+\]\{index=\d+\}/g, '');
                                                })
                                                .join('\n');
                                            var logs = [];
                                            var originalLog = console.log;
                                            try {
                                                console.log = function () {
                                                    try {
                                                        var msg = Array.prototype.map.call(arguments, function (a) { return typeof a === 'object' ? JSON.stringify(a) : String(a); }).join(' ');
                                                        logs.push(msg);
                                                    } catch (e) {
                                                        logs.push(Array.prototype.join.call(arguments, ' '));
                                                    }
                                                };
                                                try { eval(sanitized); } catch (e) { logs.push('Error: ' + e.message); }
                                            } finally {
                                                console.log = originalLog;
                                            }
                                            out.textContent = logs.join('\n');
                                        });
                                        wrapper.appendChild(btn);
                                        wrapper.appendChild(out);
                                        codeEl.parentElement.insertAdjacentElement('afterend', wrapper);
                                    });
                                })();
                            </script>
            </section>

            <section id="js-data-types">
                <h3>Datatypes</h3>
                <p>JavaScript heeft verschillende ingebouwde datatypes.</p>
                <h4>Numbers</h4>
                <p>Voor alle numerieke waarden, zowel gehele getallen als decimalen.</p>
                <pre><code>let length = 16;       // Geheel getal
let weight = 7.5;      // Decimaal getal
let result = 10 / "a"; // NaN (Not a Number)</code></pre>
                <h4>Booleans</h4>
                <p>Kan alleen <code>true</code> of <code>false</code> zijn. Wordt vaak gebruikt in conditionele logica.
                </p>
                <pre><code>let x = 5;
let y = 5;
let z = 6;
(x == y) // Geeft true terug
(x == z) // Geeft false terug</code></pre>
            </section>

            <section id="js-functions">
                <h3>Functies</h3>
                <p>Een functie is een herbruikbaar blok code dat een specifieke taak uitvoert.</p>
                <pre><code>// Functie declaratie
function greet(name) {
  return "Hallo, " + name;
}

// Arrow functie (ES6+)
const add = (a, b) => a + b;

// Functie aanroepen
let greeting = greet("Wereld"); // "Hallo, Wereld"
let sum = add(5, 3); // 8</code></pre>
            </section>

            <section id="js-objects">
                <h3>Objecten</h3>
                <p>Een object is een verzameling van key-value paren, waarbij de keys (sleutels) strings zijn en de
                    values (waarden) elk datatype kunnen zijn.</p>
                <pre><code>const car = {
  type: "Fiat",
  model: "500",
  color: "white",
  start: function() {
    console.log("De motor start.");
  }
};

// Eigenschappen benaderen
console.log(car.model); // "500"
console.log(car["color"]); // "white"

// Methode aanroepen
car.start();</code></pre>
            </section>

            <section id="js-arrays">
                <h3>Arrays</h3>
                <p>Een array is een speciaal type object dat een geordende lijst van waarden bevat.</p>
                <pre><code>const cars = ["Saab", "Volvo", "BMW"];
console.log(cars[0]); // "Saab"

cars.push("Audi"); // Voegt een element toe aan het einde

cars.forEach(car => {
  console.log(car);
});</code></pre>
            </section>

            <section id="js-conditionals">
                <h3>Conditionals (If/Else, Switch)</h3>
                <p>Conditionele statements worden gebruikt om verschillende acties uit te voeren op basis van
                    verschillende condities.</p>
                <h4>If/Else</h4>
                <pre><code>const time = 14;
if (time < 12) {
  console.log("Goedemorgen");
} else if (time < 18) {
  console.log("Goedemiddag");
} else {
  console.log("Goedenavond");
}</code></pre>
                <h4>Switch</h4>
                <pre><code>const day = new Date().getDay();
switch (day) {
  case 0:
    console.log("Zondag");
    break;
  case 6:
    console.log("Zaterdag");
    break;
  default:
    console.log("Werkdag");
}</code></pre>
            </section>

            <section id="js-loops">
                <h3>Loops (For, While)</h3>
                <p>Loops kunnen een blok code een bepaald aantal keren uitvoeren.</p>
                <h4>For Loop</h4>
                <p>Herhaalt een blok code zolang een conditie waar is.</p>
                <pre><code>for (let i = 0; i < 5; i++) {
  console.log("Het getal is " + i);
}</code></pre>
                <h4>For...In & For...Of</h4>
                <p><code>for...in</code> itereert over de eigenschappen van een object. <code>for...of</code> itereert
                    over de waarden van een "iterable" (zoals een array).</p>
                <pre><code>// for...in
const person = { fname: "John", lname: "Doe" };
for (let key in person) {
  console.log(person[key]); // "John", dan "Doe"
}

// for...of
const letters = ["a", "b", "c"];
for (let x of letters) {
  console.log(x); // "a", dan "b", dan "c"
}</code></pre>
                <h4>While Loop</h4>
                <p>Herhaalt een blok code zolang een gespecificeerde conditie waar is.</p>
                <pre><code>let i = 0;
while (i < 5) {
  console.log("Het getal is " + i);
  i++;
}</code></pre>
            </section>

            <section id="js-iterators">
                <h3>Iterators</h3>
                <p>Een iterator is een object dat een `next()` methode implementeert, die een object teruggeeft met twee
                    eigenschappen: `value` en `done`.</p>
                <pre><code>const myArray = ['a', 'b', 'c'];
const it = myArray[Symbol.iterator]();

console.log(it.next().value); // 'a'
console.log(it.next().value); // 'b'</code></pre>
            </section>

            <section id="js-typeof">
                <h3>typeof</h3>
                <p>De <code>typeof</code> operator geeft het datatype van een variabele of expressie terug als een
                    string.</p>
                <pre><code>typeof "John"         // Geeft "string"
typeof 3.14           // Geeft "number"
typeof true           // Geeft "boolean"
typeof {name:'John'}  // Geeft "object"</code></pre>
            </section>

            <section id="js-tostring">
                <h3>toString()</h3>
                <p>De <code>toString()</code> methode converteert een waarde naar een string.</p>
                <pre><code>let myNumber = 123;
myNumber.toString(); // geeft "123"

(100 + 23).toString(); // geeft "123"</code></pre>
            </section>

            <section id="js-cheatsheet">
                <h3>JavaScript Cheatsheet</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Categorie</th>
                            <th>Syntaxis & Voorbeelden</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Variabelen</strong></td>
                            <td><code>let myVar = 10;</code>, <code>const PI = 3.14;</code></td>
                        </tr>
                        <tr>
                            <td><strong>Functies</strong></td>
                            <td><code>function hi() {}</code>, <code>const hi = () => {}</code></td>
                        </tr>
                        <tr>
                            <td><strong>Conditionals</strong></td>
                            <td><code>if (x > 0) {} else {}</code>, <code>switch(val) {}</code></td>
                        </tr>
                        <tr>
                            <td><strong>Loops</strong></td>
                            <td><code>for(let i=0;..){}</code>, <code>while(cond){}</code>,
                                <code>for(const item of arr){}</code>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Arrays</strong></td>
                            <td><code>[1, 2, 3]</code>, <code>.push()</code>, <code>.map()</code>,
                                <code>.filter()</code>, <code>.forEach()</code>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Objecten</strong></td>
                            <td><code>{ key: 'value' }</code>, <code>Object.keys()</code>, destructuring
                                <code>const {key} = obj</code>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>DOM</strong></td>
                            <td><code>document.querySelector()</code>, <code>.addEventListener()</code>,
                                <code>.createElement()</code>, <code>.textContent</code>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Async</strong></td>
                            <td><code>new Promise()</code>, <code>.then().catch()</code>,
                                <code>async function() {}</code>, <code>await</code>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- ====================================================================== -->
            <!-- =========================== TYPESCRIPT =============================== -->
            <!-- ====================================================================== -->
            <section id="typescript">
                <h2>TypeScript</h2>
                <p>TypeScript is een "superset" van JavaScript, ontwikkeld door Microsoft. Het voegt statische typering
                    toe aan de taal. Dit helpt om fouten vroegtijdig te vinden (tijdens het ontwikkelen in plaats van
                    tijdens runtime) en maakt het werken met grote codebases eenvoudiger.</p>
            </section>

            <section id="ts-intro">
                <h3>Introductie & Setup</h3>
                <p>TypeScript-code wordt gecompileerd naar JavaScript. Je kunt de TypeScript-compiler installeren via
                    npm (Node Package Manager):</p>
                <pre><code>npm install -g typescript</code></pre>
                <p>Vervolgens compileer je een `.ts` bestand naar een `.js` bestand met het commando:</p>
                <pre><code>tsc mijnscript.ts</code></pre>
            </section>

            <section id="ts-types">
                <h3>Types (Basis & Geavanceerd)</h3>
                <p>De kern van TypeScript is het toevoegen van types aan variabelen, functieparameters en returnwaardes.
                </p>

                <h4 id="ts-inleiding">Inleiding</h4>
                <p>TypeScript is een populaire superset van JavaScript die statische typecontrole toevoegt aan de taal.
                    Dit betekent dat je variabelen, functies, objecten enz. van tevoren van types kunt voorzien,
                    waardoor veel fouten al bij het compileren worden opgemerkt. In deze gids nemen we alle belangrijke
                    aspecten van het TypeScript-type systeem onder de loep – van basis types en interfaces tot generics,
                    ingebouwde utility types, ingebouwde klassen en veelgebruikte patronen en toepassingen. We richten
                    ons op ontwikkelaars met een beginnend tot novice-niveau in TypeScript, en voorzien bij elk
                    onderwerp korte uitleg én codevoorbeelden om te illustreren hoe je ze gebruikt.</p>
                <p>We behandelen onder andere:</p>
                <ul>
                    <li>De basis types in TypeScript (primitieve types zoals <code>string</code> en <code>number</code>,
                        speciale types als <code>any</code>, <code>unknown</code>, <code>void</code>,
                        <code>never</code>, etc.).
                    </li>
                    <li>Complexere types zoals literal types, union (unie) en intersection (kruispunt) types, en hoe je
                        type-combinaties gebruikt.</li>
                    <li>Enums (enumeraties) in TypeScript voor het definiëren van reeks constante waarden.</li>
                    <li>Het verschil tussen interfaces en type aliassen, hoe je ze definieert en wanneer je welke
                        gebruikt.</li>
                    <li>Classes (klassen) in TypeScript, inclusief eigenschappen, methodes, access modifiers
                        (<code>public</code>, <code>private</code>, <code>protected</code>), <code>readonly</code>
                        velden, inheritance (<code>extends</code>), interfaces implementeren en andere OOP-features.
                    </li>
                    <li>Generics: hoe je generieke functies, klassen en interfaces maakt die met verschillende datatypes
                        kunnen werken voor herbruikbaarheid en flexibiliteit.</li>
                    <li>De ingebouwde utility types van TypeScript (zoals <code>Partial</code>, <code>Required</code>,
                        <code>Pick</code>, <code>Omit</code>, <code>Record</code>, etc.), met uitleg waarvoor ze dienen
                        en voorbeelden van gebruik.
                    </li>
                    <li>Overzicht van ingebouwde klassen en objecten (zoals <code>Array</code>, <code>Date</code>,
                        <code>Map</code>, <code>Set</code>, <code>Promise</code>, enz.) die JavaScript standaard biedt
                        en hoe TypeScript hiermee omgaat.
                    </li>
                    <li>Belangrijke patronen en toepassingen van het type-systeem: o.a. type-narrowing met type guards,
                        discriminated unions voor variant-typen, het gebruik van utility types in de praktijk (bijv.
                        voor configuratie-objecten), en best practices voor beginners (zoals wanneer je classes gebruikt
                        vs. interfaces, en hoe je typeveilig kunt programmeren).</li>
                </ul>

                <h4 id="ts-basis-typen">Basis TypeScript-typen</h4>
                <p>In TypeScript kun je variabelen annoteren met een type. Een type specificeert wat voor soort waarden
                    de variabele kan bevatten. We starten met de primitieve types die je vaak zult gebruiken, en
                    behandelen daarna enkele speciale typen.</p>

                <h5 id="ts-primitieve-typen">Primitieve typen</h5>
                <p>De meest voorkomende primitieve datatypen in TypeScript (en JavaScript) zijn:</p>
                <ul>
                    <li><strong>string</strong> – voor tekstuele data, bijv. <code>let naam: string = "Alice";</code>.
                    </li>
                    <li><strong>number</strong> – voor numerieke waarden (zowel gehele getallen als kommagetallen
                        gebruiken hetzelfde type), bijv. <code>let leeftijd: number = 30;</code>.</li>
                    <li><strong>boolean</strong> – voor true/false waarden, bijv.
                        <code>let isActive: boolean = true;</code>.
                    </li>
                    <li><strong>bigint</strong> – voor hele grote integers buiten het veilige bereik van
                        <code>number</code>. Bijvoorbeeld: <code>let big: bigint = 12345678901234567890n;</code> (merk
                        op de <code>n</code> suffix).
                    </li>
                    <li><strong>symbol</strong> – voor unieke symbolen (veelal gebruikt als unieke object‑eigenschap
                        keys).</li>
                    <li><strong>null</strong> en <strong>undefined</strong> – dit zijn ook types op zich, met slechts
                        respectievelijk de waarde <code>null</code> of <code>undefined</code>. Ze worden zelden
                        expliciet gebruikt als type, behalve in combinatie met andere types (zie verderop bij strict
                        null checks).</li>
                </ul>
                <p>Een variabele declareren met een type gebeurt meestal met de syntaxis
                    <code>let variabeleNaam: Type = waarde;</code>. Bijvoorbeeld:
                </p>
                <pre><code>let message: string = "Hallo, wereld!";
let amount: number = 42;
let isValid: boolean = false;</code></pre>
                <p>TypeScript kan types vaak ook afleiden uit de toegekende waarde, dus de annotatie is niet altijd
                    expliciet nodig als je direct initialiseert. Toch is het goed om de basistypen en hun namen te
                    kennen.</p>
                <div class="live-demo">
                    <div id="ts-primitives-demo" style="border:1px solid #ddd; padding:8px; display:grid; gap:8px;">
                        <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
                            <input id="primStr" placeholder="naam (string)" />
                            <input id="primNum" placeholder="leeftijd (number)" />
                            <label style="display:flex; align-items:center; gap:6px;">
                                <input id="primBool" type="checkbox" /> isActive (boolean)
                            </label>
                            <input id="primBig" placeholder="bigint (bv. 9007199254740993)" />
                            <input id="primSymDesc" placeholder="symbol beschrijving (optioneel)" />
                            <button id="primRun">Toon resultaten</button>
                        </div>
                        <div id="primOut" style="color:#333; white-space:pre-wrap;"></div>
                    </div>
                    <script>(function () {
                            var s = document.getElementById('primStr');
                            var n = document.getElementById('primNum');
                            var b = document.getElementById('primBool');
                            var big = document.getElementById('primBig');
                            var sd = document.getElementById('primSymDesc');
                            var run = document.getElementById('primRun');
                            var out = document.getElementById('primOut');
                            function toNumber(val) { var v = Number((val || '').trim()); return Number.isNaN(v) ? null : v; }
                            if (s && n && b && big && sd && run && out) {
                                run.addEventListener('click', function () {
                                    var name = String(s.value || '');
                                    var ageNum = toNumber(n.value);
                                    var active = !!b.checked;
                                    var bigText = (big.value || '').trim();
                                    var bigVal = null; var bigMsg = '';
                                    if (bigText) {
                                        try { bigVal = BigInt(bigText); bigMsg = String(bigVal) + 'n (ok)'; }
                                        catch (e) { bigMsg = 'ongeldige bigint: ' + e.message; }
                                    } else {
                                        bigMsg = '(geen)';
                                    }
                                    var desc = (sd.value || '').trim();
                                    var symA = Symbol(desc || 'a');
                                    var symB = Symbol(desc || 'a');
                                    var symEqual = symA === symB;
                                    var lines = [];
                                    lines.push('string → naam: ' + name + ' | toUpperCase(): ' + (name ? name.toUpperCase() : '(leeg)'));
                                    lines.push('number → leeftijd: ' + (ageNum === null ? '(ongeldig)' : ageNum) + (ageNum !== null ? (' | toFixed(2): ' + ageNum.toFixed(2)) : ''));
                                    lines.push('boolean → isActive: ' + active);
                                    lines.push('bigint → ' + bigMsg);
                                    lines.push('symbol → Symbol("' + (desc || 'a') + '"): symA === symB ? ' + symEqual + ' (altijd false, symbols zijn uniek)');
                                    out.textContent = lines.join('\n');
                                });
                            }
                        })();</script>
                </div>

                <h5 id="ts-speciale-typen">Speciale typen: any, unknown, void, never</h5>
                <p><strong>any</strong> – schakelt de typecontrole uit voor de variabele. Gebruik spaarzaam.</p>
                <pre><code>let iets: any = "hallo";
iets = 42;            // ok
console.log(iets.toFixed(2));  // kan runtime fout geven</code></pre>
                <p>Vergelijking: Het <code>any</code> type is krachtig maar gevaarlijk: het geeft je volledige vrijheid,
                    maar je verliest alle typeveiligheid
                    typescriptlang.org
                    . In tegenstelling tot <code>unknown</code> kun je op een <code>any</code>-variabele direct
                    willekeurige properties of methodes aanroepen zonder TypeScript-fouten, zelfs als ze niet bestaan
                    typescriptlang.org
                    . Dit kan tot runtime-fouten leiden als je niet oppast.</p>
                <p><strong>unknown</strong> – universele placeholder die je eerst moet narrowen (controleren) voor je er
                    specifieke bewerkingen op doet.</p>
                <pre><code>let onbekend: unknown = getIets();
// onbekend.toFixed(2); // Fout in TS
if (typeof onbekend === "number") {
  console.log(onbekend.toFixed(2));
}</code></pre>
                <p>In dit voorbeeld gebruiken we een type guard (<code>typeof onbekend === "number"</code>) om vast te
                    stellen dat
                    <code>onbekend</code> een <code>number</code> is voordat we <code>toFixed</code> aanroepen. Met
                    <code>unknown</code> krijg je dus typeveiligheid: je moet eerst controleren welk type de waarde
                    heeft, anders krijg je een compile‑fout
                    typescriptlang.org
                    typescriptlang.org
                    .
                </p>
                <div class="live-demo">
                    <div id="ts-types-unknown-demo" style="border:1px solid #ddd; padding:8px; display:grid; gap:8px;">
                        <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
                            <input id="unknownInput" placeholder="Typ bv. 12 of hallo" />
                            <button id="unknownBtn">Toon toFixed indien number</button>
                        </div>
                        <div id="unknownOut" style="color:#333;"></div>
                    </div>
                    <script>(function () {
                            var btn = document.getElementById('unknownBtn');
                            var input = document.getElementById('unknownInput');
                            var out = document.getElementById('unknownOut');
                            if (btn && input && out) {
                                btn.addEventListener('click', function () {
                                    var raw = input.value;
                                    var maybeNumber = raw.trim() === '' ? NaN : Number(raw);
                                    if (!Number.isNaN(maybeNumber)) {
                                        out.textContent = 'Geldig number → toFixed(2): ' + maybeNumber.toFixed(2);
                                    } else {
                                        out.textContent = 'Geen number. In TypeScript moet je eerst het type controleren (narrowing).';
                                    }
                                });
                            }
                        })();</script>
                </div>
                <p><strong>void</strong> – vooral als returntype van functies die niets teruggeven.</p>
                <pre><code>function waarschuw(message: string): void {
  console.log("Waarschuwing: " + message);
}</code></pre>
                <p>Hier geeft de functie <code>waarschuw</code> niets terug, dus annoteren we het retourtype als
                    <code>void</code>. Je zult <code>void</code> zelden als type van een variabele gebruiken (het heeft
                    dan weinig nut, behalve om aan te geven dat er echt niks mee gedaan wordt)
                    typescriptlang.org
                    typescriptlang.org
                    .
                </p>
                <p><strong>null</strong> en <strong>undefined</strong> – Dit zijn bijzondere waarden én types. Standaard
                    (zonder <code>--strictNullChecks</code> compilervlag) worden <code>null</code> en
                    <code>undefined</code> door TypeScript gezien als subtypen die je aan vrijwel elk ander type kunt
                    toewijzen
                    typescriptlang.org
                    . Met andere woorden: een <code>number</code> variabele zou dan ook <code>null</code> kunnen zijn.
                    Echter, met strict mode (aanbevolen) moet je expliciet aangeven als iets
                    <code>null</code>/<code>undefined</code> mag zijn, meestal via een union type (zoals
                    <code>string | null</code>).
                </p>
                <pre><code>let mogelijkLeeg: string | undefined;
mogelijkLeeg = "Hallo";
mogelijkLeeg = undefined;
// mogelijkLeeg = null; // Fout als strictNullChecks aanstaat en 'null' niet is toegestaan</code></pre>
                <p><strong>never</strong> – het <code>never</code> type geeft aan dat iets nooit een waarde kan hebben.
                    Dit wordt gebruikt in twee scenario's:
                    een functie die nooit op de normale manier eindigt (bijvoorbeeld altijd een error gooit of oneindig
                    loopt)
                    typescriptlang.org
                    typescriptlang.org
                    , en een variabele die door type narrowing in een toestand komt die onmogelijk is (bij uitputtende
                    checks).</p>
                <pre><code>function fatal(message: string): never {
  throw new Error(message);
}

type Dier = { soort: "kat", geluid: string } | { soort: "vis", gewicht: number };
function verwerkDier(d: Dier) {
  if (d.soort === "kat") {
    console.log("Kat zegt " + d.geluid);
  } else if (d.soort === "vis") {
    console.log("Vis weegt " + d.gewicht + " gram");
  } else {
    const _exhaustive: never = d;
  }
}</code></pre>
                <p>In de <code>else</code> hierboven gebruiken we <code>_exhaustive: never</code> om van de compiler een
                    fout te krijgen als er toch een onvoorziene variant is. Dit is een patroon om te checken dat je alle
                    gevallen hebt afgehandeld. Samengevat, <code>never</code> is vooral een instrument voor de compiler
                    om consistente typeafspraken te bewaken.</p>

                <h4 id="ts-object-typen">Object typen en object-annotaties</h4>
                <p>JavaScript is een object-georiënteerde taal en veel waarden zijn objecten. In TypeScript kun je
                    object types beschrijven, bijvoorbeeld via object literals, interfaces of type aliases (meer
                    hierover later).</p>
                <p>Je kunt een object-type ad hoc aangeven met accolades <code>{ ... }</code>. Bijvoorbeeld:</p>
                <pre><code>let point: { x: number, y: number } = { x: 10, y: 20 };
// point = { x: 5 }; // Fout: ontbrekende eigenschap 'y'</code></pre>
                <p>Hier hebben we het type van <code>point</code> vastgelegd als een object met een <code>x</code> en
                    <code>y</code> eigenschap, beide nummers. Dit is handig voor kleinere objecttypes, maar bij
                    hergebruik of grotere objecten is het beter een interface of type alias te gebruiken (zie sectie
                    over Interfaces).
                </p>
                <p>Er is ook een speciaal basistype <code>object</code> in TypeScript, dat ongeveer betekent
                    "non-primitives" (dus alles behalve <code>null</code>, <code>undefined</code>, <code>string</code>,
                    <code>number</code>, <code>boolean</code>, etc). Je kunt <code>object</code> als type gebruiken
                    wanneer je een willekeurig object verwacht, maar eigenlijk meer type-informatie niet nodig hebt.
                    Bijvoorbeeld:
                </p>
                <pre><code>function create(o: object) { /* ... */ }

create({ naam: "Alice" }); // OK
// create("hallo");        // Fout in TS: 'string' is geen 'object' (non-primitive)

// Nadeel: binnen 'create' weet TS niet welke properties bestaan op 'o',
// dus kun je niet zomaar o.naam lezen zonder verdere definitie/cast.</code></pre>
                <p>Het gebruik van het <code>object</code> type is beperkt, want je kunt er niet zomaar eigenschappen
                    van gebruiken zonder cast of verdere definitie. In de praktijk definieer je meestal een specifieker
                    objecttype via een interface of type alias.</p>
                <div class="live-demo">
                    <div id="ts-object-demo" style="border:1px solid #ddd; padding:8px; display:grid; gap:8px;">
                        <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
                            <input id="objX" placeholder="x (number)" />
                            <input id="objY" placeholder="y (number)" />
                            <button id="objValidate">Valideer point</button>
                        </div>
                        <div id="objOut" style="color:#333;"></div>
                        <div style="font-size:12px; color:#666;">In TypeScript zou een ontbrekende <code>x</code> of
                            <code>y</code> compile-fouten geven bij het toewijzen aan
                            <code>{ x: number, y: number }</code>. Hier valideren we dit runtime.
                        </div>
                    </div>
                    <script>(function () {
                            var x = document.getElementById('objX');
                            var y = document.getElementById('objY');
                            var b = document.getElementById('objValidate');
                            var o = document.getElementById('objOut');
                            if (x && y && b && o) {
                                b.addEventListener('click', function () {
                                    var xv = Number((x.value || '').trim());
                                    var yv = Number((y.value || '').trim());
                                    if (Number.isNaN(xv) || Number.isNaN(yv)) {
                                        o.textContent = 'Beide velden moeten numbers zijn.';
                                        return;
                                    }
                                    var pointObj = { x: xv, y: yv };
                                    o.textContent = 'Geldig point object: ' + JSON.stringify(pointObj);
                                });
                            }
                        })();</script>
                </div>

                <h4 id="ts-array-typen">Array types</h4>
                <p>Arrays zijn verzamelingen van waarden. In TypeScript kun je arrays typen om te specificeren wat voor
                    elementen erin mogen. Er zijn twee syntaxes die hetzelfde betekenen:</p>
                <p><code>T[]</code> – bijvoorbeeld <code>number[]</code> betekent "een array van nummers".</p>
                <p><code>Array&lt;T&gt;</code> – bijvoorbeeld <code>Array&lt;number&gt;</code> betekent hetzelfde als
                    <code>number[]</code>.
                </p>
                <p>Je kunt kiezen welke notatie je prettiger vindt. De vierkante-haakjes notatie is het meest beknopt.
                </p>
                <p>Voorbeeld:</p>
                <pre><code>let getallen: number[] = [1, 2, 3];
getallen.push(4);        // OK
// getallen.push("vijf");  // Fout: "vijf" is een string, array verwacht number

let woorden: Array<string> = ["foo", "bar"];
let eersteWoord: string = woorden[0];  // "foo"</code></pre>
                <p>Je kunt natuurlijk ook complexe types in arrays zetten, zoals objecten of unions, zolang je het
                    aangeeft. Bijvoorbeeld een array die zowel strings als nummers bevat (hier twee personen met naam en
                    leeftijd afwisselend):</p>
                <pre><code>let lijst: (string | number)[] = ["Alice", 30, "Bob", 25];</code></pre>
                <div class="live-demo">
                    <div id="ts-types-array-demo" style="border:1px solid #ddd; padding:8px; display:grid; gap:8px;">
                        <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
                            <input id="arrValue" placeholder="Voeg nummer toe (bv. 5)" />
                            <button id="arrAdd">Voeg toe</button>
                            <button id="arrReset">Reset</button>
                        </div>
                        <div id="arrOut" style="color:#333;">Huidige lijst: [1, 2, 3]</div>
                        <div id="arrMsg" style="font-size:12px; color:#666;">In TypeScript zou het toevoegen van
                            niet-numerieke waarden een compile-fout geven.</div>
                    </div>
                    <script>(function () {
                            var data = [1, 2, 3];
                            var out = document.getElementById('arrOut');
                            var msg = document.getElementById('arrMsg');
                            var inp = document.getElementById('arrValue');
                            var add = document.getElementById('arrAdd');
                            var reset = document.getElementById('arrReset');
                            function render() { if (out) { out.textContent = 'Huidige lijst: [' + data.join(', ') + ']'; } }
                            if (add && reset && inp) {
                                add.addEventListener('click', function () {
                                    var raw = inp.value.trim();
                                    if (raw === '') return;
                                    var num = Number(raw);
                                    if (Number.isNaN(num)) {
                                        if (msg) { msg.textContent = 'Alleen nummers toegestaan (TS: type-check zou dit blokkeren).'; }
                                    } else {
                                        data.push(num); render(); if (msg) { msg.textContent = 'Toegevoegd.'; }
                                    }
                                    inp.value = '';
                                });
                                reset.addEventListener('click', function () { data = [1, 2, 3]; render(); if (msg) { msg.textContent = 'Reset uitgevoerd.'; } });
                                render();
                            }
                        })();</script>
                </div>

                <h4 id="ts-tuples">Tuples (tulpes)</h4>
                <p>Een tuple is een specialiteit van TypeScript: het is eigenlijk een array met een vaste lengte en
                    vastgelegde type(s) per index. Waar een normale array van één type is, kan een tuple verschillende
                    types op verschillende posities bevatten, maar het aantal elementen en de types liggen vast.</p>
                <p>Dit is handig voor een klein record van verschillende gegevens. Bijvoorbeeld een tuple voor een
                    coördinaat als paar <code>[x, y]</code> nummers, of een tuple <code>[naam, leeftijd]</code> als in
                    het voorbeeld hieronder:</p>
                <pre><code>let gebruiker: [string, number];
gebruiker = ["Alice", 30];    // Correct
// gebruiker = [30, "Alice"]; // Fout in TS

console.log(gebruiker[0].toUpperCase());
console.log(gebruiker[1].toFixed(2));</code></pre>
                <p>In bovenstaand voorbeeld is <code>gebruiker[0]</code> van type <code>string</code> en
                    <code>gebruiker[1]</code> van type <code>number</code>. Probeer je iets op de verkeerde positie te
                    plaatsen, dan krijg je een compile-fout. Tuples worden vaak gebruikt voor bijvoorbeeld
                    functie-terugkeerwaarden als je twee of drie waarden wilt teruggeven (een beter alternatief is dan
                    vaak een object, maar tuples komen voor).
                </p>
                <div class="live-demo">
                    <div id="ts-types-tuple-demo" style="border:1px solid #ddd; padding:8px; display:grid; gap:8px;">
                        <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
                            <input id="tupleName" placeholder="Naam (string)" />
                            <input id="tupleAge" placeholder="Leeftijd (number)" />
                            <button id="tupleBuild">Maak tuple</button>
                        </div>
                        <div id="tupleOut" style="color:#333;"></div>
                        <div style="font-size:12px; color:#666;">In TypeScript is de volgorde/type per index verplicht;
                            verkeerde volgorde geeft compile-fouten.</div>
                    </div>
                    <script>(function () {
                            var n = document.getElementById('tupleName');
                            var a = document.getElementById('tupleAge');
                            var b = document.getElementById('tupleBuild');
                            var o = document.getElementById('tupleOut');
                            if (n && a && b && o) {
                                b.addEventListener('click', function () {
                                    var name = String(n.value || '').trim();
                                    var age = Number((a.value || '').trim());
                                    if (!name) { o.textContent = 'Naam is verplicht.'; return; }
                                    if (Number.isNaN(age)) { o.textContent = 'Leeftijd moet een number zijn.'; return; }
                                    var tuple = [name, age];
                                    o.textContent = 'Tuple: ["' + tuple[0] + '", ' + tuple[1] + '] — naam.toUpperCase(): ' + name.toUpperCase() + ', leeftijd.toFixed(2): ' + age.toFixed(2);
                                });
                            }
                        })();</script>
                </div>
            </section>

            <section id="ts-interfaces">
                <h3>Interfaces & Classes</h3>
                <h4>Interfaces</h4>
                <p>Een interface definieert de "vorm" van een object. Het is een krachtige manier om contracten in je
                    code vast te leggen.</p>
                <pre><code>interface User {
    readonly id: number;
    name: string;
    age?: number; // Optionele property
}

function printUser(user: User) {
    console.log(`User ${user.name} (ID: ${user.id})`);
}

let myUser: User = { id: 1, name: "Bob" };
printUser(myUser);</code></pre>

                <h4>Classes</h4>
                <p>TypeScript ondersteunt classes, net als moderne JavaScript, maar met type-annotaties.</p>
                <pre><code>class Animal {
    private name: string; // Alleen toegankelijk binnen de class

    constructor(theName: string) {
        this.name = theName;
    }

    public move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}</code></pre>
            </section>

            <section id="ts-enums">
                <h3>Enums & Generics</h3>
                <h4>Enums</h4>
                <p>Een manier om een set van benoemde constanten te definiëren.</p>
                <pre><code>enum Color {
    Red,    // 0
    Green,  // 1
    Blue    // 2
}
let c: Color = Color.Green;</code></pre>

                <h4>Generics</h4>
                <p>Hiermee kun je herbruikbare componenten maken die met verschillende types kunnen werken.</p>
                <pre><code>function identity&lt;T&gt;(arg: T): T {
    return arg;
}

let output1 = identity&lt;string&gt;("myString");
let output2 = identity&lt;number&gt;(100);</code></pre>
                <div class="exercise">
                    <h4>Oefening T4-01: Generic Function</h4>
                    <p>Schrijf een generic function `getFirstElement` die het eerste element van een array teruggeeft.
                        De functie moet werken voor arrays van elk type.</p>
                    <textarea id="ex-t4-01" placeholder="Plaats hier je TypeScript-functie..."></textarea>
                    <button class="check-btn" data-exercise="t4-01">Controleer</button>
                    <button class="solution-btn secondary">Toon Oplossing</button>
                    <div class="validator-result"></div>
                    <div class="exercise-solution">
                        <pre><code>function getFirstElement&lt;T&gt;(arr: T[]): T | undefined {
    return arr[0];
}

// Voorbeeld gebruik:
const stringArray = ["a", "b", "c"];
const numberArray = [1, 2, 3];

const firstString = getFirstElement(stringArray); // Type is string | undefined
const firstNumber = getFirstElement(numberArray); // Type is number | undefined</code></pre>
                    </div>
                </div>
            </section>

            <section id="ts-modules">
                <h3>Modules</h3>
                <p>Net als in JavaScript, kun je je code organiseren in modules. TypeScript gebruikt `import` en
                    `export`.</p>
                <pre><code>// --- file: math.ts ---
export function add(a: number, b: number): number {
    return a + b;
}

// --- file: app.ts ---
import { add } from './math';

console.log(add(5, 10)); // 15</code></pre>
            </section>



            <section id="ts-dom">
                <h3>TypeScript DOM-manipulatie</h3>
                <h4>DOM-manipulatie in TypeScript: Een Uitgebreide Gids</h4>
                <h5>Introductie</h5>
                <p>De Document Object Model (DOM) is de programmeerbare representatie van een webpagina als een
                    hiërarchische boom van objecten. Met DOM-manipulatie kun je via JavaScript (en TypeScript) de
                    structuur, inhoud en stijl van een webpagina dynamisch aanpassen. TypeScript is een superset van
                    JavaScript met statische typecontrole, wat vooral bij DOM-manipulatie erg nuttig is. Dankzij
                    TypeScript krijg je tijdens het programmeren al feedback op fouten, bijvoorbeeld als je probeert een
                    niet-bestaande eigenschap van een DOM-element te benaderen of een verkeerde typen doorgeeft aan een
                    functie
                    biggyzoe.medium.com
                    biggyzoe.medium.com
                    . Dit verhoogt de betrouwbaarheid en onderhoudbaarheid van je code.</p>
                <p>Waarom TypeScript voor DOM-manipulatie? In essentie kun je alle DOM-bewerkingen die je in JavaScript
                    doet, ook in TypeScript doen – maar met extra zekerheid. TypeScript biedt type-definities voor het
                    volledige DOM API (via het ingebouwde lib.dom.d.ts bestand), waardoor IntelliSense, autocompletion
                    en compile-time foutcontroles mogelijk zijn
                    typescriptlang.org
                    typescriptlang.org
                    . Dit betekent dat je bijvoorbeeld niet per ongeluk een onjuiste eigenschap van een element probeert
                    te gebruiken: de compiler waarschuwt je als iets niet klopt. Daarnaast dwingt TypeScript je om
                    null/undefined scenario’s af te vangen (aangezien een DOM-zoekopdracht soms niets kan opleveren),
                    waardoor je minder snel tegen runtime errors aanloopt.</p>
                <p>In deze gids behandelen we alle belangrijke aspecten van DOM-manipulatie in TypeScript, van het
                    selecteren van elementen en het veilig typen daarvan, tot het aanpassen van content, toevoegen van
                    event handlers en zelfs hoe je dit integreert met populaire frameworks als React en Angular. We
                    geven beknopte beschrijvingen van veelgebruikte methoden en eigenschappen (zoals
                    <code>document.getElementById</code> en <code>element.innerHTML</code>), mét uitleg over het gebruik
                    en concrete voorbeelden. De focus ligt op best practices en type-veiligheid, zodat ook beginnende
                    TypeScript-ontwikkelaars hier veel aan hebben.
                </p>
                <h5>Aan de slag: TypeScript instellen voor DOM</h5>
                <p>Om DOM‑manipulatie met TypeScript te gebruiken, moet je project de DOM‑types geladen hebben. In een
                    standaard TypeScript‑configuratie voor een webapplicatie zijn de browser‑API’s meestal al
                    inbegrepen. Dit betekent dat je direct toegang hebt tot globale objecten als <code>document</code>,
                    <code>window</code>, <code>Element</code>, etc., met hun respectievelijke type‑definities. Mocht je
                    ooit merken dat TypeScript de DOM‑objecten niet kent (bijv. in een Node.js‑omgeving), zorg dan dat
                    in je <code>tsconfig.json</code> onder <code>lib</code> de <code>DOM</code> library is opgenomen.
                </p>
                <p>Belangrijk: voer je TypeScript/JavaScript pas uit nadat de HTML geladen is, anders krijg je mogelijk
                    <code>null</code> terug bij het selecteren van elementen. Je kunt je script onderaan de
                    <code>&lt;body&gt;</code> plaatsen of luisteren naar het <code>DOMContentLoaded</code>‑event voordat
                    je elementen opvraagt en manipuleert.
                </p>
                <pre><code>document.addEventListener('DOMContentLoaded', () => {
  // Hier pas DOM-manipulatie doen
});</code></pre>
                <div class="live-demo">
                    <div id="tsdom-ready" style="border:1px solid #ddd; padding:8px; margin-bottom:8px;">
                        <button id="tsdom-ready-btn">Voeg tekst toe</button>
                        <div id="tsdom-ready-target" style="margin-top:6px; color:#333;"></div>
                    </div>
                    <script>(function () {
                            const btn = document.getElementById('tsdom-ready-btn');
                            const target = document.getElementById('tsdom-ready-target');
                            if (btn && target) {
                                btn.addEventListener('click', () => {
                                    target.textContent = 'DOM is klaar en dit is dynamisch toegevoegd.';
                                });
                            }
                        })();</script>
                </div>
                <h5>DOM‑elementen selecteren en benaderen</h5>
                <p>De eerste stap in DOM‑manipulatie is meestal het opzoeken van elementen waar je iets mee wilt doen.
                    Enkele veelgebruikte methoden van het <code>Document</code> object zijn:</p>
                <ul>
                    <li><strong>document.getElementById(id)</strong>: zoekt een element met een gegeven <code>id</code>.
                        Retourneert <code>HTMLElement | null</code>. Bijvoorbeeld:
                        <code>const header = document.getElementById('main-header');</code>
                    </li>
                    <li><strong>document.querySelector(selector)</strong>: vindt het eerste element dat matcht met de
                        CSS‑selector. Met generics kun je direct een specifieker type krijgen, bv.
                        <code>document.querySelector&lt;HTMLInputElement&gt;('#ageInput')</code>.
                    </li>
                    <li><strong>document.querySelectorAll(selector)</strong>: vindt alle elementen die voldoen en geeft
                        <code>NodeListOf&lt;Element&gt;</code> terug (statisch). Je kunt hierover itereren met
                        <code>forEach</code>.
                    </li>
                    <li><strong>document.getElementsByClassName(name)</strong>: geeft een <em>live</em>
                        <code>HTMLCollection</code> van elementen met de class.
                    </li>
                    <li><strong>document.getElementsByTagName(tag)</strong>: geeft een <em>live</em>
                        <code>HTMLCollectionOf&lt;...&gt;</code> met alle elementen van dat tag (bv.
                        <code>HTMLAnchorElement</code> bij <code>'a'</code>).
                    </li>
                    <li><strong>document.getElementsByName(name)</strong>: zoekt op <code>name</code> attribuut (vaak
                        gebruikt bij formulieren, zoals radio knoppen).</li>
                </ul>
                <pre><code>&lt;!-- Stel deze HTML voor --&gt;
&lt;div id="content"&gt;
  &lt;p class="text-item"&gt;Eerste alinea&lt;/p&gt;
  &lt;p class="text-item highlight"&gt;Tweede alinea&lt;/p&gt;
  &lt;input id="ageInput" name="age" type="number" /&gt;
&lt;/div&gt;

const contentDiv = document.getElementById('content');            // HTMLElement | null
const firstParagraph = document.querySelector('p.text-item');     // Element | null (of specifieker)
const highlighted = document.querySelectorAll('.highlight');      // NodeListOf&lt;Element&gt;
const allParas = document.getElementsByTagName('p');              // HTMLCollectionOf&lt;HTMLParagraphElement&gt;
const ageInputList = document.getElementsByName('age');           // NodeList</code></pre>
                <div class="live-demo">
                    <div id="tsdom-selectors" style="border:1px solid #ddd; padding:8px;">
                        <div id="tsdom-content">
                            <p class="text-item">Eerste alinea</p>
                            <p class="text-item highlight">Tweede alinea</p>
                            <input id="tsdom-age" name="age" type="number" placeholder="Leeftijd" />
                        </div>
                        <div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;">
                            <button id="tsdom-btn-qsa">Tel .highlight</button>
                            <button id="tsdom-btn-q">Pak eerste .text-item</button>
                            <button id="tsdom-btn-byid">Check #tsdom-content</button>
                        </div>
                        <div id="tsdom-selectors-out" style="margin-top:8px; color:#333;"></div>
                    </div>
                    <script>(function () {
                            const out = document.getElementById('tsdom-selectors-out');
                            const btnQSA = document.getElementById('tsdom-btn-qsa');
                            const btnQ = document.getElementById('tsdom-btn-q');
                            const btnById = document.getElementById('tsdom-btn-byid');
                            if (out && btnQSA && btnQ && btnById) {
                                btnQSA.addEventListener('click', () => {
                                    const n = document.querySelectorAll('#tsdom-content .highlight').length;
                                    out.textContent = 'Aantal .highlight: ' + n;
                                });
                                btnQ.addEventListener('click', () => {
                                    const p = document.querySelector('#tsdom-content p.text-item');
                                    out.textContent = 'Eerste text-item: ' + (p ? (p.textContent || '') : 'niet gevonden');
                                });
                                btnById.addEventListener('click', () => {
                                    const el = document.getElementById('tsdom-content');
                                    out.textContent = el ? 'tsdom-content bestaat' : 'niet gevonden';
                                });
                            }
                        })();</script>
                </div>
                <h5>Type‑veilig selecteren (narrowing, generics, assertions)</h5>
                <h6>Type‑veilig selecteren (narrowing, generics, assertions)</h6>
                <p>Een van de grootste voordelen van TypeScript is de type-veiligheid. Laten we
                    <code>document.getElementById</code> als voorbeeld nemen. De definitie daarvan in TypeScript is
                    <code>function getElementById(elementId: string): HTMLElement | null</code>
                </p>
                <p>typescriptlang.org</p>
                <p>. Dit vertelt ons twee dingen:</p>
                <ol>
                    <li>Je krijgt altijd ofwel een object dat tenminste een <code>HTMLElement</code> is, ofwel
                        <code>null</code> (indien geen element met dat ID bestaat).
                    </li>
                    <li>Het geretourneerde object is van het algemene type <code>HTMLElement</code>. In de DOM API is
                        <code>HTMLElement</code> de basisklasse (interface) van waaruit alle specifieke HTML‑elementen
                        (zoals <code>HTMLDivElement</code>, <code>HTMLParagraphElement</code>,
                        <code>HTMLInputElement</code>, etc.) voortkomen
                    </li>
                </ol>
                <p>typescriptlang.org</p>

                <p>Concreet betekent dit dat als je bijvoorbeeld een <code>&lt;p&gt;</code> element ophaalt,
                    TypeScript weet dat het minstens een <code>HTMLElement</code> is, maar niet dat het specifiek een
                    paragraf‑tag betreft – tenzij je dat aangeeft. In ons voorbeeld hierboven:
                    <code>firstParagraph</code>
                    is van type <code>HTMLParagraphElement | null</code> als je de generieke versie van
                    <code>querySelector</code> voor <code>'p'</code> gebruikt, maar als je dat niet doet is het gewoon
                    <code>Element | null</code>. Meestal wil je de juiste specifieke type kunnen gebruiken, omdat
                    specifieke elementen extra eigenschappen kunnen hebben. Een <code>HTMLInputElement</code> heeft
                    bijvoorbeeld een <code>.value</code> eigenschap, terwijl een <code>HTMLDivElement</code> die niet
                    heeft. Als je via TypeScript bij een algemene <code>HTMLElement</code> probeert <code>.value</code>
                    op te vragen, krijg je een compilerfout omdat niet iedere <code>HTMLElement</code> een
                    <code>value</code> heeft. Dit voorkomt fouten. Bijvoorbeeld:
                </p>
                <pre><code>const elem = document.getElementById("ageInput"); 
elem.value = "123";  // FOUT: property 'value' bestaat niet op type HTMLElement</code></pre>

                <p>Bovenstaande code compileert niet, omdat TypeScript veilig aangeeft dat <code>elem</code> mogelijk
                    geen <code>value</code> heeft (bijvoorbeeld als het eigenlijk een <code>&lt;div&gt;</code> was)</p>
                <p>biggyzoe.medium.com</p>
                <p>. Je moet type‑narrowing toepassen.</p>

                <p><strong>Type‑narrowing en casting:</strong> Er zijn een paar manieren om dit aan te pakken:</p>
                <p><strong>Type guard:</strong> Controleer in runtime wat voor element het is, bijvoorbeeld via
                    <code>instanceof</code>. Bijvoorbeeld:
                </p>
                <pre><code>if (elem instanceof HTMLInputElement) {
  console.log(elem.value); // nu weet TS dat elem een HTMLInputElement is
}</code></pre>

                <p><strong>Type assertion (casten):</strong> Als je zelf zeker weet dat een bepaald element een input
                    is,
                    kun je TypeScript een cast laten doen. Dit kan met de <code>as</code> syntax:</p>
                <pre><code>const ageInputElem = document.getElementById("ageInput") as HTMLInputElement;
console.log(ageInputElem.value);  // nu is ageInputElem getypeerd als HTMLInputElement</code></pre>
                <p>Doe dit alleen als je zeker bent van het type, want je vertelt hiermee de compiler het aan te nemen
                    (en negeert mogelijke fouten als je verkeerd cast). TypeScript laat dit toe, maar als je verkeerd
                    zit kan het alsnog een runtime error geven. Gebruik deze techniek bijvoorbeeld om een element naar
                    een
                    specifieker subtype te brengen, zodat je toegang krijgt tot properties als <code>.value</code>,
                    <code>.checked</code> (voor checkboxes), etc.
                </p>
                <p>biggyzoe.medium.com</p>
                <p>biggyzoe.medium.com</p>

                <p><strong>Generics bij <code>querySelector</code>:</strong> Zoals genoemd kun je ook direct bij
                    <code>querySelector</code> een type parameter meegeven. Bijvoorbeeld:
                </p>
                <pre><code>const ageInputElem = document.querySelector&lt;HTMLInputElement&gt;('#ageInput');</code></pre>
                <p>Nu is <code>ageInputElem</code> van type <code>HTMLInputElement | null</code> zonder extra cast. Dit
                    is een elegantere manier die TypeScript biedt door function overloading en generics</p>
                <p>typescriptlang.org</p>
                <p>.</p>

                <p>Daarnaast moet je om kunnen gaan met <code>null</code>. TypeScript vereist vaak dat je null‑checks
                    doet of non‑null assertions. Een patroon is bijvoorbeeld:</p>
                <pre><code>const contentDiv = document.getElementById('content');
if (contentDiv) {
  // contentDiv is zeker niet null binnen deze blok
  contentDiv.appendChild(...);
}</code></pre>

                <p>Of als je zeker weet dat het element bestaat (bijvoorbeeld omdat je het zelf in de HTML hebt staan),
                    kun je een non‑null assertion gebruiken door een <code>!</code> achter de aanroep te zetten:
                    <code>const contentDiv = document.getElementById('content')!;</code>. Dit verandert het type van
                    <code>HTMLElement | null</code> naar gewoon <code>HTMLElement</code>, waarmee je de compiler
                    vertelt: "geloof me, dit is niet null." Wees hier voorzichtig mee: als het element toch niet
                    bestaat, krijg je een runtime error.
                </p>

                <p>Modernere syntax zoals optionele chaining kan ook handig zijn. Bijvoorbeeld in de TypeScript
                    documentatie werd het toevoegen van een child zo gedaan: <code>app?.appendChild(p);</code></p>
                <p>typescriptlang.org</p>
                <p>. Hier is <code>app</code> een mogelijk <code>null</code> element, en dankzij <code>?.</code>
                    (Optional chaining) wordt <code>appendChild</code> alleen aangeroepen als <code>app</code> niet
                    <code>null</code> is – anders wordt het statement overgeslagen. Dit is een nette manier om
                    null‑checks korter te schrijven.
                </p>

                <div class="live-demo">
                    <div id="tsdom-narrow-adv" style="border:1px solid #ddd; padding:8px; display:grid; gap:8px;">
                        <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
                            <input id="ageInput" type="number" placeholder="Leeftijd" />
                            <button id="btn-inst">Lees via instanceof</button>
                            <button id="btn-cast">Lees via assertion</button>
                            <button id="btn-generic">Lees via querySelector&lt;T&gt;</button>
                            <button id="btn-opt">Append via optional chaining</button>
                            <button id="btn-reset-narrow">Reset</button>
                        </div>
                        <div id="narrow-adv-out" style="font-size:12px; color:#555;"></div>
                        <div id="content" style="padding:6px; background:#fafafa; min-height:24px;"></div>
                    </div>
                    <script>(function () {
                            var out = document.getElementById('narrow-adv-out');
                            var btnInst = document.getElementById('btn-inst');
                            var btnCast = document.getElementById('btn-cast');
                            var btnGen = document.getElementById('btn-generic');
                            var btnOpt = document.getElementById('btn-opt');
                            var btnReset = document.getElementById('btn-reset-narrow');
                            function log(msg) { if (out) out.textContent = msg; }
                            if (btnInst) {
                                btnInst.addEventListener('click', function () {
                                    var elem = document.getElementById('ageInput');
                                    if (elem instanceof HTMLInputElement) {
                                        log('instanceof OK, value=' + (elem.value || ''));
                                    } else {
                                        log('instanceof faalde: geen HTMLInputElement');
                                    }
                                });
                            }
                            if (btnCast) {
                                btnCast.addEventListener('click', function () {
                                    var elem = /** @type {HTMLInputElement|null} */ (document.getElementById('ageInput'));
                                    log('assertion, value=' + (elem ? elem.value : '(null)'));
                                });
                            }
                            if (btnGen) {
                                btnGen.addEventListener('click', function () {
                                    var el = /** @type {HTMLInputElement|null} */ (document.querySelector('#ageInput'));
                                    log('querySelector<T>: value=' + (el ? el.value : '(null)'));
                                });
                            }
                            if (btnOpt) {
                                btnOpt.addEventListener('click', function () {
                                    var app = document.getElementById('content');
                                    var p = document.createElement('p');
                                    p.textContent = 'Toegevoegd via optional chaining demo';
                                    // app?.appendChild(p) in TS; in JS simuleren we de check
                                    if (app) { app.appendChild(p); log('child toegevoegd'); } else { log('content niet gevonden'); }
                                });
                            }
                            if (btnReset) {
                                btnReset.addEventListener('click', function () {
                                    var app = document.getElementById('content');
                                    if (app) app.innerHTML = '';
                                    log('gereset');
                                });
                            }
                        })();</script>
                </div>

                <p>TypeScript dwingt je veilig met mogelijk <code>null</code> om te gaan en zorgt dat je alleen
                    properties gebruikt die bij het elementtype horen. Voorbeelden:</p>
                <ul>
                    <li><strong>Type guard met instanceof</strong>: check eerst of een element bv. een
                        <code>HTMLInputElement</code> is voor je <code>.value</code> gebruikt.
                    </li>
                    <li><strong>Type assertion</strong>: wanneer je zeker bent van het type kun je casten, bv.
                        <code>as HTMLInputElement</code>.
                    </li>
                    <li><strong>Generics met querySelector</strong>:
                        <code>document.querySelector&lt;HTMLInputElement&gt;('#ageInput')</code> geeft meteen
                        <code>HTMLInputElement | null</code>.
                    </li>
                    <li><strong>Optional chaining</strong>: <code>ageInputElem?.value</code> voorkomt fouten als het
                        element ontbreekt.</li>
                    <li><strong>Non‑null assertion</strong>: <code>document.getElementById('content')!</code> als je
                        100% zeker bent dat het bestaat (wees voorzichtig).</li>
                </ul>
                <pre><code>const elem = document.getElementById('ageInput');
// elem.value = '123'; // FOUT: 'value' bestaat niet op HTMLElement
if (elem instanceof HTMLInputElement) {
  console.log(elem.value);
}

const ageInputElem = document.querySelector&lt;HTMLInputElement&gt;('#ageInput');
console.log(ageInputElem?.value);

const contentDiv2 = document.getElementById('content');
if (contentDiv2) {
  contentDiv2.appendChild(document.createElement('span'));
}
// Non-null assertion (wees voorzichtig)
const sureDiv = document.getElementById('content')!;</code></pre>
                <div class="live-demo">
                    <div id="tsdom-narrow" style="border:1px solid #ddd; padding:8px;">
                        <input id="tsdom-age2" type="number" placeholder="Leeftijd" />
                        <button id="tsdom-read-age">Lees waarde</button>
                        <div id="tsdom-age-out" style="margin-top:6px;"></div>
                    </div>
                    <script>(function () {
                            const btn = document.getElementById('tsdom-read-age');
                            const input = document.getElementById('tsdom-age2');
                            const out = document.getElementById('tsdom-age-out');
                            if (btn && input && out) {
                                btn.addEventListener('click', () => {
                                    const el = /** @type {HTMLInputElement} */ (input);
                                    out.textContent = 'Waarde: ' + (el.value || '(leeg)');
                                });
                            }
                        })();</script>
                </div>
                <h5>Inhoud &amp; attributen: innerHTML, textContent, classList, style, dataset</h5>
                <p>Met <code>innerHTML</code> plaats of lees je HTML‑inhoud (let op XSS‑veiligheid). Met
                    <code>textContent</code> werk je veilig met platte tekst. Gebruik <code>classList</code> om classes
                    te beheren, <code>style</code> voor inline stijlen en <code>dataset</code> voor <code>data‑*</code>
                    attributen.
                </p>
                <pre><code>const content = document.getElementById('content');
if (content) {
  content.innerHTML = "&lt;p&gt;&lt;b&gt;Hallo!&lt;/b&gt; Dit is &lt;i&gt;HTML&lt;/i&gt; content.&lt;/p&gt;";
}</code></pre>
                <div class="live-demo">
                    <div id="tsdom-content-block" style="border:1px solid #ddd; padding:8px;">
                        <div id="tsdom-target" style="padding:6px; background:#fafafa; margin-bottom:8px;"></div>
                        <div style="display:flex; gap:8px; flex-wrap:wrap;">
                            <button id="tsdom-btn-html">innerHTML</button>
                            <button id="tsdom-btn-text">textContent</button>
                            <button id="tsdom-btn-class">Toggle .highlight</button>
                            <button id="tsdom-btn-style">Style: rood</button>
                            <button id="tsdom-btn-data">Zet data-id</button>
                        </div>
                        <div id="tsdom-content-out" style="margin-top:8px;"></div>
                    </div>
                    <script>(function () {
                            const target = document.getElementById('tsdom-target');
                            const out = document.getElementById('tsdom-content-out');
                            const bHtml = document.getElementById('tsdom-btn-html');
                            const bText = document.getElementById('tsdom-btn-text');
                            const bClass = document.getElementById('tsdom-btn-class');
                            const bStyle = document.getElementById('tsdom-btn-style');
                            const bData = document.getElementById('tsdom-btn-data');
                            if (target && out && bHtml && bText && bClass && bStyle && bData) {
                                bHtml.addEventListener('click', () => {
                                    target.innerHTML = '<p><b>Hallo!</b> Dit is <i>HTML</i> content.</p>';
                                    out.textContent = 'innerHTML gezet';
                                });
                                bText.addEventListener('click', () => {
                                    target.textContent = '<b>Hallo</b> als tekst';
                                    out.textContent = 'textContent gezet (geen HTML interpretatie)';
                                });
                                bClass.addEventListener('click', () => {
                                    target.classList.toggle('highlight');
                                    out.textContent = 'classList.toggle("highlight")';
                                });
                                bStyle.addEventListener('click', () => {
                                    /** @type {HTMLElement} */ (target).style.backgroundColor = 'red';
                                    out.textContent = 'style.backgroundColor = "red"';
                                });
                                bData.addEventListener('click', () => {
                                    /** @type {HTMLElement} */ (target).dataset.id = String(Date.now());
                                    out.textContent = 'dataset.id = ' + (/** @type {HTMLElement} */ (target)).dataset.id;
                                });
                            }
                        })();</script>
                </div>
                <h5>Formulieren &amp; waarden</h5>
                <p>Form controls zoals <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> en
                    <code>&lt;select&gt;</code> hebben specifieke properties: <code>.value</code> (string),
                    <code>.checked</code> (boolean voor checkbox/radio), <code>.options</code> en
                    <code>.selectedIndex</code> (voor <code>&lt;select&gt;</code>). Type deze elementen correct om
                    properties veilig te gebruiken.
                </p>
                <pre><code>const inputEl = document.querySelector&lt;HTMLInputElement&gt;('#ageInput');
const outputEl = document.getElementById('ageOutput');
if (inputEl && outputEl) {
  inputEl.addEventListener('change', () => {
    const age = inputEl.value;
    outputEl.textContent = `Leeftijd ingevoerd: ${age}`;
  });
}</code></pre>
                <div class="live-demo">
                    <div id="tsdom-form" style="border:1px solid #ddd; padding:8px;">
                        <input id="tsdom-form-age" type="number" placeholder="Leeftijd" />
                        <span id="tsdom-form-out" style="margin-left:8px;"></span>
                    </div>
                    <script>(function () {
                            const input = document.getElementById('tsdom-form-age');
                            const out = document.getElementById('tsdom-form-out');
                            if (input && out) {
                                (/** @type {HTMLInputElement} */ (input)).addEventListener('change', () => {
                                    out.textContent = 'Leeftijd ingevoerd: ' + ((/** @type {HTMLInputElement} */ (input)).value || '(leeg)');
                                });
                            }
                        })();</script>
                </div>

                <h6>Formulieren in het DOM</h6>
                <p>Het Document Object Model (DOM) is de hiërarchische representatie van een HTML‑document in de
                    browser.
                    JavaScript kan dit DOM manipuleren om formulieren te lezen en aan te passen. Een HTML‑formulier
                    (<code>&lt;form&gt;</code>) is in de DOM een <code>HTMLFormElement</code> met daarin invoerelementen
                    zoals
                    <code>&lt;input&gt;</code>, <code>&lt;select&gt;</code>, <code>&lt;textarea&gt;</code> enzovoort.
                    Via eigenschappen en
                    methoden van deze objecten kun je gegevens uitlezen, wijzigen en versturen. developer.mozilla.org
                </p>
                <p>Een formulier kun je verkrijgen via <code>document.getElementById</code> of de speciale collectie
                    <code>document.forms</code> (alle formulieren op de pagina). Je kunt kiezen op index of op
                    <code>name</code>/<code>id</code>:
                </p>
                <pre><code>const formA = document.forms["mijnForm"]; // via name
// of via index:
const form0 = document.forms[0];
// Hierna heb je een HTMLFormElement-referentie</code></pre>
                <p>developer.mozilla.org developer.mozilla.org</p>
                <p>Belangrijke formulier‑eigenschappen:</p>
                <ul>
                    <li><code>form.elements</code> – collectie met alle controls (HTMLFormControlsCollection).
                        developer.mozilla.org</li>
                    <li><code>form.length</code> – aantal elementen (zelfde als <code>form.elements.length</code>).</li>
                    <li><code>form.action</code> en <code>form.method</code> – uitlezen of instellen waar/hoe wordt
                        verzonden.</li>
                    <li><code>form.submit()</code> – programma­tisch verzenden. <code>form.reset()</code> – terugzetten
                        naar standaardwaarden.</li>
                </ul>
                <p>Formulieren vuren events zoals <code>submit</code>. Je kunt met
                    <code>event.preventDefault()</code> voorkomen dat de pagina herlaadt en zelf de data verwerken.
                    freecodecamp.org
                </p>
                <div class="live-demo">
                    <div id="tsdom-forms-overview" style="border:1px solid #ddd; padding:8px; display:grid; gap:8px;">
                        <form id="tsdom-form-a" name="mijnForm" action="#" method="get">
                            <label for="ov-name">Naam</label>
                            <input id="ov-name" name="naam" type="text" placeholder="Naam" />
                            <button type="submit">Verzend</button>
                        </form>
                        <div style="display:flex; gap:8px; flex-wrap:wrap;">
                            <button id="btn-forms-cnt">Toon document.forms info</button>
                            <button id="btn-forms-elems">Toon form.elements</button>
                        </div>
                        <div id="forms-overview-out" style="font-size:12px; color:#555;"></div>
                    </div>
                    <script>(function () {
                            const out = document.getElementById('forms-overview-out');
                            const bCnt = document.getElementById('btn-forms-cnt');
                            const bElems = document.getElementById('btn-forms-elems');
                            if (out && bCnt && bElems) {
                                bCnt.addEventListener('click', function () {
                                    const forms = document.forms;
                                    out.textContent = 'document.forms.length=' + forms.length + ', eerste name=' + (forms[0]?.getAttribute('name') || '(geen)');
                                });
                                bElems.addEventListener('click', function () {
                                    const f = /** @type {HTMLFormElement|null} */ (document.forms['mijnForm']);
                                    if (!f) { out.textContent = 'Form niet gevonden'; return; }
                                    const names = Array.from(f.elements).map(function (el) { return /** @type {HTMLElement} */(el).getAttribute('name') || /** @type {HTMLElement} */(el).id || el.tagName; });
                                    out.textContent = 'form.elements: [' + names.join(', ') + '] (totaal=' + f.elements.length + ')';
                                });
                            }
                        })();</script>
                </div>

                <h6>Formulierelementen en hun waarden</h6>
                <p><code>&lt;input&gt;</code> (HTMLInputElement): <code>input.value</code> (string),
                    <code>input.checked</code> (checkbox/radio: boolean), <code>input.valueAsNumber</code> (number of
                    <code>NaN</code>), <code>input.disabled</code>/<code>readOnly</code>/<code>required</code>. Bij
                    <code>type=&quot;file&quot;</code>: <code>input.files</code> is een FileList. developer.mozilla.org
                    developer.mozilla.org developer.mozilla.org
                </p>
                <p><code>&lt;select&gt;</code> (HTMLSelectElement): <code>select.value</code>,
                    <code>select.selectedIndex</code>, <code>select.options</code>,
                    <code>select.multiple</code> en <code>select.selectedOptions</code>. developer.mozilla.org
                </p>
                <p><code>&lt;textarea&gt;</code> (HTMLTextAreaElement): <code>textarea.value</code>.
                    developer.mozilla.org</p>
                <p>Overig: <code>&lt;button&gt;</code> heeft <code>value</code>, <code>&lt;output&gt;</code> heeft
                    <code>.value</code>, <code>&lt;fieldset&gt;</code> heeft <code>.disabled</code>,
                    <code>&lt;label&gt;</code>
                    kan gekoppeld zijn via <code>for</code> of <code>label.control</code>.
                </p>
                <p><strong>Attribuut vs Property</strong>: HTML‑attributen zijn de initiële waarden; DOM‑properties zijn
                    de
                    actuele staat. <code>&lt;input value=&quot;hallo&quot;&gt;</code> zet de startwaarde; na typen
                    wijzigt
                    <code>input.value</code>, maar <code>getAttribute('value')</code> blijft de initiële <em>hallo</em>.
                    greatfrontend.com greatfrontend.com
                </p>
                <div class="live-demo">
                    <div id="tsdom-controls" style="border:1px solid #ddd; padding:8px; display:grid; gap:8px;">
                        <form id="tsdom-controls-form" action="#" method="post">
                            <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
                                <label for="c-text">Tekst</label>
                                <input id="c-text" name="cText" type="text" value="hallo" placeholder="typ iets" />
                                <label for="c-num">Getal</label>
                                <input id="c-num" name="cNum" type="number" value="42" />
                                <label><input id="c-check" name="cCheck" type="checkbox" /> Akkoord</label>
                                <label for="c-sel">Kleur</label>
                                <select id="c-sel" name="cSel">
                                    <option value="rood">Rood</option>
                                    <option value="groen">Groen</option>
                                    <option value="blauw">Blauw</option>
                                </select>
                                <label for="c-selm">Tags (meervoud)</label>
                                <select id="c-selm" name="cSelM" multiple size="3">
                                    <option value="html">HTML</option>
                                    <option value="css">CSS</option>
                                    <option value="js">JS</option>
                                </select>
                                <label for="c-ta">Notities</label>
                                <textarea id="c-ta" name="cTa" rows="2" cols="24">init</textarea>
                            </div>
                            <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:6px;">
                                <button id="btn-read" type="button">Toon waarden</button>
                                <button id="btn-attr-prop" type="button">Attribuut vs property</button>
                                <button id="btn-reset" type="button">Reset form</button>
                            </div>
                        </form>
                        <div id="tsdom-controls-out" style="white-space:pre-wrap; font-size:12px; color:#333;"></div>
                    </div>
                    <script>(function () {
                            const out = document.getElementById('tsdom-controls-out');
                            const bRead = document.getElementById('btn-read');
                            const bAttr = document.getElementById('btn-attr-prop');
                            const bReset = document.getElementById('btn-reset');
                            const t = /** @type {HTMLInputElement|null} */ (document.getElementById('c-text'));
                            const n = /** @type {HTMLInputElement|null} */ (document.getElementById('c-num'));
                            const ch = /** @type {HTMLInputElement|null} */ (document.getElementById('c-check'));
                            const sel = /** @type {HTMLSelectElement|null} */ (document.getElementById('c-sel'));
                            const selm = /** @type {HTMLSelectElement|null} */ (document.getElementById('c-selm'));
                            const ta = /** @type {HTMLTextAreaElement|null} */ (document.getElementById('c-ta'));
                            function log(msg) { if (out) out.textContent = msg; }
                            function selectedMultiValues(s) { return Array.from(s.selectedOptions).map(function (o) { return o.value; }); }
                            if (bRead) {
                                bRead.addEventListener('click', function () {
                                    const parts = [];
                                    parts.push('input.value=' + (t ? t.value : '(null)'));
                                    parts.push('number.valueAsNumber=' + (n ? String(n.valueAsNumber) : '(null)'));
                                    parts.push('checkbox.checked=' + (ch ? String(ch.checked) : '(null)'));
                                    parts.push('select.value=' + (sel ? sel.value : '(null)'));
                                    parts.push('select[multiple] selected=' + (selm ? JSON.stringify(selectedMultiValues(selm)) : '(null)'));
                                    parts.push('textarea.value=' + (ta ? ta.value : '(null)'));
                                    log(parts.join('\n'));
                                });
                            }
                            if (bAttr) {
                                bAttr.addEventListener('click', function () {
                                    if (!t) { log('input niet gevonden'); return; }
                                    const attrV = t.getAttribute('value');
                                    const propV = t.value;
                                    log("getAttribute('value') (init) = " + String(attrV) + "\nproperty .value (actueel) = " + propV + "\nTip: na typen wijzigt .value maar attribuut blijft gelijk.");
                                });
                            }
                            if (bReset) {
                                bReset.addEventListener('click', function () {
                                    const f = /** @type {HTMLFormElement|null} */ (document.getElementById('tsdom-controls-form'));
                                    if (f) f.reset();
                                    log('formulier gereset naar standaardwaarden');
                                });
                            }
                        })();</script>
                </div>

                <h6>Formuliervelden lezen en bijwerken</h6>
                <pre><code>const naamInput = document.getElementById('naam') as HTMLInputElement;
const kleurSelect = document.getElementById('kleur') as HTMLSelectElement;
console.log(naamInput.value);
console.log(kleurSelect.value);

// Waarden instellen
naamInput.value = 'Jan Jansen';
kleurSelect.value = 'blauw';

// Checkbox
const deelname = document.getElementById('deelname') as HTMLInputElement;
if (deelname.checked) {
  console.log('Checkbox is aangevinkt!');
}</code></pre>

                <h6>Dynamisch updaten met events</h6>
                <pre><code>const invoer = document.getElementById('mijnInput');
const output = document.getElementById('output');
invoer.addEventListener('input', function() {
    output.textContent = /** @type {HTMLInputElement} */(invoer).value;
});</code></pre>
                <div class="live-demo">
                    <div id="tsdom-live-input" style="border:1px solid #ddd; padding:8px; display:grid; gap:6px;">
                        <input id="li-input" type="text" placeholder="Typ en kijk mee…" />
                        <p id="li-output" style="margin:0; color:#333;"></p>
                    </div>
                    <script>(function () {
                            const i = document.getElementById('li-input');
                            const o = document.getElementById('li-output');
                            if (i && o) {
                                i.addEventListener('input', function () {
                                /** @type {HTMLInputElement} */(i).value;
                                    o.textContent = /** @type {HTMLInputElement} */(i).value;
                                });
                            }
                        })();</script>
                </div>

                <h6>Submit afvangen en zelf verwerken</h6>
                <pre><code>const form = document.getElementById('contactForm') as HTMLFormElement;
form.addEventListener('submit', (event) =&gt; {
  event.preventDefault(); // voorkom herlaad
  const naam = form.elements.namedItem('naam') as HTMLInputElement;
  console.log(naam.value);
  // Verwerk via fetch of lokaal
});</code></pre>
                <p>freecodecamp.org</p>
                <div class="live-demo">
                    <div id="tsdom-submit" style="border:1px solid #ddd; padding:8px; display:grid; gap:8px;">
                        <form id="tsdom-submit-form" action="#" method="post">
                            <label for="sf-name">Naam</label>
                            <input id="sf-name" name="naam" type="text" placeholder="Naam" />
                            <label for="sf-mail">E‑mail</label>
                            <input id="sf-mail" name="email" type="email" placeholder="mail@voorbeeld.be" />
                            <button type="submit">Verzend (preventDefault)</button>
                        </form>
                        <div id="tsdom-submit-out" style="font-size:12px; color:#333;"></div>
                    </div>
                    <script>(function () {
                            const f = document.getElementById('tsdom-submit-form');
                            const out = document.getElementById('tsdom-submit-out');
                            if (f && out) {
                                f.addEventListener('submit', function (ev) {
                                    ev.preventDefault();
                                    const ff = /** @type {HTMLFormElement} */ (f);
                                    const naam = /** @type {HTMLInputElement|null} */ (ff.elements.namedItem('naam'));
                                    const email = /** @type {HTMLInputElement|null} */ (ff.elements.namedItem('email'));
                                    out.textContent = 'Submit onderschept: naam=' + (naam ? naam.value : '') + ', email=' + (email ? email.value : '');
                                });
                            }
                        })();</script>
                </div>

                <h6>FormData: alle velden tegelijk uitlezen</h6>
                <pre><code>const f = document.getElementById('orderForm') as HTMLFormElement;
const data = new FormData(f);
for (const [key, value] of data) {
  console.log(`${key}: ${value}`);
}</code></pre>
                <p>FormData houdt geen velden zonder <code>name</code> en geen <code>disabled</code> velden bij.
                    developer.mozilla.org developer.mozilla.org</p>
                <div class="live-demo">
                    <div id="tsdom-formdata" style="border:1px solid #ddd; padding:8px; display:grid; gap:8px;">
                        <form id="tsdom-formdata-form" action="#" method="post">
                            <input name="product" type="text" placeholder="Product" />
                            <input name="aantal" type="number" value="1" />
                            <select name="maat">
                                <option value="S">S</option>
                                <option value="M">M</option>
                                <option value="L">L</option>
                            </select>
                            <button type="button" id="btn-fd">Lees met FormData</button>
                        </form>
                        <div id="tsdom-formdata-out" style="white-space:pre-wrap; font-size:12px; color:#333;"></div>
                    </div>
                    <script>(function () {
                            const b = document.getElementById('btn-fd');
                            const form = /** @type {HTMLFormElement|null} */ (document.getElementById('tsdom-formdata-form'));
                            const out = document.getElementById('tsdom-formdata-out');
                            if (b && form && out) {
                                b.addEventListener('click', function () {
                                    const fd = new FormData(form);
                                    const lines = [];
                                    for (const pair of fd.entries()) {
                                        lines.push(String(pair[0]) + ': ' + String(pair[1]));
                                    }
                                    out.textContent = lines.join('\n');
                                });
                            }
                        })();</script>
                </div>

                <h6>Voorbeelden en best practices</h6>
                <ul>
                    <li><strong>Elementen selecteren</strong>: gebruik <code>getElementById</code>,
                        <code>getElementsByName</code>, <code>querySelector</code>/<code>All</code>. In TypeScript: cast
                        naar
                        het juiste type waar nodig.
                    </li>
                    <li><strong>Controleer bestaan</strong>: test op <code>null</code> of gebruik optionele chaining
                        (<code>?.</code>) voordat je <code>.value</code> leest.</li>
                    <li><strong>Realtime events</strong>: gebruik <code>input</code>/<code>change</code> voor live
                        updates.</li>
                    <li><strong>Submit afhandelen</strong>: roep <code>event.preventDefault()</code> aan als je zelf
                        verwerkt. freecodecamp.org</li>
                    <li><strong>Beperk DOM‑opvragingen</strong>: cache referenties in variabelen.</li>
                    <li><strong>Attribuut vs property</strong>: gebruik <code>.value</code>/<code>.checked</code> voor
                        de
                        actuele staat; <code>getAttribute</code> geeft initiële attributen. greatfrontend.com</li>
                </ul>

                <h6>Integratie met frameworks (React) en TypeScript</h6>
                <pre><code>import React, { useState, FC } from 'react';

const ControlledForm: FC = () =&gt; {
  const [naam, setNaam] = useState&lt;string&gt;('');
  const handleChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    setNaam(e.target.value);
  };
  return (
    &lt;form&gt;
      &lt;label&gt;Naam:&lt;/label&gt;
      &lt;input type=&quot;text&quot; value={naam} onChange={handleChange} /&gt;
      &lt;button type=&quot;submit&quot;&gt;Verzenden&lt;/button&gt;
    &lt;/form&gt;
  );
};</code></pre>
                <p>dev.to dev.to</p>
                <pre><code>const input = document.getElementById('veldID') as HTMLInputElement;
console.log(input.value); // Zonder cast klaagt TS omdat HTMLElement geen .value heeft
// Tip: methods kunnen null teruggeven, check dus eventueel met if of ?. (optionele chaining)</code></pre>

                <h6>Samenvattend</h6>
                <p>DOM‑manipulatie bij formulieren draait om het opvragen van formulierelementen (
                    <code>document.forms</code>, <code>getElementById</code>), lezen/schrijven van
                    <code>.value</code>/<code>.checked</code>, en events (<code>input</code>, <code>change</code>,
                    <code>submit</code>) correct afhandelen. De <code>FormData</code>‑API verzamelt snel alle velden
                    voor
                    verzending. In frameworks als React beheer je waarden doorgaans via component‑state in plaats van
                    directe DOM‑toegang. developer.mozilla.org developer.mozilla.org dev.to
                </p>

                <h5>Verbergen, tonen en verwijderen</h5>
                <p>Verwijderen kan met <code>element.remove()</code>. Verbergen/tonen kan via CSS‑klassen
                    (<code>classList.add('hidden')</code>) of inline styles (<code>style.display = 'none'</code> en weer
                    leegmaken voor tonen). De property <code>hidden</code> (<code>true/false</code>) is ook beschikbaar.
                </p>
                <pre><code>// Verbergen met class
element.classList.add('hidden');
// Inline stijl
element.style.display = 'none';
// Verwijderen
element.remove();</code></pre>
                <div class="live-demo">
                    <div id="tsdom-hide" style="border:1px solid #ddd; padding:8px;">
                        <div id="tsdom-box" style="padding:8px; background:#eef;">Verberg/Toon mij</div>
                        <div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;">
                            <button id="tsdom-hide-btn">Verberg</button>
                            <button id="tsdom-show-btn">Toon</button>
                            <button id="tsdom-remove-btn">Verwijder</button>
                        </div>
                    </div>
                    <script>(function () {
                            const box = document.getElementById('tsdom-box');
                            const bHide = document.getElementById('tsdom-hide-btn');
                            const bShow = document.getElementById('tsdom-show-btn');
                            const bRemove = document.getElementById('tsdom-remove-btn');
                            if (box && bHide && bShow && bRemove) {
                                bHide.addEventListener('click', () => { (/** @type {HTMLElement} */ (box)).style.display = 'none'; });
                                bShow.addEventListener('click', () => { (/** @type {HTMLElement} */ (box)).style.display = ''; });
                                bRemove.addEventListener('click', () => { box.remove(); });
                            }
                        })();</script>
                </div>

                <h6>Inhoud en attributen van elementen manipuleren</h6>

                <p>Eenmaal een referentie naar een DOM-element verkregen, kun je allerlei eigenschappen en methoden
                    gebruiken om de inhoud, weergave en attributen van dat element te wijzigen. We bespreken hier de
                    belangrijkste DOM-eigenschappen en -methodes voor manipulatie en hoe je ze gebruikt in TypeScript,
                    met aandacht voor eventuele bijzonderheden.</p>

                <h6>Binnenste HTML en tekst aanpassen</h6>

                <p><code>element.innerHTML</code> – Met deze eigenschap kun je de HTML-inhoud binnenin een element
                    uitlezen of instellen. Bijvoorbeeld <code>div.innerHTML = "&lt;p&gt;Hello&lt;/p&gt;"</code> zal de
                    volledige inhoud van de <code>&lt;div&gt;</code> vervangen door een nieuw <code>&lt;p&gt;</code>
                    element</p>
                <p>developer.mozilla.org</p>
                <p>. Dit is een krachtige maar ook potentieel gevaarlijke eigenschap. Het leest of schrijft HTML als
                    string en bij schrijven zal de string door de browser als HTML-gecodeerd en in het DOM ingevoegd
                    worden. TypeScript ziet innerHTML als een property van type string (lezen geeft een string terug,
                    schrijven verwacht een string). Let op: als er geen HTML inhoud is, kan innerHTML als lege string
                    terugkomen. Een belangrijk aandachtspunt is veiligheid: direct ongecontroleerde strings in innerHTML
                    stoppen kan XSS-kwetsbaarheden introduceren, omdat daarin mogelijk <code>&lt;script&gt;</code> tags
                    of on-event attributen uitgevoerd kunnen worden</p>
                <p>developer.mozilla.org</p>
                <p>developer.mozilla.org</p>
                <p>. In TypeScript kun je dit niet automatisch voorkomen, dus als ontwikkelaar moet je oppassen met wat
                    je in innerHTML zet. Gebruik innerHTML bij voorkeur alleen met statische of veilig gegenereerde
                    strings.</p>

                <p>Kort voorbeeld: stel we hebben <code>&lt;div id="content"&gt;&lt;/div&gt;</code>, dan:</p>
                <pre><code>const content = document.getElementById('content');
if (content) {
  content.innerHTML = "&lt;p&gt;&lt;b&gt;Hallo!&lt;/b&gt; Dit is &lt;i&gt;HTML&lt;/i&gt; content.&lt;/p&gt;";
}</code></pre>

                <p>Dit creëert een vet en cursief stuk tekst binnen de div. Als je innerHTML leest
                    (<code>console.log(content.innerHTML)</code>), krijg je de HTML-string van de inhoud.</p>

                <p><code>element.textContent</code> – Hiermee krijg je of stel je de platte tekst van een element
                    (zonder HTML-tags)</p>
                <p>pluralsight.com</p>
                <p>. Het verschil met innerHTML is dat textContent geen HTML parseert. Als je iets toekent aan
                    textContent, wordt het gewoon als tekst ingevoegd, met karakters als <code>&lt;</code> en
                    <code>&gt;</code> onschadelijk gemaakt (geëscapeerd). Gebruik textContent als je puur tekst wilt
                    toevoegen of uitlezen, omdat dit ook efficiënter en veiliger is als je geen HTML-markup nodig hebt
                </p>
                <p>stackoverflow.com</p>
                <p>. Bijvoorbeeld:</p>

                <pre><code>heading.textContent = "Welkom, gebruiker!";</code></pre>

                <p>Dit plaatst de gegeven string als leesbare tekst in de heading, en alle eerdere kinderen van heading
                    worden vervangen door deze tekst (vergelijkbaar met innerHTML, maar zonder interpretatie van HTML).
                </p>

                <p><code>element.innerText</code> – Lijkt op textContent, maar er is een subtiel verschil: innerText
                    houdt rekening met de weergave (CSS) van de tekst, en retourneert alleen de zichtbare tekst in het
                    element. Ook kan het veroorzaken dat de layout gehercalculeerd wordt wanneer je het opvraagt. Over
                    het algemeen wordt innerText minder gebruikt dan textContent tenzij je specifiek de "rendered" tekst
                    nodig hebt (bijvoorbeeld om te krijgen zoals het op het scherm verschijnt, waarbij verborgen
                    elementen genegeerd worden). Voor de meeste use-cases in TypeScript volstaat textContent voor het
                    manipuleren van tekst.</p>

                <p><strong>Samenvatting tip:</strong> Gebruik innerHTML wanneer je bestaande HTML-structuur in een
                    element wilt plaatsen of lezen (en wees dan alert op veiligheid). Gebruik textContent voor het
                    werken met plain text, om html-injectie te voorkomen en performance-optimaler te zijn</p>
                <p>greatfrontend.com</p>
                <p>.</p>

                <h6>Attributen en custom data</h6>

                <p>Directe eigenschap vs. setAttribute/getAttribute: Veel HTML-attributen hebben corresponderende
                    JavaScript eigenschappen. Bijvoorbeeld <code>element.id</code>, <code>element.className</code>,
                    <code>element.href</code> (voor <code>&lt;a&gt;</code> tags), <code>element.checked</code> (voor
                    checkboxes), etc. In TypeScript kun je die vaak direct benaderen via de eigenschap op het object. Zo
                    is <code>myLink.href</code> een string met de URL van een anchor element, en
                    <code>myCheckbox.checked</code> een boolean. Dit is meestal de eenvoudigste manier en TypeScript
                    kent de types van deze properties (bijv. <code>.checked</code> is bekend als boolean eigenschap van
                    <code>HTMLInputElement</code>). Echter, soms wil je attributen benaderen die geen directe property
                    hebben, of je wilt eenduidig attribuutnamen gebruiken. In die gevallen kun je
                    <code>element.getAttribute(name)</code> en <code>element.setAttribute(name, value)</code> gebruiken.
                    Deze werken met strings voor de waarde (setAttribute zal altijd een string zetten). Bijvoorbeeld:
                </p>

                <pre><code>const img = document.querySelector('img');

img?.setAttribute('alt', 'Profielfoto');

const altText = img?.getAttribute('alt');  // altText is nu bijvoorbeeld "Profielfoto"</code></pre>

                <p>TypeScript definieert <code>getAttribute</code> als retournerend <code>string | null</code> (null als
                    attribuut niet bestaat) en <code>setAttribute</code> als <code>void</code> (het voert alleen de
                    opdracht uit).</p>

                <p><code>element.id</code> en andere globale attributen: id, className, title, etc. zijn direct als
                    properties beschikbaar. Bijvoorbeeld <code>element.id = "newId"</code> verandert het id van het
                    element. <code>element.className</code> geeft de volledige class string. NB: Voor klasse-manipulatie
                    is er een betere manier: <code>classList</code> (zie verder).</p>

                <p><code>element.classList</code> – Dit is een zeer handige eigenschap (type <em>DOMTokenList</em>)
                    waarmee je op een makkelijkere manier de CSS-classes van een element kunt manipuleren. In plaats van
                    de hele <code>className</code> string te moeten parsen of samenstellen, kun je via
                    <code>classList</code> methodes gebruiken:
                </p>

                <p><code>element.classList.add('klas1', 'klas2')</code> om één of meerdere classes toe te voegen.</p>

                <p><code>element.classList.remove('klas1')</code> om een class te verwijderen.</p>

                <p><code>element.classList.toggle('highlight')</code> om een class aan/uit te zetten (optioneel kun je
                    een tweede boolean argument geven om expliciet aan of uit te zetten).</p>

                <p><code>element.classList.contains('naam')</code> om te checken of een bepaalde class aanwezig is.</p>

                <p>TypeScript weet dat <code>classList</code> een <code>DOMTokenList</code> is en biedt autocompletion
                    voor deze methodes. Bijvoorbeeld, om een element onzichtbaar te maken via een CSS-class:</p>

                <pre><code>myElement.classList.add('hidden');</code></pre>

                <p>Later: <code>myElement.classList.remove('hidden');</code>. Dit is beter dan direct
                    <code>className</code> bewerken omdat je niet per ongeluk andere classes overschrijft. Citaat: “Elke
                    element heeft een handige classList property die je kunt gebruiken om CSS-klassen toe te voegen of
                    te verwijderen”
                </p>
                <p>pluralsight.com</p>

                <p><code>element.style</code> – Geeft toegang tot de inline CSS-stijlen van een element via een
                    <code>CSSStyleDeclaration</code> object. Hiermee kun je individuele CSS properties instellen als
                    JavaScript properties. Bijvoorbeeld:
                </p>

                <pre><code>myElement.style.backgroundColor = 'red';
myElement.style.display = 'none';</code></pre>

                <p>Let op dat de property-namen in <code>style</code> vaak in camelCase zijn (zoals
                    <code>backgroundColor</code> voor de CSS property <code>background-color</code>). TypeScript
                    definieert deze allemaal, dus je krijgt autocompletion en typecontrole (veel verwachten een string,
                    soms specifieke types zoals number voor z-index, etc.). Inline styles toepassen is direct, maar voor
                    complexere styling is het vaak beter classes te toggelen (zodat de daadwerkelijke stijl in CSS
                    blijft). Toch is <code>style</code> handig voor kleine dynamische aanpassingen (bijv. positie, kleur
                    op runtime).
                </p>

                <p>Data-attributen (data-*) en <code>dataset</code>: Voor het opslaan van custom data op HTML-elementen
                    zijn data-attributen erg handig, bijvoorbeeld <code>&lt;li data-id="123"&gt;</code>. In
                    JavaScript/TypeScript kun je al deze data-attributen benaderen via de eigenschap
                    <code>element.dataset</code>. <code>dataset</code> is een <code>DOMStringMap</code> die elk
                    data-attribuut beschikbaar maakt als eigenschap. Bijvoorbeeld, <code>li.dataset.id</code> geeft je
                    de waarde van <code>data-id</code> attribuut als string
                </p>
                <p>pluralsight.com</p>
                <p>. Let op dat de namen na <code>data-</code> in camelCase verschijnen in <code>dataset</code>. Dus
                    <code>data-user-name</code> wordt <code>element.dataset.userName</code>. Met <code>dataset</code>
                    kun je ook waarden zetten: <code>li.dataset.category = "books"</code> resulteert in
                    <code>data-category="books"</code> op het element. TypeScript definieert <code>dataset</code> zo dat
                    de waarden altijd string (of undefined als niet aanwezig) zijn. Dat betekent dat als je bijvoorbeeld
                    <code>li.dataset.id</code> gebruikt, dat van type <code>string | undefined</code> is (undefined als
                    <code>data-id</code> niet bestaat). Vaak zul je weten dat het er is, dan kun je <code>!</code> of
                    een if-check gebruiken.
                </p>

                <p><strong>Voorbeeld gebruik:</strong></p>
                <pre><code>const item = document.querySelector('li');
if (item) {
  const idStr = item.dataset.id; 
  console.log(`Data-id attribute van li: ${idStr}`);
  item.dataset.processed = "true";  // voegt data-processed="true" toe aan het li-element
}</code></pre>

                <p>Zoals Pluralsight het beschrijft: “In TypeScript kun je custom data-attributen benaderen via de
                    <code>dataset</code> property, die een <code>DOMStringMap</code> object teruggeeft. Om bijvoorbeeld
                    het <code>data-id</code> attribuut van een <code>&lt;li&gt;</code> te lezen, gebruik je
                    <code>li.dataset.id</code>.”
                </p>
                <p>pluralsight.com</p>

                <h6>Werken met form elementen en waarde-eigenschappen</h6>

                <p>Bij formulieren hebben elementen vaak bijzondere eigenschappen:</p>

                <p><code>&lt;input&gt;</code> en <code>&lt;textarea&gt;</code> elementen: hebben onder andere een
                    <code>.value</code> property (string) die de huidige invoerwaarde bevat, en voor checkboxes/radio’s
                    een <code>.checked</code> property (boolean) die aangeeft of ze aangevinkt zijn. Zoals eerder
                    genoemd, moet je in TypeScript vaak casten naar <code>HTMLInputElement</code> om bij
                    <code>.value</code> of <code>.checked</code> te kunnen als je het element via een algemene selector
                    hebt opgehaald. Alternatief is gebruik <code>querySelector&lt;HTMLInputElement&gt;</code>.
                </p>

                <p><code>&lt;select&gt;</code> elementen: hebben een <code>.value</code> voor de geselecteerde optie, en
                    ook een <code>.options</code> collectie en <code>.selectedIndex</code>. Daarnaast kun je via
                    <code>&lt;option&gt;</code> elementen hun <code>.selected</code> property instellen.
                </p>

                <p><code>&lt;form&gt;</code> elementen: hebben o.a. een <code>.elements</code> property
                    (<code>HTMLFormControlsCollection</code>) die verwijst naar de form controls binnen dat form, en een
                    <code>.submit()</code> methode om het form te submitten via script.
                </p>

                <p>TypeScript definieert elk van deze elementen met hun specifieke interfaces
                    (<code>HTMLInputElement</code>, <code>HTMLTextAreaElement</code>, <code>HTMLSelectElement</code>,
                    etc.), inclusief al deze properties. Als je bijvoorbeeld een input element correct cast, zal
                    <code>myInput.value</code> als een string beschouwd worden, en <code>myCheckbox.checked</code> als
                    boolean, waardoor je code direct type-veilig is.
                </p>

                <p><strong>Voorbeeld – invoer uitlezen en verwerken (type-veilig):</strong></p>

                <pre><code>const inputEl = document.querySelector&lt;HTMLInputElement&gt;('#ageInput');
const outputEl = document.getElementById('ageOutput');
if (inputEl \&\& outputEl) {
  inputEl.addEventListener('change', () => {
    // We casten hier niet eens, want inputEl is al HTMLInputElement
    const age = inputEl.value;  // TypeScript weet dat dit een string is
    outputEl.textContent = `Leeftijd ingevoerd: ${age}`;
  });
}</code></pre>

                <p>In dit voorbeeld wordt bij verandering van het inputveld de waarde gepakt en in een andere element
                    gezet. Merk op dat we dankzij de type parameter <code>&lt;HTMLInputElement&gt;</code> bij
                    <code>querySelector</code> direct de juiste type hebben, dus geen extra cast binnen de event handler
                    nodig. Als we dat niet hadden, zou <code>inputEl</code> type <code>Element</code> zijn en zou
                    <code>inputEl.value</code> niet compileren zonder cast.
                </p>

                <h6>Inhoud en attributen van elementen manipuleren</h6>
                <p>Eenmaal een referentie naar een DOM-element verkregen, kun je allerlei eigenschappen en methoden
                    gebruiken om de inhoud, weergave en attributen van dat element te wijzigen. We bespreken hier de
                    belangrijkste DOM-eigenschappen en -methodes voor manipulatie en hoe je ze gebruikt in TypeScript,
                    met aandacht voor eventuele bijzonderheden.</p>

                <h6>Binnenste HTML en tekst aanpassen</h6>
                <p><code>element.innerHTML</code> – Met deze eigenschap kun je de HTML-inhoud binnenin een element
                    uitlezen of instellen. Bijvoorbeeld <code>div.innerHTML = "&lt;p&gt;Hello&lt;/p&gt;"</code> zal de
                    volledige inhoud van de <code>&lt;div&gt;</code> vervangen door een nieuw <code>&lt;p&gt;</code>
                    element. Dit is krachtig maar potentieel gevaarlijk (XSS). Gebruik dit bij voorkeur alleen met
                    statische of veilig gegenereerde strings.</p>
                <pre><code>const content = document.getElementById('content');
if (content) {
  content.innerHTML = "&lt;p&gt;&lt;b&gt;Hallo!&lt;/b&gt; Dit is &lt;i&gt;HTML&lt;/i&gt; content.&lt;/p&gt;";
}</code></pre>
                <p><code>element.textContent</code> – Hiermee krijg je of stel je de platte tekst (zonder HTML-tags).
                    Het parseert geen HTML en is daarmee veiliger en vaak efficiënter. <code>element.innerText</code>
                    houdt rekening met zichtbaarheid en layout; gebruik het alleen als je de gerenderde tekst nodig
                    hebt. Tip: gebruik <code>innerHTML</code> voor HTML-structuur, <code>textContent</code> voor pure
                    tekst.</p>

                <h6>Attributen en custom data</h6>
                <p>Veel HTML-attributen hebben corresponderende eigenschappen (bv. <code>id</code>,
                    <code>className</code>, <code>checked</code>). Voor overige attributen gebruik je
                    <code>getAttribute</code>/<code>setAttribute</code> (waarden als string).
                </p>
                <pre><code>const img = document.querySelector('img');
img?.setAttribute('alt', 'Profielfoto');
const altText = img?.getAttribute('alt');</code></pre>
                <p><code>element.classList</code> (type <em>DOMTokenList</em>) om klassen te beheren:
                    <code>add</code>, <code>remove</code>, <code>toggle</code>, <code>contains</code>. Voor inline
                    stijlen gebruik je <code>element.style</code> (camelCase properties):
                </p>
                <pre><code>myElement.style.backgroundColor = 'red';
myElement.style.display = 'none';</code></pre>
                <p>Data-attributen via <code>dataset</code> (type <em>DOMStringMap</em>):</p>
                <pre><code>const item = document.querySelector('li');
if (item) {
  const idStr = item.dataset.id;
  item.dataset.processed = "true";
}</code></pre>

                <h6>Werken met form elementen en waarde-eigenschappen</h6>
                <p><code>&lt;input&gt;</code>/<code>&lt;textarea&gt;</code> hebben o.a. <code>.value</code> (string);
                    checkbox/radio hebben <code>.checked</code> (boolean). <code>&lt;select&gt;</code> heeft
                    <code>.value</code>, <code>.options</code>, <code>.selectedIndex</code>. Typ de elementen correct
                    (bv. met generics) om properties veilig te gebruiken.
                </p>
                <pre><code>const inputEl = document.querySelector&lt;HTMLInputElement&gt;('#ageInput');
const outputEl = document.getElementById('ageOutput');
if (inputEl && outputEl) {
  inputEl.addEventListener('change', () => {
    const age = inputEl.value;
    outputEl.textContent = `Leeftijd ingevoerd: ${age}`;
  });
}</code></pre>

                <div class="live-demo">
                    <div id="tsdom-vtv" style="border:1px solid #ddd; padding:8px;">
                        <div id="tsdom-vtv-target" style="padding:6px; background:#fafafa; margin-bottom:8px;"></div>
                        <div style="display:flex; gap:8px; flex-wrap:wrap;">
                            <button id="tsdom-vtv-html">innerHTML</button>
                            <button id="tsdom-vtv-text">textContent</button>
                        </div>
                        <div id="tsdom-vtv-out" style="margin-top:8px;"></div>
                    </div>
                    <script>(function () {
                            var target = document.getElementById('tsdom-vtv-target');
                            var out = document.getElementById('tsdom-vtv-out');
                            var bHtml = document.getElementById('tsdom-vtv-html');
                            var bText = document.getElementById('tsdom-vtv-text');
                            if (target && out && bHtml && bText) {
                                bHtml.addEventListener('click', function () {
                                    target.innerHTML = '<p><b>Hallo!</b> Dit is <i>HTML</i> content.</p>';
                                    out.textContent = 'innerHTML gezet';
                                });
                                bText.addEventListener('click', function () {
                                    target.textContent = '<b>Hallo</b> als tekst';
                                    out.textContent = 'textContent gezet';
                                });
                            }
                        })();</script>
                </div>

                <h5>Elementen maken en toevoegen</h5>
                <p>Maak elementen met <code>document.createElement(tag)</code>. TypeScript geeft het juiste subtype
                    terug (via <code>HTMLElementTagNameMap</code>). Tekst voeg je toe met <code>textContent</code> of
                    <code>createTextNode</code>. Voeg toe met <code>appendChild</code>, of modern
                    <code>append</code>/<code>prepend</code>/<code>before</code>/<code>after</code>/<code>replaceWith</code>.
                </p>
                <pre><code>const content = document.getElementById('content');
if (content) {
  const newPara = document.createElement('p');
  newPara.textContent = 'Deze paragraaf is dynamisch toegevoegd.';
  newPara.classList.add('highlight');
  content.appendChild(newPara);
}</code></pre>
                <div class="live-demo">
                    <div id="tsdom-create" style="border:1px solid #ddd; padding:8px;">
                        <div id="tsdom-create-target"
                            style="min-height:24px; background:#fafafa; margin-bottom:8px; padding:6px;"></div>
                        <button id="tsdom-add-p">Voeg paragraaf toe</button>
                    </div>
                    <script>(function () {
                            const target = document.getElementById('tsdom-create-target');
                            const btn = document.getElementById('tsdom-add-p');
                            if (target && btn) {
                                btn.addEventListener('click', () => {
                                    const p = document.createElement('p');
                                    p.textContent = 'Deze paragraaf is dynamisch toegevoegd.';
                                    p.classList.add('highlight');
                                    target.appendChild(p);
                                });
                            }
                        })();</script>
                </div>

                <h6>Elementen maken en toevoegen (DOM bouwen)</h6>
                <p>Dynamische webpagina’s maken betekent vaak nieuwe elementen creëren of klonen, en in het DOM
                    plaatsen. Hier zijn de kernmethoden:</p>

                <p><code>document.createElement(tagName)</code> – Hiermee maak je een nieuw element van het gegeven
                    type. TypeScript’s definitie is slim: het gebruikt generics om het juiste type terug te geven op
                    basis van de <em>tagName</em> die je meegeeft
                    typescriptlang.org
                    . Bijvoorbeeld <code>document.createElement('p')</code> retourneert een
                    <code>HTMLParagraphElement</code>
                    type, en <code>document.createElement('button')</code> geeft een <code>HTMLButtonElement</code>.
                    Dit werkt via een interne map van tag-namen naar types (<code>HTMLElementTagNameMap</code>)
                    typescriptlang.org
                    typescriptlang.org
                    . Als je een onbekende <em>tagName</em> doorgeeft (iets wat geen standaard HTML tag is), krijg je
                    gewoon <code>HTMLElement</code> terug. Dit mechanisme maakt je code weer type-veiliger, want de
                    variabele die het resultaat opvangt heeft meteen de juiste specifieke eigenschappen.
                </p>

                <p><strong>Voorbeeld:</strong></p>
                <pre><code>const newDiv = document.createElement('div');  // type HTMLDivElement
newDiv.id = "popup";  // je kunt nu gewoon .id of andere HTMLDivElement props gebruiken</code></pre>

                <p>Je kunt daarna eventueel attributen instellen (via properties of <code>setAttribute</code>), content
                    toevoegen, etc.</p>

                <p><code>document.createTextNode(text)</code> – Maakt een nieuw tekstnode die de opgegeven tekst bevat.
                    In de praktijk gebruik je <code>createTextNode</code> niet zo vaak meer, omdat je tekst ook direct
                    als <code>textContent</code> of <code>innerHTML</code> van een nieuw element kunt zetten. Maar het
                    is
                    goed om te weten dat het bestaat. In TypeScript retourneert dit een <code>Text</code> node (die een
                    subtype is van <code>Node</code>, niet van <code>HTMLElement</code>).</p>

                <p><code>element.appendChild(node)</code> – Voegt een node (bijv. een element of tekstnode) toe als
                    laatste kind van het opgegeven ouderelement. Retourneert de toegevoegde node. Dit is een methode van
                    het basistype <code>Node</code> in de DOM, en alle elementen (die ook Nodes zijn) erven dit.
                    TypeScript definieert het generiek zodat het dezelfde type teruggeeft die je meegeeft
                    typescriptlang.org
                    . Bijvoorbeeld: <code>const para = document.createElement('p'); container.appendChild(para);</code>
                    hier is de return van <code>appendChild</code> getypeerd als <code>HTMLParagraphElement</code>. Vaak
                    negeer je de return omdat je meestal al de referentie had (zoals <code>para</code> in dit geval).
                </p>

                <p>Als je een element wil toevoegen voor een bepaald ander element, kun je
                    <code>parent.insertBefore(newNode, referenceNode)</code> gebruiken. En om te vervangen is er
                    <code>parent.replaceChild(newNode, oldNode)</code>. Deze worden minder vaak direct gebruikt, maar ze
                    bestaan.
                </p>

                <p><strong>Modernere methoden:</strong> Er bestaan ook <code>element.append(...nodesOrStrings)</code> en
                    <code>element.prepend(...nodesOrStrings)</code> in de DOM API. Deze kunnen meerdere nodes of strings
                    (die dan als textnodes worden behandeld) tegelijk toevoegen. Bijvoorbeeld:
                    <code>container.append('Hello ', strongElem, '!')</code>. Deze geven niets terug en kunnen handig
                    zijn
                    voor korte toevoegingen. TypeScript kent deze methodes ook aan de hand van de <em>lib.dom</em>
                    types.
                    Daarnaast kun je met <code>element.before(...)</code> of <code>element.after(...)</code> dingen op
                    dezelfde niveau plaatsen (siblings voor of na een bepaald element), en
                    <code>element.replaceWith(newNode)</code> om een element in één keer te vervangen. Dit zijn handige
                    DOM API’s om te weten; ze zijn wat moderner (IE11 ondersteunt ze bijvoorbeeld niet zonder
                    polyfills).
                </p>

                <p><strong>Voorbeeld – Een nieuw element dynamisch toevoegen:</strong></p>
                <p>Stel je wil via TypeScript een nieuwe paragraaf met tekst aan een bestaande
                    <code>&lt;div id="content"&gt;</code> toevoegen:
                </p>
                <pre><code>const content = document.getElementById('content');
if (content) {
  const newPara = document.createElement('p');              // maak &lt;p&gt;
  newPara.textContent = "Deze paragraaf is dynamisch toegevoegd.";  // stel tekst in
  newPara.classList.add('highlight');                       // voeg eventueel een CSS-class toe
  content.appendChild(newPara);                             // voeg p toe als laatste kind van #content
}</code></pre>

                <p>Na uitvoeren van dit script zou de HTML er als volgt uitzien:</p>
                <pre><code>&lt;div id="content"&gt;
  ... (oorspronkelijke inhoud) ...
  &lt;p class="highlight"&gt;Deze paragraaf is dynamisch toegevoegd.&lt;/p&gt;
&lt;/div&gt;</code></pre>

                <p>We zien dat we hier <code>textContent</code> gebruikten om de tekst in te stellen. We hadden ook
                    <code>innerHTML</code> kunnen gebruiken, bijvoorbeeld als we een stukje HTML wilden toevoegen met
                    opmaak. Let ook op het gebruik van <code>classList.add</code> om de paragraaf een
                    <code>highlight</code>-class te geven voor styling.
                </p>

                <div class="live-demo">
                    <div id="tsdom-build" style="border:1px solid #ddd; padding:8px; display:grid; gap:8px;">
                        <div>
                            <div id="tsdom-build-content" style="padding:6px; background:#fafafa; min-height:28px;">
                                <span id="tsdom-build-ref" style="background:#eef; padding:2px 4px;">[ref]</span>
                            </div>
                        </div>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
                            <button id="tsdom-build-create-append">createElement + appendChild</button>
                            <button id="tsdom-build-textnode">createTextNode</button>
                            <button id="tsdom-build-append">append (string + node)</button>
                            <button id="tsdom-build-prepend">prepend</button>
                            <button id="tsdom-build-insertBefore">insertBefore (voor ref)</button>
                            <button id="tsdom-build-replaceChild">replaceChild (eerste)</button>
                            <button id="tsdom-build-before">before (voor ref)</button>
                            <button id="tsdom-build-after">after (na ref)</button>
                            <button id="tsdom-build-replaceWith">replaceWith (op ref)</button>
                            <button id="tsdom-build-reset">Reset</button>
                        </div>
                        <div id="tsdom-build-out" style="font-size:12px; color:#555;"></div>
                    </div>
                    <script>(function () {
                            var content = document.getElementById('tsdom-build-content');
                            var ref = document.getElementById('tsdom-build-ref');
                            var out = document.getElementById('tsdom-build-out');
                            function log(msg) { if (out) { out.textContent = msg; } }
                            function reset() {
                                if (!content) return;
                                content.innerHTML = '';
                                var r = document.createElement('span');
                                r.id = 'tsdom-build-ref';
                                r.style.background = '#eef';
                                r.style.padding = '2px 4px';
                                r.textContent = '[ref]';
                                content.appendChild(r);
                                ref = r;
                                log('Gerest: ref opnieuw geplaatst.');
                            }
                            function strongNode(text) {
                                var s = document.createElement('strong');
                                s.textContent = text;
                                return s;
                            }
                            var bCreateAppend = document.getElementById('tsdom-build-create-append');
                            var bTextNode = document.getElementById('tsdom-build-textnode');
                            var bAppend = document.getElementById('tsdom-build-append');
                            var bPrepend = document.getElementById('tsdom-build-prepend');
                            var bInsertBefore = document.getElementById('tsdom-build-insertBefore');
                            var bReplaceChild = document.getElementById('tsdom-build-replaceChild');
                            var bBefore = document.getElementById('tsdom-build-before');
                            var bAfter = document.getElementById('tsdom-build-after');
                            var bReplaceWith = document.getElementById('tsdom-build-replaceWith');
                            var bReset = document.getElementById('tsdom-build-reset');
                            if (bCreateAppend && content) {
                                bCreateAppend.addEventListener('click', function () {
                                    var p = document.createElement('p');
                                    p.textContent = 'Nieuw element via createElement + appendChild';
                                    p.classList.add('highlight');
                                    content.appendChild(p);
                                    log('appendChild: <p> toegevoegd.');
                                });
                            }
                            if (bTextNode && content) {
                                bTextNode.addEventListener('click', function () {
                                    var t = document.createTextNode(' [txt]');
                                    content.appendChild(t);
                                    log('createTextNode: tekstnode toegevoegd.');
                                });
                            }
                            if (bAppend && content) {
                                bAppend.addEventListener('click', function () {
                                    content.append(' Hello ', strongNode('WORLD'), '!');
                                    log('append: string + <strong> toegevoegd.');
                                });
                            }
                            if (bPrepend && content) {
                                bPrepend.addEventListener('click', function () {
                                    var i = document.createElement('i');
                                    i.textContent = 'BEGIN ';
                                    content.prepend(i);
                                    log('prepend: <i> als eerste kind toegevoegd.');
                                });
                            }
                            if (bInsertBefore && content) {
                                bInsertBefore.addEventListener('click', function () {
                                    if (!ref) return;
                                    var span = document.createElement('span');
                                    span.textContent = '[voor-ref] ';
                                    content.insertBefore(span, ref);
                                    log('insertBefore: node voor [ref] geplaatst.');
                                });
                            }
                            if (bReplaceChild && content) {
                                bReplaceChild.addEventListener('click', function () {
                                    if (!content.firstChild) return;
                                    var s = document.createElement('span');
                                    s.textContent = '[replaced]';
                                    content.replaceChild(s, content.firstChild);
                                    log('replaceChild: eerste kind vervangen.');
                                });
                            }
                            if (bBefore && ref) {
                                bBefore.addEventListener('click', function () {
                                    var em = document.createElement('em');
                                    em.textContent = '{before} ';
                                    ref.before(em);
                                    log('before: sibling voor [ref] geplaatst.');
                                });
                            }
                            if (bAfter && ref) {
                                bAfter.addEventListener('click', function () {
                                    var em = document.createElement('em');
                                    em.textContent = ' {after}';
                                    ref.after(em);
                                    log('after: sibling na [ref] geplaatst.');
                                });
                            }
                            if (bReplaceWith && ref) {
                                bReplaceWith.addEventListener('click', function () {
                                    var mark = document.createElement('mark');
                                    mark.textContent = '[ref vervangen]';
                                    ref.replaceWith(mark);
                                    ref = mark; // nieuwe referentie
                                    log('replaceWith: [ref] vervangen door <mark>.');
                                });
                            }
                            if (bReset) { bReset.addEventListener('click', reset); }
                        })();</script>
                </div>

                <h5>Events</h5>
                <h6>Event handlers toevoegen (interactieve UI)</h6>
                <p>Webpagina’s worden echt dynamisch door events: gebruikersinteracties zoals klikken, typen,
                    muisbewegingen, etc. In TypeScript kun je op dezelfde manier als in JavaScript event listeners
                    toevoegen, maar het grote voordeel is dat TypeScript de event-objecten typeert, zodat je weet
                    welke eigenschappen beschikbaar zijn en je minder snel fouten maakt.</p>
                <p>De meest gebruikte manier is <code>element.addEventListener(eventType, handler)</code>. Hierbij is
                    <code>eventType</code> een string zoals <code>"click"</code>, <code>"input"</code>,
                    <code>"keydown"</code>, etc., en <em>handler</em> een functie die wordt aangeroepen als het event
                    plaatsvindt. TypeScript heeft voor veel standaard event types overloads gedefinieerd, zodat het type
                    van het event-object in de handler correct is. Bijvoorbeeld:
                </p>
                <pre><code>button.addEventListener('click', (event) => {
  // hier ziet TS 'event' als MouseEvent
  console.log(`Button clicked at coords: ${event.clientX}, ${event.clientY}`);
});</code></pre>
                <p>In bovenstaand geval weet TypeScript dat bij een 'click' event het een MouseEvent betreft (met
                    eigenschappen als <code>clientX</code>, <code>clientY</code>, <code>button</code> etc.
                    beschikbaar)</p>
                <p>pluralsight.com</p>
                <p>Als je 'keydown' kiest, wordt het een KeyboardEvent (met bv. <code>event.key</code> om de toets te
                    zien). Dit is ontzettend handig, want het voorkomt dat je bijv. per ongeluk <code>event.key</code>
                    op een muis-event probeert te lezen (wat niet bestaat).</p>
                <p><strong>Event target typen</strong>: Een veelvoorkomend scenario is dat je binnen een event-handler
                    iets met het doelwit-element (<code>event.target</code>) wilt doen. <code>event.target</code> is
                    getypeerd als een generieke <code>EventTarget</code>, waar niet direct bijvoorbeeld een
                    <code>.value</code> op zit. Als je zeker weet dat de target een bepaald type element is, moet je
                    casten:
                </p>
                <pre><code>input.addEventListener('change', (e) => {
  const target = e.target as HTMLInputElement;
  console.log(`Nieuwe waarde: ${target.value}`);
});</code></pre>
                <p>Hier casten we <code>e.target</code> naar <code>HTMLInputElement</code> om de <code>.value</code>
                    eigenschap te kunnen uitlezen. Let op: soms kun je ook <code>e.currentTarget</code> gebruiken, die
                    is
                    getypeerd als het element waarop de listener zit (in bovenstaande geval zou
                    <code>e.currentTarget</code> al als <code>HTMLInputElement</code> getypeerd kunnen zijn, omdat we de
                    listener aan een specifieke input koppelden). Echter, <code>currentTarget</code> is in TypeScript
                    declaraties vaak een beetje generiek tenzij je er zelf een generic voor gebruikt, dus de expliciete
                    cast is gangbaar.
                </p>
                <p><strong>Onevent properties</strong>: Naast <code>addEventListener</code> is er ook de mogelijkheid om
                    direct een event eigenschap te gebruiken, zoals
                    <code>element.onclick = function(evt) { ... }</code>.
                    In TypeScript zijn deze eigenschappen (zoals <code>.onclick</code>, <code>.onchange</code>, etc.)
                    ook getypeerd. Bijvoorbeeld <code>HTMLElement.onclick</code> is van type
                    <code>(this: HTMLElement, ev: MouseEvent) =&gt; any</code> (of <code>null</code> als geen handler).
                    Dat betekent dat als je een functie toewijst, deze aan die vorm moet voldoen. Meestal voldoet een
                    arrow function zonder parameters ook, omdat extra params genegeerd worden.
                    <code>element.onclick = () =&gt; { ... }</code> werkt dus, net als
                    <code>element.onclick = (event) =&gt; { ... }</code> (met <code>event</code> als
                    <code>MouseEvent</code>). Let wel dat je via deze manier maar één handler tegelijk kunt hebben
                    (nieuw
                    toewijzen overschrijft de oude). Daarom is <code>addEventListener</code> flexibeler (je kunt
                    meerdere
                    handlers van hetzelfde type toevoegen en ook specifiek verwijderen met
                    <code>removeEventListener</code>).
                </p>
                <p><strong>Voorbeeld – Klik event verwerken:</strong></p>
                <pre><code>const btn = document.querySelector&lt;HTMLButtonElement&gt;('#saveBtn');
if (btn) {
  btn.addEventListener('click', () =&gt; {
    console.log('Opslaan-knop geklikt!');
    btn.textContent = "Opgeslagen";  // verander de knoptekst bijvoorbeeld
  });
}</code></pre>
                <p>Als de gebruiker op de knop met id <code>"saveBtn"</code> klikt, ziet de console het bericht en de
                    knoptekst verandert. TypeScript zorgt ervoor dat:</p>
                <ul>
                    <li><code>btn</code> een <code>HTMLButtonElement | null</code> is, en we checken op truthiness.</li>
                    <li>Binnen de handler is <code>btn</code> nog steeds die button (via closure) en we kunnen veilig
                        <code>textContent</code> aanpassen.
                    </li>
                    <li>Het event-object hebben we hier niet eens nodig, maar als we <code>event</code> als parameter
                        hadden, zou TypeScript dat als <code>MouseEvent</code> interpreteren.</li>
                </ul>
                <p><strong>Voorbeeld – Toetsenbord event:</strong></p>
                <pre><code>window.addEventListener('keydown', (e) =&gt; {
  if (e.key === 'Enter') {
    console.log('Enter ingedrukt');
  }
});</code></pre>
                <p>Hier levert TypeScript ons dat <code>e</code> een <code>KeyboardEvent</code> is, met een
                    <code>key</code> eigenschap van type <code>string</code> die de toets vertegenwoordigt.
                </p>
                <div class="live-demo">
                    <div id="tsdom-events-intro" style="border:1px solid #ddd; padding:8px; display:grid; gap:8px;">
                        <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
                            <button id="tsdom-ev-btn">Klik mij</button>
                            <span id="tsdom-ev-out"></span>
                        </div>
                        <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
                            <input id="tsdom-ev-input" type="text" placeholder="Typ en verander (blur)" />
                            <span id="tsdom-ev-input-out"></span>
                        </div>
                        <div><span id="tsdom-ev-key-out"></span></div>
                    </div>
                    <script>(function () {
                            var btn = document.getElementById('tsdom-ev-btn');
                            var out = document.getElementById('tsdom-ev-out');
                            var inp = document.getElementById('tsdom-ev-input');
                            var inpOut = document.getElementById('tsdom-ev-input-out');
                            var keyOut = document.getElementById('tsdom-ev-key-out');
                            if (btn && out) {
                                btn.addEventListener('click', function (event) {
                                    out.textContent = 'Coords: ' + (event.clientX || 0) + ', ' + (event.clientY || 0);
                                });
                            }
                            if (inp && inpOut) {
                                inp.addEventListener('change', function (e) {
                                    var target = e.target; // HTMLInputElement in TS; hier runtime check
                                    inpOut.textContent = 'Nieuwe waarde: ' + (target && target.value !== undefined ? target.value : '');
                                });
                            }
                            if (keyOut) {
                                window.addEventListener('keydown', function (e) {
                                    if (e.key === 'Enter') {
                                        keyOut.textContent = 'Enter ingedrukt';
                                    }
                                });
                            }
                        })();</script>
                </div>
                <p>Voeg event handlers toe met <code>addEventListener</code>. TypeScript geeft sterke types aan het
                    event‑object (<code>MouseEvent</code>, <code>KeyboardEvent</code>, ...). Voor het doelwit kun je
                    <code>e.target</code> casten of <code>e.currentTarget</code> gebruiken.
                </p>
                <pre><code>const btn = document.querySelector&lt;HTMLButtonElement&gt;('#saveBtn');
if (btn) {
  btn.addEventListener('click', () =&gt; {
    console.log('Opslaan-knop geklikt!');
    btn.textContent = 'Opgeslagen';
  });
}

window.addEventListener('keydown', (e) =&gt; {
  if (e.key === 'Enter') {
    console.log('Enter ingedrukt');
  }
});</code></pre>
                <div class="live-demo">
                    <div id="tsdom-events"
                        style="border:1px solid #ddd; padding:8px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
                        <button id="tsdom-save">Opslaan</button>
                        <span id="tsdom-kb-out" style="min-width:160px;"></span>
                    </div>
                    <script>(function () {
                            const btn = /** @type {HTMLButtonElement} */ (document.getElementById('tsdom-save'));
                            const out = document.getElementById('tsdom-kb-out');
                            if (btn) btn.addEventListener('click', () => { btn.textContent = 'Opgeslagen'; });
                            if (out) {
                                window.addEventListener('keydown', (e) => {
                                    if (e.key === 'Enter') { out.textContent = 'Enter ingedrukt'; }
                                });
                            }
                        })();</script>
                </div>

                <h6>Event handlers en <code>this</code></h6>
                <p>Let op dat in traditionele DOM events, binnen een event handler functie (niet arrow function)
                    <code>this</code> refereert aan het element zelf. TypeScript houdt hier ook rekening mee in de
                    type‑definities bij gebruik van <code>on&lt;event&gt;</code> properties. Bijvoorbeeld, als je
                    <code>element.onclick = function(e) { console.log(this) }</code>, dan zal <code>this</code> binnen
                    die
                    functie gezien worden als <code>HTMLElement</code> in TypeScript (specifieker als het element’s type
                    als bekend). Bij arrow functies is <code>this</code> lexicaal gebonden (dus niet relevant aan het
                    element). Dit is een detail, maar goed om te weten als je met <code>function</code> keywords events
                    bindt.
                </p>
                <div class="live-demo">
                    <div id="tsdom-this-demo"
                        style="border:1px solid #ddd; padding:8px; display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
                        <button id="tsdom-this-btn">Klik (function handler)</button>
                        <span id="tsdom-this-out"></span>
                    </div>
                    <script>(function () {
                            const btn = document.getElementById('tsdom-this-btn');
                            const out = document.getElementById('tsdom-this-out');
                            if (btn && out) {
                                // function handler: this verwijst naar element
                                btn.onclick = function (e) {
                                    // @ts-ignore - demonstratie van runtime this op HTMLElement
                                    out.textContent = 'this === button: ' + (this === btn);
                                };
                            }
                        })();</script>
                </div>

                <h6>Verwijderen van event handlers</h6>
                <p>Mocht je ooit een event listener willen verwijderen, onthoud dan dat de functie referentie exact moet
                    matchen. Je kunt niet een anonieme functie weer verwijderen zonder referentie, dus meestal definieer
                    je de handler los:</p>
                <pre><code>function handler(event: Event) { /* ... */ }
element.addEventListener('focus', handler);
// ... later ...
element.removeEventListener('focus', handler);</code></pre>
                <p>TypeScript checkt ook bij <code>removeEventListener</code> of het event‑type klopt en de handler het
                    juiste type had voor dat event (omdat het dezelfde overload‑set gebruikt).</p>

                <h5>Voorbeeld: mini to‑do lijst</h5>
                <p>Een klein projectje dat selecteren, creëren, classes toggelen en events samenbrengt. Klik op
                    “Toevoegen” om een taak toe te voegen. Vink af om te voltooien, “Verwijder” om te verwijderen.</p>
                <pre><code>&lt;input id="taskInput" type="text" placeholder="Nieuwe taak..." /&gt;
&lt;button id="addBtn"&gt;Toevoegen&lt;/button&gt;
&lt;ul id="taskList"&gt;&lt;/ul&gt;

const input = document.querySelector&lt;HTMLInputElement&gt;('#taskInput');
const addBtn = document.getElementById('addBtn');
const list = document.getElementById('taskList');

addBtn?.addEventListener('click', () =&gt; {
  if (!input || !list) return;
  const text = input.value.trim();
  if (text === '') return;

  const li = document.createElement('li');
  const checkbox = document.createElement('input');
  checkbox.type = 'checkbox';
  const span = document.createElement('span');
  span.textContent = text;
  const removeBtn = document.createElement('button');
  removeBtn.textContent = 'Verwijder';

  li.appendChild(checkbox);
  li.appendChild(span);
  li.appendChild(removeBtn);
  list.appendChild(li);
  input.value = '';

  checkbox.addEventListener('change', () =&gt; {
    li.classList.toggle('done', checkbox.checked);
  });
  removeBtn.addEventListener('click', () =&gt; { li.remove(); });
});</code></pre>
                <div class="live-demo">
                    <div id="tsdom-todo" style="border:1px solid #ddd; padding:8px;">
                        <input id="tsdom-task" type="text" placeholder="Nieuwe taak..." />
                        <button id="tsdom-add">Toevoegen</button>
                        <ul id="tsdom-list" style="margin-top:8px; display:grid; gap:6px; padding-left:18px;"></ul>
                        <style>
                            #tsdom-todo li.done span {
                                text-decoration: line-through;
                                color: #777;
                            }
                        </style>
                    </div>
                    <script>(function () {
                            const input = /** @type {HTMLInputElement} */ (document.getElementById('tsdom-task'));
                            const addBtn = document.getElementById('tsdom-add');
                            const list = document.getElementById('tsdom-list');
                            if (addBtn && input && list) {
                                addBtn.addEventListener('click', () => {
                                    const text = input.value.trim();
                                    if (!text) return;
                                    const li = document.createElement('li');
                                    const checkbox = document.createElement('input');
                                    checkbox.type = 'checkbox';
                                    const span = document.createElement('span');
                                    span.textContent = text;
                                    const removeBtn = document.createElement('button');
                                    removeBtn.textContent = 'Verwijder';
                                    li.appendChild(checkbox);
                                    li.appendChild(span);
                                    li.appendChild(removeBtn);
                                    list.appendChild(li);
                                    input.value = '';
                                    checkbox.addEventListener('change', () => {
                                        li.classList.toggle('done', checkbox.checked);
                                    });
                                    removeBtn.addEventListener('click', () => { li.remove(); });
                                });
                            }
                        })();</script>
                </div>

                <h5>Integratie met frameworks</h5>
                <h5>React</h5>
                <p>React werkt met een Virtual DOM. Directe DOM‑manipulatie gebeurt zelden; je gebruikt state en props.
                    Voor uitzonderingen gebruik je refs. In TypeScript typ je events als <code>React.MouseEvent</code>
                    en refs met <code>useRef&lt;HTMLButtonElement&gt;</code>.</p>
                <h6>React (met TypeScript)</h6>
                <p>React gebruikt een virtuele DOM en JSX om UI te definiëren. Als ontwikkelaar voeg of verwijder je
                    geen
                    DOM‑elementen direct; je past de state of props aan en React zorgt voor de juiste DOM‑updates. Toch
                    zijn er situaties waar je directe DOM‑toegang nodig hebt, zoals:</p>
                <ul>
                    <li>Een element focus geven (bijv. input automatisch focus bij mount).</li>
                    <li>Scrollposities meten of iets met de layout doen.</li>
                    <li>Integratie met een niet‑React bibliotheek die direct DOM gebruikt (bijv. een jQuery plugin of
                        een D3 chart).</li>
                    <li>Het gebruik van canvas of andere gevallen waar je imperative controle nodig hebt.</li>
                </ul>
                <p>React biedt hiervoor Refs (references). In TypeScript kun je refs type‑veilig gebruiken. Bijvoorbeeld
                    met functionele componenten gebruik je de <code>useRef</code> hook:</p>
                <pre><code>import { useRef, useEffect } from 'react';

function Form() {
  const inputRef = useRef&lt;HTMLInputElement&gt;(null);

  useEffect(() =&gt; {
    if (inputRef.current) {
      inputRef.current.focus();  // zet focus op de input bij laden
    }
  }, []);

  return &lt;input ref={inputRef} type="text" placeholder="Typ iets" /&gt;;
}</code></pre>
                <p>Hier:</p>
                <ul>
                    <li><code>useRef&lt;HTMLInputElement&gt;(null)</code> creëert een ref waarvan <code>current</code>
                        uiteindelijk een
                        <code>HTMLInputElement</code> zal bevatten. We initialiseren met <code>null</code> (tot het
                        element gerenderd is).<br />angularminds.com
                    </li>
                    <li>Na render (in <code>useEffect</code> met lege dependency array) checken we of
                        <code>inputRef.current</code> er is, en zo ja, roepen we <code>.focus()</code> aan. TypeScript
                        weet dat
                        <code>inputRef.current</code> een <code>HTMLInputElement</code> is zodra het niet null is (door
                        de generieke type).
                    </li>
                    <li>We geven de ref door aan het <code>&lt;input&gt;</code> element in JSX via
                        <code>ref={inputRef}</code>. React zorgt
                        ervoor dat bij mount <code>inputRef.current</code> naar het DOM‑element wijst.
                    </li>
                    <li>Met class‑componenten is het vergelijkbaar, maar dan gebruik je <code>React.createRef()</code>.
                        TypeScript kan ook
                        daar het type van de ref bepalen, bijvoorbeeld
                        <code>this.inputRef = React.createRef&lt;HTMLInputElement&gt;()</code>,
                        en later <code>this.inputRef.current?.focus()</code> in <code>componentDidMount</code>.
                    </li>
                    <li>In React met TypeScript krijg je ook hulp bij event handlers in JSX: bijvoorbeeld
                        <code>&lt;button onClick={e =&gt; handleClick(e)}&gt;</code> zal <code>e</code> als
                        <code>React.MouseEvent&lt;HTMLButtonElement&gt;</code> typeren. Dat lijkt op de normale DOM
                        <code>MouseEvent</code> maar is een specifiek type van React (met o.a. <code>e.persist()</code>
                        voor async gebruik).
                        Je kunt altijd <code>e.currentTarget</code> casten indien nodig.
                    </li>
                    <li>Belangrijk: vermijd direct DOM gebruik via <code>document</code> methodes in React, omdat dat
                        buiten React’s beheer
                        om gaat. Gebruik refs zoals hierboven. In uitzonderingen kan het, maar je bent dan zelf
                        verantwoordelijk voor UI‑consistentie.</li>
                </ul>
                <div class="live-demo">
                    <div id="react-ref-demo"
                        style="border:1px solid #ddd; padding:8px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
                        <input id="react-ref-input" type="text" placeholder="Typ iets" />
                        <button id="react-ref-mount">Simuleer mount (focus input)</button>
                        <span id="react-ref-status" style="min-width:180px;"></span>
                    </div>
                    <script>(function () {
                            var input = document.getElementById('react-ref-input');
                            var btn = document.getElementById('react-ref-mount');
                            var status = document.getElementById('react-ref-status');
                            if (btn && input && status) {
                                btn.addEventListener('click', function () {
                                    input.focus();
                                    status.textContent = 'Input gefocust (simulatie van ref focus bij mount)';
                                });
                            }
                        })();</script>
                </div>
                <pre><code>import React, { useEffect, useRef, useState } from 'react';

function ButtonWithRef() {
  const btnRef = useRef&lt;HTMLButtonElement | null&gt;(null);
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    btnRef.current?.focus();
  }, []);

  function handleClick(e: React.MouseEvent&lt;HTMLButtonElement&gt;) {
    setCount((c) =&gt; c + 1);
  }

  return (
    &lt;button ref={btnRef} onClick={handleClick}&gt;Kliks: {count}&lt;/button&gt;
  );
}</code></pre>
                <p>In deze website wordt React niet gebundeld, dus bovenstaande is een codevoorbeeld zonder live demo.
                </p>

                <h5>Angular</h5>
                <p>In Angular manipuleer je het DOM via templates en databinding; voor uitzonderingen kun je
                    <code>@ViewChild</code> en <code>Renderer2</code> gebruiken. Dit is veiliger voor SSR en
                    platformonafhankelijk.
                </p>
                <p>In Angular zal een beginnende TypeScript developer meestal niet veel direct <code>document</code>
                    gebruik nodig hebben. Typische interactie gaat via databinding: je bindt bijvoorbeeld met
                    <code>(click)="doSomething()"</code> in de template, en de methode <code>doSomething()</code> in je
                    component kan dan velden aanpassen die weer via <code>{{ }}</code> interpolatie getoond worden. Als
                    je toch een DOM‑element nodig hebt (bijv. om de hoogte of scrollpositie te meten), gebruik je
                    <code>ViewChild</code>. Let op: <code>document.getElementById</code> of soortgelijke directe
                    aanroepen werken wel, maar zijn lastiger te testen (in een Angular context) en gaan uit van een
                    aanwezige DOM (niet het geval bij server‑side rendering). Daarom: vermijd directe DOM‑toegang tenzij
                    noodzakelijk en gebruik bij voorkeur Angular’s eigen API’s.
                </p>
                <pre><code>// component.ts
@Component({ selector: 'app-demo', templateUrl: './demo.component.html' })
export class DemoComponent {
  @ViewChild('btn', { static: true }) btn!: ElementRef&lt;HTMLButtonElement&gt;;
  constructor(private renderer: Renderer2) {}
  ngAfterViewInit() {
    this.renderer.setProperty(this.btn.nativeElement, 'textContent', 'Hallo');
  }
}

// template.html
&lt;button #btn (click)="onClick()"&gt;Klik&lt;/button&gt;</code></pre>

                <p><strong>Waarom directe DOM‑manipulatie ontmoedigd wordt</strong></p>
                <ul>
                    <li>Het kan de performance en het lifecycle‑management van Angular doorkruisen.</li>
                    <li>Het maakt code minder compatibel met server‑side rendering of Web Worker scenario’s (geen echte
                        DOM).</li>
                </ul>

                <p><strong>Template reference variables + ViewChild</strong></p>
                <p>Geef een element in de template een referentie en injecteer het als <code>ElementRef</code> in je
                    component. Na <code>ngAfterViewInit</code> kun je het element benaderen.</p>
                <pre><code>// template.html
&lt;div #myDiv&gt;&lt;/div&gt;

// component.ts
@Component({ selector: 'app-example', templateUrl: './example.component.html' })
export class ExampleComponent implements AfterViewInit {
  @ViewChild('myDiv', { static: true }) myDivElem!: ElementRef&lt;HTMLDivElement&gt;;

  ngAfterViewInit() {
    this.myDivElem.nativeElement.textContent = 'Hallo!';
  }
}</code></pre>

                <p><strong>Renderer2 service</strong></p>
                <p>Gebruik <code>Renderer2</code> voor platform‑onafhankelijke en veiligere DOM‑bewerkingen.</p>
                <pre><code>import { Renderer2, ElementRef, AfterViewInit } from '@angular/core';
export class ExampleComponent implements AfterViewInit {
  constructor(private renderer: Renderer2, private el: ElementRef) {}
  ngAfterViewInit() {
    this.renderer.setStyle(this.el.nativeElement.querySelector('h1'), 'color', 'blue');
  }
}</code></pre>
                <p>Ook Angular wordt hier niet gebundeld; dit is een codevoorbeeld zonder live demo.</p>

                <h5>Algemene tip voor frameworks</h5>
                <p>Of je nu React, Angular, Vue of iets anders gebruikt, het principe blijft: TypeScript helpt je overal
                    waar je met DOM‑elementen te maken hebt. Ook in JSX of templating zal TypeScript types forceren.</p>
                <ul>
                    <li><strong>React</strong>: in JSX kun je events typeren, bv.
                        <code>onDrag={(e: React.DragEvent&lt;HTMLDivElement&gt;) =&gt; ...}</code>. Vaak is inferentie
                        voldoende, maar expliciet kan als je nauwkeurigheid wilt.
                    </li>
                    <li><strong>Angular</strong>: in templates zelden expliciete types nodig; bij
                        <code>@ViewChild</code>
                        geef je wel door, bv. <code>ElementRef&lt;HTMLDivElement&gt;</code>.
                    </li>
                    <li><strong>Refs/doorverwijzingen</strong>: bij eigen componentrefs (bijv. React
                        <code>forwardRef</code>) gebruik je generics of <code>RefObject&lt;HTMLElement&gt;</code> voor
                        type‑veiligheid.
                    </li>
                </ul>
                <p>Samenvattend: frameworks bieden hogere‑abstractie manieren om de UI te manipuleren, maar de
                    onderliggende DOM blijft hetzelfde. Soms moet je imperatieve DOM‑manipulatie doen binnen frameworks;
                    gebruik dan concepten zoals Refs (React) of ElementRef/Renderer2 (Angular). Dankzij TypeScript kan
                    dat zonder de veiligheid van types te verliezen.</p>

                <h5>Conclusie</h5>
                <p>DOM‑manipulatie is een essentieel onderdeel van webontwikkeling – het stelt ons in staat om de
                    statische HTML tot leven te wekken door elementen te zoeken en te wijzigen in reactie op input of
                    andere gebeurtenissen. TypeScript voegt hier een waardevolle laag van voorspelbaarheid en
                    veiligheid aan toe. We hebben in deze gids uitvoerig de belangrijkste technieken en eigenschappen
                    behandeld:</p>
                <ul>
                    <li><strong>DOM‑elementen selecteren</strong> met methodes als <code>getElementById</code> en
                        <code>querySelector(All)</code>, en hoe TypeScript daarbij aangeeft dat je met <code>null</code>
                        moet omgaan en direct van de juiste elementtypes gebruik kunt maken.
                    </li>
                    <li><strong>Type‑veilig werken met elementen</strong> door gebruik van TypeScript’s kennis van het
                        DOM: het vermijden van fouten zoals het benaderen van onbestaande properties, en technieken als
                        type guards en type casting (<code>as HTMLInputElement</code>) om specifieke eigenschappen
                        veilig te gebruiken.</li>
                    <li><strong>Inhoud en attributen manipuleren</strong>: <code>innerHTML</code> vs
                        <code>textContent</code>, classes beheren met <code>classList</code>, custom data opslaan met
                        <code>dataset</code>, form‑eigenschappen zoals <code>value</code>, en attributen instellen of
                        uitlezen via <code>setAttribute</code>/<code>getAttribute</code>.
                    </li>
                    <li><strong>Elementen dynamisch creëren en verwijderen</strong>: het gebruik van
                        <code>createElement</code> (met generics voor het juiste type), <code>appendChild</code> en
                        moderne methodes als <code>append</code>/<code>remove</code> om de DOM‑structuur te wijzigen.
                    </li>
                    <li><strong>Event handling</strong> in TypeScript: hoe <code>addEventListener</code> sterke types
                        geeft aan je event objecten, het correct gebruiken van event properties en waar nodig casten van
                        <code>event.target</code>, met voorbeelden van klik‑ en invoerevents.
                    </li>
                    <li><strong>Voorbeeldscenario’s</strong> van interactieve UI’s zonder frameworks (zoals de to‑do
                        lijst), om te tonen hoe deze concepten in samenhang werken in een mini‑project.</li>
                    <li><strong>Integratie met frameworks</strong>: in React via refs DOM‑elementen type‑veilig
                        benaderen en waarom directe DOM‑manipulatie meestal beperkt wordt; in Angular via
                        <code>ElementRef</code> en <code>Renderer2</code> voor compatibiliteit en veiligheid. In beide
                        gevallen helpen de juiste types (bijv. <code>ElementRef&lt;HTMLDivElement&gt;</code> of
                        <code>RefObject&lt;HTMLInputElement&gt;</code>).
                    </li>
                </ul>
                <p>Tot slot: Deze uitgebreide verkenning heeft laten zien dat geen informatie verloren is gegaan – alle
                    relevante aspecten van DOM‑manipulatie in TypeScript zijn behandeld. Je hoeft niet alles meteen uit
                    je hoofd te kennen, maar gebruik deze gids als naslag voor type‑veilige DOM‑manipulatie. Profiteer
                    van wat TypeScript biedt: de compiler helpt je om potentieel gevaarlijke situaties (zoals
                    null‑referenties of typevergissingen) vroeg te vinden, vóór je code in de browser draait.</p>

                <h5>Verdiepingsbronnen</h5>
                <ul>
                    <li><a href="https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html"
                            target="_blank" rel="noopener">TypeScript en DOM types</a></li>
                    <li><a href="https://developer.mozilla.org/docs/Web/API/Document_Object_Model" target="_blank"
                            rel="noopener">MDN: DOM</a></li>
                    <li><a href="https://developer.mozilla.org/docs/Web/API/Element" target="_blank" rel="noopener">MDN:
                            Element API</a></li>
                    <li><a href="https://developer.mozilla.org/docs/Web/API/EventTarget/addEventListener"
                            target="_blank" rel="noopener">MDN: addEventListener</a></li>
                    <li><a href="https://react.dev/learn" target="_blank" rel="noopener">React documentatie</a></li>
                    <li><a href="https://angular.io/guide/what-is-angular" target="_blank" rel="noopener">Angular
                            documentatie</a></li>
                    <li><a href="https://owasp.org/www-community/attacks/xss/" target="_blank" rel="noopener">OWASP:
                            XSS</a></li>
                </ul>
            </section>

            <section id="ts-cheatsheet">
                <h3>TypeScript Cheatsheet</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Concept</th>
                            <th>Syntaxis & Voorbeeld</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Basis Types</strong></td>
                            <td><code>let name: string;</code>, <code>let age: number;</code>,
                                <code>let active: boolean;</code>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Arrays & Tuples</strong></td>
                            <td><code>let list: number[];</code>, <code>let tuple: [string, number];</code></td>
                        </tr>
                        <tr>
                            <td><strong>Interfaces</strong></td>
                            <td><code>interface Person { name: string; }</code></td>
                        </tr>
                        <tr>
                            <td><strong>Classes</strong></td>
                            <td><code>class Animal { constructor(public name: string) {} }</code></td>
                        </tr>
                        <tr>
                            <td><strong>Functies</strong></td>
                            <td><code>function greet(name: string): string { return `Hi ${name}`; }</code></td>
                        </tr>
                        <tr>
                            <td><strong>Union Types</strong></td>
                            <td><code>let id: string | number;</code></td>
                        </tr>
                        <tr>
                            <td><strong>Generics</strong></td>
                            <td><code>function identity&lt;T&gt;(arg: T): T { return arg; }</code></td>
                        </tr>
                        <tr>
                            <td><strong>Enums</strong></td>
                            <td><code>enum Color { Red, Green, Blue }</code></td>
                        </tr>
                    </tbody>
                </table>
            </section>

        </div>

    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Responsive Sidebar Toggle Logic ---
            const menuToggle = document.getElementById('menu-toggle');
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('overlay');
            const sidebarLinks = document.querySelectorAll('#sidebar a');
            const topbar = document.getElementById('topbar');

            function closeSidebar() {
                sidebar.classList.remove('visible');
                overlay.classList.remove('visible');
            }

            menuToggle.addEventListener('click', () => {
                const willShow = !sidebar.classList.contains('visible');
                sidebar.classList.toggle('visible');
                overlay.classList.toggle('visible');
                menuToggle.setAttribute('aria-expanded', willShow ? 'true' : 'false');
            });

            overlay.addEventListener('click', () => {
                closeSidebar();
                menuToggle.setAttribute('aria-expanded', 'false');
            });

            sidebarLinks.forEach(link => {
                link.addEventListener('click', () => {
                    // Only close sidebar on mobile view
                    if (window.innerWidth <= 991) {
                        closeSidebar();
                    }
                });
            });

            // Ensure sidebar starts hidden on resize if switching to desktop
            window.addEventListener('resize', () => {
                if (window.innerWidth > 991) {
                    sidebar.classList.remove('visible');
                    overlay.classList.remove('visible');
                    menuToggle.setAttribute('aria-expanded', 'false');
                }
            });


            // --- Sidebar Active Link Logic (original) ---
            const sections = document.querySelectorAll('section[id]');
            const navLinks = document.querySelectorAll('#sidebar a');

            const observer = new IntersectionObserver((entries) => {
                let visibleSectionId = '';
                entries.forEach(entry => {
                    if (entry.isIntersecting && entry.intersectionRatio > 0) {
                        visibleSectionId = entry.target.id;
                    }
                });

                if (visibleSectionId) {
                    navLinks.forEach(link => {
                        link.classList.remove('active');
                        if (link.getAttribute('href').substring(1) === visibleSectionId) {
                            link.classList.add('active');
                        }
                    });
                }
            }, { rootMargin: "-40% 0px -60% 0px" });

            sections.forEach(section => {
                observer.observe(section);
            });

            // --- Exercise Solution Toggle Logic (original) ---
            document.querySelectorAll('.solution-btn').forEach(button => {
                button.addEventListener('click', () => {
                    const solutionDiv = button.nextElementSibling.nextElementSibling;
                    if (solutionDiv) {
                        solutionDiv.style.display = solutionDiv.style.display === 'block' ? 'none' : 'block';
                    }
                });
            });

            // --- Exercise Validation Logic (original) ---
            const validators = {
                'h1-01': (code) => {
                    const results = [];
                    if (!/<!DOCTYPE\s+html>/i.test(code)) results.push("Doctype ontbreekt of is incorrect.");
                    if (!/<html\s+lang="nl">/i.test(code)) results.push("`lang=\"nl\"` op `<html>` tag ontbreekt.");
                    if (!/<meta\s+charset="UTF-8">/i.test(code)) results.push("Meta charset UTF-8 ontbreekt.");
                    if (!/<meta\s+name="viewport"\s+content="width=device-width,\s*initial-scale=1.0">/i.test(code)) results.push("Viewport meta tag is incorrect.");
                    if (!/<title>.*<\/title>/i.test(code)) results.push("Title tag ontbreekt.");
                    return { success: results.length === 0, messages: results.length ? results : ["Correct!"] };
                },
                'h2-01': (code) => {
                    const results = [];
                    if (!/<header>[\s\S]*?<\/header>/i.test(code)) results.push("Header ontbreekt.");
                    if (!/<nav[\s\S]*?>[\s\S]*?<\/nav>/i.test(code)) results.push("Nav ontbreekt.");
                    if (!/<main>[\s\S]*?<\/main>/i.test(code)) results.push("Main ontbreekt.");
                    if (!/<article>[\s\S]*?<\/article>/i.test(code)) results.push("Article ontbreekt.");
                    if (!/<aside>[\s\S]*?<\/aside>/i.test(code)) results.push("Aside ontbreekt.");
                    if (!/<footer>[\s\S]*?<\/footer>/i.test(code)) results.push("Footer ontbreekt.");
                    return { success: results.length === 0, messages: results.length ? results : ["Correcte structuur!"] };
                },
                'h4-01': (code) => {
                    const results = [];
                    if (!/<caption>[\s\S]*?<\/caption>/i.test(code)) results.push("Caption ontbreekt.");
                    if ((code.match(/<th\s+scope="col"/gi) || []).length < 2) results.push("Minstens twee kolomkoppen (`th` met `scope=\"col\"`) zijn vereist.");
                    if ((code.match(/<th\s+scope="row"/gi) || []).length < 2) results.push("Minstens twee rijkoppen (`th` met `scope=\"row\"`) zijn vereist.");
                    return { success: results.length === 0, messages: results.length ? results : ["Correct!"] };
                },
                'h6-01': (code) => {
                    const results = [];
                    if (!/<label\s+for="email"/i.test(code)) results.push("Label voor e-mail ontbreekt of is incorrect gekoppeld.");
                    if (!/<input[^>]+id="email"/i.test(code)) results.push("Input voor e-mail heeft geen `id=\"email\"`.");
                    if (!/<label\s+for="password"/i.test(code)) results.push("Label voor wachtwoord ontbreekt.");
                    if (!/<input[^>]+id="password"/i.test(code)) results.push("Input voor wachtwoord heeft geen `id=\"password\"`.");
                    if (!/<input[^>]+type="email"[^>]+required/i.test(code)) results.push("E-mail input is niet `required`.");
                    return { success: results.length === 0, messages: results.length ? results : ["Correct!"] };
                },
                'c1-01': (code) => {
                    const results = [];
                    if (!/box-sizing:\s*border-box/i.test(code)) results.push("`box-sizing: border-box;` ontbreekt.");
                    if (!/width:\s*200px/i.test(code)) results.push("`width: 200px;` ontbreekt.");
                    return { success: results.length === 0, messages: results.length ? results : ["Correct!"] };
                },
                'c3-01': (code) => {
                    const results = [];
                    if (!/display:\s*grid/i.test(code)) results.push("`display: grid;` ontbreekt.");
                    if (!/grid-template-columns:\s*repeat\(\s*auto-fit,\s*minmax\(250px,\s*1fr\)\)/i.test(code.replace(/\s+/g, ' '))) results.push("De `grid-template-columns` regel is incorrect.");
                    return { success: results.length === 0, messages: results.length ? results : ["Correct!"] };
                },
                'c7-01': (code) => {
                    const results = [];
                    if (!/@media\s*\(\s*min-width:\s*600px\s*\)/i.test(code)) results.push("De media query conditie is incorrect.");
                    if (!/body\s*\{\s*background-color:\s*lightblue;\s*\}/i.test(code.replace(/\s+/g, ' '))) results.push("De stijlregel binnen de media query is incorrect.");
                    return { success: results.length === 0, messages: results.length ? results : ["Correct!"] };
                },
                'j5-01': (code) => {
                    try {
                        // Reset UI for test
                        const uiContainer = document.getElementById('ex-j5-01-ui');
                        const originalHTML = uiContainer.innerHTML;

                        const countSpan = uiContainer.querySelector('#clickCount');
                        countSpan.textContent = '0';

                        // Execute user code
                        const userFunction = new Function(code);
                        userFunction();

                        const btn = uiContainer.querySelector('#counterBtn');
                        btn.click();
                        btn.click();

                        const finalCount = parseInt(countSpan.textContent, 10);

                        // Cleanup
                        uiContainer.innerHTML = originalHTML;

                        if (finalCount === 2) {
                            return { success: true, messages: ["Test geslaagd! De teller werkt."] };
                        } else {
                            return { success: false, messages: [`Test mislukt. Verwachtte 2, kreeg ${finalCount}.`] };
                        }
                    } catch (e) {
                        return { success: false, messages: [`Runtime error: ${e.message}`] };
                    }
                },
                't4-01': (code) => {
                    // TypeScript can't be executed directly, so we do a simple string check
                    const results = [];
                    if (!/function\s+getFirstElement\s*<T>/.test(code)) results.push("Functie moet een generic type parameter `<T>` hebben.");
                    if (!/\(arr:\s*T\[\]\)/.test(code)) results.push("Argument `arr` moet van het type `T[]` zijn.");
                    if (!/:\s*T\s*\|\s*undefined/.test(code)) results.push("Return type moet `T | undefined` zijn.");
                    return { success: results.length === 0, messages: results.length ? results : ["Syntaxis ziet er correct uit!"] };
                }
            };

            document.querySelectorAll('.check-btn').forEach(button => {
                button.addEventListener('click', () => {
                    const exerciseId = button.dataset.exercise;
                    const textarea = document.getElementById(`ex-${exerciseId}`);
                    const resultDiv = button.nextElementSibling.nextElementSibling;

                    const validator = validators[exerciseId];
                    if (validator && textarea) {
                        const result = validator(textarea.value);
                        resultDiv.innerHTML = result.messages.join('<br>');
                        resultDiv.className = 'validator-result ' + (result.success ? 'success' : 'error');
                    } else {
                        resultDiv.innerHTML = 'Validator niet gevonden voor deze oefening.';
                        resultDiv.className = 'validator-result error';
                    }
                });
            });
        });
    </script>
</body>

</html>